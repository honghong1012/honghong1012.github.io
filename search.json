[{"title":"动态规划","url":"/2022/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"算法本质动态规划（Dynamic Programming),简称dp问题，dp中的每一个状态由上一个状态推导出来\n构建步骤\n确定dp table及其下标的含义\n确定递推公式\ndp数组初始化\n确定遍历顺序\n举例推导dp数组\n\ndebug方法\n打印tb table\n模拟dp table中的状态转移\n\nleetcode相关题目509.斐波那契数题目链接：https://leetcode-cn.com/problems/fibonacci-number/\n\n本题主要用于熟悉dp\n然而我的做法不是基于dp思路推导，选择了今天算法课上老师说的速度较快，内存占用较小的方法（避免了递归，重复计算）class Solution:    def fib(self, n: int) -&gt; int:        num = []        num.append(0)        num.append(1)        for i in range(n):            temp = num[1]            num[1] = num[0] + num[1]            num[0] = temp        return num[0]\n\n70.爬楼梯（climbing stairs）题目链接：https://leetcode-cn.com/problems/climbing-stairs/\n\ndp[i]：爬到第i层楼的方法数\n由于本题中一次只能跨1或2个台阶，所以dp[i] = dp[i-1] + dp[i-2]\ndp[0]的初始化，本题其实无需讨论，但要做到心里有数\n延伸到一步跨不同台阶数到做法class Solution:    def climbStairs(self, n: int) -&gt; int:        dp = [0] * (n+1)        dp[0] = 1        for i in range(n+1):            for j in range(1,3):                if i &gt;= j:                    dp[i] += dp[i-j] # j的范围可改 适应不同的跨过台阶数        return dp[-1]\n\n746.使用最小花费爬楼梯（min cost climbing stairs)题目链接：\n\ndp[i]:爬到第i层的最小花费\ndp的递推公式其实有两种，每种都考虑到了，但对于不同的递推公式，有不同的初始化\ndp[i] = min(dp[i-1],dp[i-2]) + cost[i] 或 dp[i] = min(dp[i-1]+cost[i-i], dp[i-2]+cost[i-2])我的版本：class Solution:    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:        dp = [0] * (len(cost)+1)        if len(cost) == 2:            return min(cost)        for i in range(2, len(cost)+1):            dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])        return dp[-1]\n\n题解版本：\nclass Solution:    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:        dp = [0] * (len(cost))        dp[0] = cost[0]        dp[1] = cost[1]        for i in range(2, len(cost)):            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]        return min(dp[len(cost) - 1], dp[len(cost) - 2])\n\n62.不同路径（unique paths)题目链接：https://leetcode-cn.com/problems/unique-paths/\n\n题目结合高中数学的知识可推导出dp的递推公式\ndp[i][j] = dp[i-1][j] + dp[i][j-1] 因为只能向右走或者向下走\n所以就引出dp数组的初始化问题，我采用了遍历过程中初始化的方法，也可以直接全部初始化为1，修改遍历的起始点我的版本：class Solution:    def uniquePaths(self, m: int, n: int) -&gt; int:        dp = [[0] * n] * m        for i in range(0, m):            for j in range(0, n):                if i != 0 and j != 0:                    dp[i][j] = dp[i-1][j] + dp[i][j-1]                else:                    dp[i][j] = 1        return dp[-1][-1]\n\n63.不同路径II题目链接：https://leetcode-cn.com/problems/unique-paths-ii/submissions/\n\n在62的基础上，多增设了障碍\n思考过程其实与62相似，dp递推公式类似，而遇到障碍的时候，该维度的dp数组就置0，意味着没有别的通路能够通往此处/或者从此处走出\n判断条件要加上，第一格，第一行，第一列的区别我的版本：class Solution:    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:        m = len(obstacleGrid)        n = len(obstacleGrid[0])        dp = [[0]*n]*m # 构造dp table        for i in range(m):            for j in range(n):                if i != 0 and j != 0:                    if obstacleGrid[i][j] != 1:                        dp[i][j] = dp[i-1][j] + dp[i][j-1]                    else:                        dp[i][j] = 0                elif i == 0 and j != 0: # 第一行                    if obstacleGrid[i][j]!= 1:                        dp[i][j] = dp[i][j-1]                    else:                        dp[i][j] = 0                elif j == 0 and i != 0: # 第一列                    if obstacleGrid[i][j]!= 1:                        dp[i][j] = dp[i-1][j]                    else:                        dp[i][j] = 0                else: # 第一格的情况                    if obstacleGrid[i][j]!= 1:                        dp[i][j] = 1                    else:                        dp[i][j] = 0        return dp[-1][-1]\n\n343.整数拆分题目链接：https://leetcode-cn.com/problems/integer-break/submissions/\n\n本题关键在于如何确定递推公式，将数拆分的过程\n严格意义上dp[0]和dp[1]无需赋值\nO(n^2)class Solution:    def integerBreak(self, n: int) -&gt; int:        dp = [0] * (n+1)        dp[2] = 1        for i in range(3, n+1):            for j in range(1, i-1):                # 假设对正整数i拆分出的第一个数为j（此时遍历j）                # 若将i拆封成两部分：i与i-j的乘积，则此时拆分部分乘积为j*(i-j)                # 若继续将（i-j）进行拆分，则此时拆分部分乘积为j*dp[i-j]                dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j])) # 不断迭代最大值        return dp[n]\n\n96.不同的二叉搜索树(unique binary search trees)题目链接：https://leetcode-cn.com/problems/unique-binary-search-trees/submissions/\n\n本题堪称最近最有成就感的一题（大概因为想了很久吧）\n其实线索可以从leetcode上的图中观察得出，下图中已经用颜色分类，首先可以看出树的形状是对称的，接着观察以1为头节点的下半部分，实际上是当n=2时bst的形状\n最后结合二叉搜索树左右节点的特点，则可以知道dp的递推公式，由此也可以想到初始化dp[0]=1(理论上也符合)\n\n我的版本：\nclass Solution:    def numTrees(self, n: int) -&gt; int:        dp = [0] * (n+1)        dp[0] = 1        dp[1] = 1        if n == 1: return 1        for i in range(2, n+1):            for j in range(0, int(i/2)):                dp[i] += 2*dp[j]*dp[i-1-j] # 相对于题解版本，我稍微减小了内层循环的长度，实际上相差不多            if i % 2 != 0: # 加上奇偶判断                dp[i] += dp[int((i-1)/2)]*dp[int((i-1)/2)]        return dp[n]\n\n416.分割等和子集partition equal subset sum题目链接：https://leetcode-cn.com/problems/partition-equal-subset-sum/\n\n实际上这题没有理解得十分透彻\n使用了滚动数组，得注意dp的定义以及遍历顺序class Solution:    def canPartition(self, nums: List[int]) -&gt; bool:        target = sum(nums)        if target % 2 != 0:            return False        target //= 2        dp = [0] * 10001        for i in range(len(nums)):            for j in range(target, nums[i]-1, -1):                dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])        return dp[target] == target\n\ncs336 homeworkhw2.1 checker collectorConsider the following single-player game played on a game board with dimensions 4 × n.  Each square of the game board has a prize given by a positive real number.  You would like to collect prizes to maximize the sum of prizes; however, you have to satisfy the following no two adjacent prizes can be collected.  In other words, if you collect the prize at location (i,j), you cannot collect the prize at (i±1,j) or (i,j±1) (assuming those indices exist).   For example, if you checkered the game board, then one solution could be to take all the black squares, another solution could be to take all the white squares.  You could also take some white squares and some black squares as long as none of are next to each other\nInput：\n\nA 4 × n matrix Q, with prize values qijOutput: The subset S of the entries of qij such that:\nif (i,j) in S, then (i±1,j)∉ S and (i,j±1)∉S.\nΣ(i,j)∈S qij is maximized.\n\ndef print_dp(matrix):    n = len(matrix[0])    # base case? need minimum?    d = [[0 for i in range(8)] for j in range(n + 1)]  # d[][]    val = [[0 for i in range(8)] for j in range(n + 1)]  # val(j,c)    C = [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;, &#x27;0001&#x27;, &#x27;1010&#x27;, &#x27;0101&#x27;, &#x27;1001&#x27;]    idx_c = &#123;&#x27;0000&#x27;: 0, &#x27;1000&#x27;: 1, &#x27;0100&#x27;: 2, &#x27;0010&#x27;: 3, &#x27;0001&#x27;: 4, &#x27;1010&#x27;: 5, &#x27;0101&#x27;: 6, &#x27;1001&#x27;: 7&#125;    # compute all the possible solution/compatible    compatible = &#123;&#x27;0000&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;, &#x27;0001&#x27;, &#x27;1010&#x27;, &#x27;0101&#x27;, &#x27;1001&#x27;],                  &#x27;1000&#x27;: [&#x27;0000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;, &#x27;0001&#x27;, &#x27;0101&#x27;],                  &#x27;0100&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0010&#x27;, &#x27;0001&#x27;, &#x27;1010&#x27;, &#x27;1001&#x27;],                  &#x27;0010&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0100&#x27;, &#x27;0001&#x27;, &#x27;0101&#x27;, &#x27;1001&#x27;],                  &#x27;0001&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;, &#x27;1010&#x27;],                  &#x27;1010&#x27;: [&#x27;0000&#x27;, &#x27;0100&#x27;, &#x27;0001&#x27;, &#x27;0101&#x27;],                  &#x27;0101&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0010&#x27;, &#x27;1010&#x27;],                  &#x27;1001&#x27;: [&#x27;0000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;]&#125;    # compute all the val(j,c)    for j in range(1, n+1):        for index, c in enumerate(C):            if c == &#x27;0000&#x27;:                val[j][index] = 0            if c == &#x27;1000&#x27;:                val[j][index] = matrix[0][j-1]            if c == &#x27;0100&#x27;:                val[j][index] = matrix[1][j-1]            if c == &#x27;0010&#x27;:                val[j][index] = matrix[2][j-1]            if c == &#x27;0001&#x27;:                val[j][index] = matrix[3][j-1]            if c == &#x27;1010&#x27;:                val[j][index] = matrix[0][j-1] + matrix[2][j-1]            if c == &#x27;0101&#x27;:                val[j][index] = matrix[1][j-1] + matrix[3][j-1]            if c == &#x27;1001&#x27;:                val[j][index] = matrix[0][j-1] + matrix[3][j-1]    # dp    for j in range(1, n+1):        for index, c in enumerate(C):            for id, m in enumerate(compatible[c]):                idx = idx_c[m]                d[j][index] = max(d[j][index], val[j][idx] + d[j-1][idx])    # debug    print(d)    # optimal prize    print(max(d[n][0:7]))# Press the green button in the gutter to run the script.if __name__ == &#x27;__main__&#x27;:    # design a 4*n matrix m, we use 4*5 as an example    M = [[1, 10, 1, 10, 1],         [10, 1, 10, 1, 10],         [2, 10, 2, 2, 1],         [3, 2, 10, 3, 2]]    C = [[0, 1, 2, 3, 9, 2, 12, 13, 14, 15],         [2, 5, 6, 1, 9, 2, 1, 3, 9, 12],         [2, 10, 6, 2, 5, 7, 2, 5, 6, 8],         [3, 2, 7, 8, 1, 4, 2, 6, 7, 8],         ]    N = [[1, 2, 3],         [5, 6, 1],         [10, 6, 2],         [20, 7, 8]]    print_dp(M)","categories":["刷题笔记"]},{"title":"巴斯克芝士蛋糕","url":"/2021/12/27/%E5%B7%B4%E6%96%AF%E5%85%8B%E8%8A%9D%E5%A3%AB%E8%9B%8B%E7%B3%95/","content":"材料（此配方可制作6寸巴斯克芝士，8寸则所有用量乘以2）\n奶油奶酪 cream cheese: 350g\n细砂糖 sugar: 75g\n蛋黄 egg yolk: 3个\n全蛋 egg（大): 2个\n淡奶油 heavy whipping cream: 150g\n牛奶 whole milk: 50g\n玉米淀粉/低筋面粉 corn starch/cake flour: 12g\n\n简易做法版本（无电动打蛋器/无料理棒/无筛）\n奶油奶酪加入细砂糖，隔水加热，搅拌至顺滑（不能过火，有可能导致水油分离）\n\n\n\n分次加入3个蛋黄，2个全蛋，搅拌至吸收再加入下一个（鸡蛋可提前从冰箱取出放至室温，减少水油分离可能性）\n\n \n\n加入牛奶，搅拌均匀（有抹茶粉/可可粉则在牛奶后加入）\n\n加入淡奶油，搅拌均匀\n\n加入玉米淀粉，搅拌均匀\n\n烤箱预热，模具铺入烘焙纸（烘焙纸打湿/弄皱后更容易贴合模具）\n\n烤箱中层，220度22-23mins，提前查看表皮上色，上色不够深则移入烤箱上层烘烤2-3mins（我的公寓烤箱拧至一半多些，烘烤20mins后移入烤箱上层，3-4mins）\n\n出炉冷却后保鲜膜包裹起来，无需脱模，冷藏一夜\n\n \n\n可把部分剩余淡奶油打发至六分，结合水果进行装饰\n\n  \n\n\n \n\n\n","categories":["食谱"]},{"title":"链表linked_list","url":"/2022/01/12/%E9%93%BE%E8%A1%A8linked-list/","content":"关于链表作为曾经只用c写链表的人，只能说对链表厌恶至极。确实换了python刷题之后，链表操作更加简单了，但那种内心深处指针移来移去的恐惧还没有消失哈哈哈。不过，越是害怕的东西越要战胜，由于学期任务紧，关于链表的一些技巧后面再补充，这里先post一些挤出时间刷的题吧！\nleetcode相关题目24.两两交换链表中的节点 swap nodes in pair题目链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n本题需要三个指针，一个指向pair的前一个节点，剩下两个分别指向pair里的两个nodes\n是否需要继续交换则通过判断pre是否同时存在next和next.next\npre初始可定位在虚拟头节点，若上述判断成立，则使cur和post指向pair（若不成立则代表无需继续交换）# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:\n\n19.删除链表倒数第n个节点remove nth node from end of list题目链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\n\n使用双指针，只需遍历一遍\nslow让fast先走n+1步，n+1是因为单向链表删除操作需要定位在前一个节点# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:\n\n","categories":["刷题笔记"]},{"title":"Hello World","url":"/2021/12/18/hello-world/","content":"Welcome to my blog! This is my very first post. Actually I’ve been setting up my blog for a long time(even though I often found excuses not to implement anything on the website)\n"},{"title":"贪心算法（greedy algorithm)","url":"/2021/12/21/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88greedy-algorithm/","content":"算法本质选择每一阶段的局部最优，从而达到全局最优化\n算法应用场景\n无固定套路，常识性推导\n想不到相应的反例，可以试试贪心\n贪心算法跑过测试用例即可，或自圆其说  \n\n贪心一般解题步骤\n将原本问题分解为若干子问题\n找出适合的贪心策略\n求出每个子问题最优解\n将局部最优解堆叠成全局最优解\n\nleetcode相关题目455.分发饼干(assign cookies)题目链接：\n\n数组-&gt;升序排列，遍历\n可用cookies的index来减少for循环层数\n两种思路\n时间复杂度 O(n)\n\nclass solution:    def find(self, g:List[int], s:List[int]) -&gt; int:        g.sort() # 先进行升序排列        s.sort()        index = 0 # 利用cookies下标代替两层for循环        for i in range(len(s)):            if index &lt; len(g) and s[i] &gt;= g[index]: # ！满足的标准和下标移动                index += 1        return index\n\n376.摆动序列（wiggle subsequence)题目链接：\n\n每个峰值的判断（判断单调区间）\n最右峰值的判断\n时间复杂度 O(n)\n\nclass solution:    def wiggleMaxLength(self, nums:List[int]) -&gt; int:        res = 1        cuffix = 0        prefix = 0        for i in range(len(nums)-1):            curfix = nums[i+1] - nums[i]            if curfix * prefix &lt;= 0 and curfix != 0:                res += 1                prefix = curfix        return res \n\n53.最大子序和（）题目链接：\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        if nums is None:            return nums        temp = 0        maxsum = nums[0]        for i in range(len(nums)):            temp += nums[i]            if temp &gt; maxsum:                maxsum = temp            if temp &lt; 0:                temp = 0        return maxsum\n\n122.买卖股票的最佳时机（best time to buy and sell stock2)题目链接：\n\n我的做法想的太过复杂，使用了判断单调上升区间卖出计算\n时间复杂度 O(n)  \n\nclass Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        prefix, curfix, profit = 0, 0, 0        begin, end = -1, -1        for i in range(len(prices)-1):            curfix = prices[i+1] - prices[i]            if prefix * curfix &lt;= 0 and curfix &gt; 0: #上升区间起点                begin = prices[i]            if prefix * curfix &lt;= 0 and curfix &lt;= 0 and prefix &gt; 0: #上升区间终点                end = prices[i]            if i+1 == len(prices)-1 and prices[-1] - prices[-2] &gt; 0: #判断list末尾是否为上升区间终点                end = prices[i+1]            if begin != -1 and end != -1: #只有同时找到起点和终点时才能组成一个单调区间                profit += (end - begin)                end, begin = -1, -1            prefix = curfix        return profit\n\n题解版本：\n\n实际上只关注正利润，由于题目中股票持有和卖出的特性\n只要利润为正，就记入总利润中，此特性也可以在画的图中展现出来class Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        result = 0        for i in range(1, len(prices)):            result += max(prices[i] - prices[i - 1], 0)        return result\n\n55.跳跃游戏（jump game）题目链接：https://leetcode-cn.com/problems/jump-game/\n\n局部最优解：可跳跃的最大覆盖范围 整体：能否覆盖到终点\nindex：棋子跳跃的下标 cover：棋子当下能够覆盖到的最远下标\n利用cover限制index，并作为while循环的中断条件class Solution:    def canJump(self, nums: List[int]) -&gt; bool:        if len(nums) == 1:            return True        cover = 0        index = 0        while index &lt;= cover:            cover = max(index+nums[index], cover)            if cover &gt;= len(nums) - 1:                return True            index += 1        return False\n\n45.跳跃游戏II题目链接：https://leetcode-cn.com/problems/jump-game-ii/submissions/本题与55相比，不同之处：45输出能否覆盖终点，本题输出覆盖终点的最小步数\n\n局部：可移动距离中尽可能多走，未到终点则步数加1；整体：一步尽可能多走，达到最小步数\ncurCover：当前可覆盖 nextCover：下一步可覆盖\n注意棋子跳跃的时候边界范围的设定class Solution:    def jump(self, nums: List[int]) -&gt; int:        if len(nums) == 1:            return 0        index, curCover, nextCover = 0, 0, 0        step = 0        while index &lt; len(nums) - 1:            nextCover = max(index+nums[index], nextCover)            if index == curCover:                curCover = nextCover                step += 1            index += 1        return step\n\n1005.k次取反后最大化的数组之和(maximize sum of array after k negations)题目链接：https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/\n\n数组按绝对值由大到小排序\n遍历数组，遇到负数则进行取反，k-=1；k=0时跳出循环\n若遍历完全还有剩余k，则取数组最后一个数（最小的数值）反复取反\nO(n)class Solution:    def largestSumAfterKNegations(self, nums: List[int], k: int) -&gt; int:        nums = sorted(nums, key=abs,reverse=True)        for i in range(len(nums)):            if k &gt; 0:                if nums[i] &lt; 0:                    nums[i] = -nums[i]                    k -= 1                else:                    continue            else:                break        if k &gt; 0:            if k % 2 == 1:                nums[-1] = -nums[-1]        return sum(nums)\n\n134.加油站（gas station）题目链接：https://leetcode-cn.com/problems/gas-station/该题和某公司oa中的魔毯问题一样\n\n如果sum(gas) &lt; sum(cost),那么汽车不可能走完一圈\nres[i] = gas[i] - cost[i]class Solution:    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int:        start, cursum, totalsum =0, 0, 0        for i in range(len(gas)):            cursum += gas[i] - cost[i]            totalsum += gas[i] - cost[i]            if cursum &lt; 0:                start = i + 1                cursum = 0        if totalsum &lt; 0:            return -1        return start\n\n135.分发糖果（candy）题目链接：https://leetcode-cn.com/problems/candy/\n\n关键是思考时不能顾此失彼，从左到右和从右到左遍历一遍\n注意第二次遍历时要考虑到取max\npython的后序遍历range（start,stop,step)class Solution:    def candy(self, ratings: List[int]) -&gt; int:        candyvec = [1] * len(ratings)        for i in range(1, len(ratings)):            if ratings[i] &gt; ratings[i-1]:                candyvec[i] = candyvec[i-1] + 1        for j in range(len(ratings)-2, -1, -1):            if ratings[j] &gt; ratings[j+1]:                candyvec[j] = max(candyvec[j], candyvec[j+1]+1)        return sum(candyvec)\n\n860.柠檬水找零（lemonade change）题目链接：https://leetcode-cn.com/problems/lemonade-change/\n\n常识做题\n后续可优化存储和判断，有部分冗余判断\n没有记录20元的张数，因为找零用不了20元class Solution:    def lemonadeChange(self, bills: List[int]) -&gt; bool:        if bills[0] != 5:            return False        change = [0] * 2        for i in range(len(bills)):            if bills[i] == 5: # 情况1 遇到5直接收下                change[0] += 1            elif bills[i] == 10: # 情况2 遇到10则检查有无5                if change[0] &lt; 1:                    return False                else:                    change[0] -= 1                    change[1] += 1            else: # 情况3 遇到20 先用10元找零，不够再用3张5元                if change[0]*5+change[1]*10&lt;15:                    return False                else:                    if change[0] &lt; 1:                        return False                    else:                        if change[1] &gt;= 1:                            change[1] -= 1                            change[0] -= 1                        else:                            if change[0] &lt; 3:                                return False                            else:                                change[0] -= 3        return True\n\n406.根据身高重建队列（queue restruction by height）题目链接：\n\n本题与分发糖果类似，确定一个维度排序，再根据另外一个维度插入\n先按身高维度 从大到小进行排序：确保前面的节点都比自身高\n后面queue的insert 根据另一个维度进行插入，结合list.insert(index, element)，直接根据第二个维度确定插入的下标class Solution:    def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]:        people = sorted(people, key=lambda x: (-x[0], x[1]))        queue = []        for p in people:            queue.insert(p[1], p)        # print(people)        # print(queue)        return queue\n\n452.用最少数量的箭引爆气球（minimum number of arrows to burst ballons)题目链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/\n\n对区间重叠的问题，有意识从维度排序先入手（本题以任一维度排序都行）\n后序思考太复杂，判断重叠只需要上一区间上边界与下一区间的下边界\n完成判断后要更新边界，以便后续判断class Solution:    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:        points = sorted(points, key= lambda x: (x[0], x[1]))        res = 1        for i in range(1,len(points)):            if points[i][0] &gt; points[i-1][1]:                res += 1            else:                points[i][1] = min(points[i-1][1], points[i][1])        return res\n\n435.无重叠区间(non-overlapping intervals)题目链接：https://leetcode-cn.com/problems/non-overlapping-intervals/\n\n解题思路和452类似\n我的ac和题解版本不太一样\n题解思路：最小移除区间数量 = 总区间数量 - 最大非交叉区间数量题解版本：class Solution:    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        intervals = sorted(intervals, key= lambda x:(x[1])) # 按照右边界排序        count  = 1        end = intervals[0][1]        for i in range(1, len(intervals)):            if intervals[i][0] &gt;= end:                count += 1                end = intervals[i][1]        return len(intervals) - count\n\n我的版本：\nclass Solution:    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        intervals = sorted(intervals, key= lambda x:(x[0])) # 按照左边界排序        res = 0        for i in range(1, len(intervals)):            if intervals[i][0] &lt; intervals[i-1][1]:                res += 1                intervals[i][1] = min(intervals[i-1][1], intervals[i][1])        return res\n\n763.划分字母区间（partition labels）题目链接：https://leetcode-cn.com/problems/partition-labels/\n\n第一次遍历list记录该字母出现的最远下标\n巧妙思路： 第二次遍历字符串时，若index==字母的最远index，则说明此处是分割点（无需记录字母的起始位置）\n别忘更新下一个分割区间起始点的位置：上一个分割index+1class Solution:    def partitionLabels(self, s: str) -&gt; List[int]:        character = [0] * 26 # 记录字符出现的最远位置的下标        for i in range(len(s)):            character[ord(s[i])-ord(&#x27;a&#x27;)] = i        start, end = 0, 0        res = []        for j in range(len(s)):            end = max(end, character[ord(s[j])-ord(&#x27;a&#x27;)])            if end == j:                res.append(end - start + 1)                start = j + 1        return res\n\n56.合并区间（merge intervals）题目链接：https://leetcode-cn.com/problems/merge-intervals/\n\n同样地，先对数组进行按第一维度排序\n通过和res中上一个数组的第二维度进行比较，如果重叠则直接更新第二维度，不重叠则append新的数组class Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x:x[0])        res = []        res.append([intervals[0][0], intervals[0][1]])        for i in range(1, len(intervals)):            if intervals[i][0] &lt;= res[-1][1]:                res[-1][1] = max(res[-1][1], intervals[i][1])            else:                res.append([intervals[i][0],intervals[i][1]])        return res\n\n738.单调递增的数字（monotone increasing digits)题目链接：https://leetcode-cn.com/problems/monotone-increasing-digits/submissions/\n\n首先要观察到判断规律\n从后向前遍历更能利用到数字条件，不用分类讨论下一个数字是大于等于的不同情况\n注意列表/字符串/字符等相互转化的方法 以及填满列表的方法class Solution:    def monotoneIncreasingDigits(self, n: int) -&gt; int:        if n &lt;= 9: return n        if n == 10: return 9        num = list(str(n))        for i in range(len(num)-1,0,-1):            if num[i] &lt; num[i-1]:                num[i-1] = str(int(num[i-1])-1)                num[i:] = &quot;9&quot; * (len(num) - i)        return int(&quot;&quot;.join(num))\n\n","categories":["刷题笔记"]},{"title":"面试准备","url":"/2022/01/24/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/","content":"leetcode原题数组和字符串1.两数之和\nbrute force\n\nn = len(nums)for i in range(n):    for j in range(i+1, n):        if nums[i] + nums[j] == target:            return [i, j]return []\n\n哈希表解决target-x问题table = &#123;&#125;for idx, num in enumerate(nums):    if target-num in table:        return [table[target-num], idx]    else:        table[nums[idx]] = idxreturn []\n\n3.无重复子串的最长字符串\n滑动窗口，哈希记录出现字符的下标\nO(n)class Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        k, res = -1, 0        table = &#123;&#125;        for ix, char in enumerate(s):            if char in table and table[char] &gt; k:                k = table[char] # 定位到重复字符的下标作为字符串起始idx                table[char] = ix # 更新字符下标            else:                table[char] = ix                res = max(res, ix-k)        return res\n\n4.寻找两个有序数组的中位数\n说实话，还没看懂题解class Solution:    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        if len(nums1) &gt; len(nums2):            return self.findMedianSortedArrays(nums2, nums1)        infinty = 2**40        m, n = len(nums1), len(nums2)        left, right = 0, m        # median1：前一部分的最大值        # median2：后一部分的最小值        median1, median2 = 0, 0        while left &lt;= right:            # 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]            # // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]            i = (left + right) // 2            j = (m + n + 1) // 2 - i            # nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]            nums_im1 = (-infinty if i == 0 else nums1[i - 1])            nums_i = (infinty if i == m else nums1[i])            nums_jm1 = (-infinty if j == 0 else nums2[j - 1])            nums_j = (infinty if j == n else nums2[j])            if nums_im1 &lt;= nums_j:                median1, median2 = max(nums_im1, nums_jm1), min(nums_i, nums_j)                left = i + 1            else:                right = i - 1        return (median1 + median2) / 2 if (m + n) % 2 == 0 else median1\n\n5.盛最多水的容器\n经典面试题，双指针法 O(n)\n左右指针分别定位在数组头部和尾部，移动数值较小一端\n理解该方法的正确性class Solution:    def maxArea(self, height: List[int]) -&gt; int:        left, right = 0, len(height) - 1        res = 0        while left &lt; right:            area = (right - left) * min(height[left], height[right])            res = max(res, area)            if height[left] &lt;= height[right]:                left += 1            else:                right -= 1        return res\n\n13.罗马数字转整数\n考虑到罗马数字的特性，一开始使用了双指针（但其实没必要）O(n)\n用字典存储数值，每次比较，只需要对slow index的数值进行操作，return之前记得把最后一个数值加上\n纯粹自己的解法class Solution:    def romanToInt(self, s: str) -&gt; int:        roman = &#123;&quot;I&quot;:1,&quot;V&quot;:5, &quot;X&quot;: 10, &quot;L&quot;:50, &quot;C&quot;:100, &quot;D&quot;:500, &quot;M&quot;: 1000&#125;        s = list(s)        if len(s) == 1:            return roman[s[0]]        res = 0        for i in range(len(s)-1):            if roman[s[i+1]] &lt;= roman[s[i]]:                res += roman[s[i]]            else:                res -= roman[s[i]]        res += roman[s[-1]]        return res\n\n12.整数转罗马数字\n和罗马数字表达特性有关， 字典存储， 固定组合 O(n)\n尽可能选择最大的数值，字典存储数值与字符对， list append相应的字符class Solution:    def intToRoman(self, num: int) -&gt; str:        dic = [            (1000, &quot;M&quot;),(900, &quot;CM&quot;),(500, &quot;D&quot;), (400, &quot;CD&quot;),(100, &quot;C&quot;), (90, &quot;XC&quot;),(50, &quot;L&quot;), (40, &quot;XL&quot;),(10, &quot;X&quot;), (9, &quot;IX&quot;), (5, &quot;V&quot;), (4, &quot;IV&quot;), (1, &quot;I&quot;)        ]        roman = []        for value, symbol in dic:            while num &gt;= value:                num -= value                roman.append(symbol)            if num == 0:                break        return &quot;&quot;.join(roman)\n\n49.字母异位词分组\n实际上调用了python里的包 collections\ncollections.defaultdict(list) 返回一个空的dict，里面的value为空的list类型\n字母异位词包含的字符一样，所以sorted之后返回的list都是一样的\n以sorted之后的str‘为key，而str则append进相应的value‘\n注意返回的时候 list(mp.values())， values返回一个iterable类型class Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        mp = collections.defaultdict(list)        for st in strs:            key = &quot;&quot;.join(sorted(st))            mp[key].append(st)        return list(mp.values())\n\n48.旋转图像\n水平翻转 + 主对角线翻转 (注意坐标的改变规律以及两层循环的不同)\nO(n^2) class Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify matrix in-place instead.        &quot;&quot;&quot;        n = len(matrix[0])        # 水平翻转（限制 i 的遍历范围）        for i in range(n // 2):            for j in range(n):                matrix[i][j], matrix[n - i - 1][j]  = matrix[n - i - 1][j], matrix[i][j]        # 主对角线翻转（限制j的遍历范围）        for i in range(n):            for j in range(i):                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]        \n\n15.三数之和\n双指针 + 排序\n去重逻辑比较复杂 循环开始前需要去重，找到满足条件的一个三元组之后需要去重\n边界例子： 如果第一个指针指向的数已经大于0，直接返回res；去重结束之后同样需要收缩两个边界指针class Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        res = []        n = len(nums)        nums = sorted(nums)        for i in range(n):            left = i + 1            right = n - 1            # 边界条件，节省时间            if nums[i] &gt; 0:                return res            # 循环前去重            if i &gt; 0 and nums[i] == nums[i - 1]:                continue            while left &lt; right:                total = nums[i] + nums[left] + nums[right]                if total &gt; 0:                    right -= 1                elif total &lt; 0:                    left += 1                else:                    res.append([nums[i],nums[left],nums[right]])                    # 找到正确答案后去重                    while left &lt; right and nums[right-1] == nums[right]:                        right -= 1                    while left &lt; right and nums[left+1] == nums[left]:                        left += 1                    # 找到正确答案后边界条件同时收缩                    right -= 1                    left += 1        return res     \n16.最接近的三数之和\n大致思路和上题一样 排序+双指针\n细节：res先设置成最大值；循环前去重；找到答案后去重（顺序）\n\nclass Solution:    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:        res = 10**7        n = len(nums)        # 排序        nums = sorted(nums)        for i in range(n):            # 循环前去重            if i &gt; 0 and nums[i-1] == nums[i]:                continue            # 因为此处是寻找与目标值最接近的总和，这里就不能通过判断第一位大于target而中止循环            left = i + 1             right = n - 1            while left &lt; right:                total = nums[i] + nums[left] + nums[right]                if abs(total - target) &lt;= abs(res - target):                    res = total                # 注意更新结果后的去重的顺序，去重再收缩边界                if total &lt; target:                    while left &lt; right and nums[left + 1] == nums[left]:                        left += 1                    left += 1                elif total &gt; target:                    while left &lt; right and nums[right - 1] == nums[right]:                        right -= 1                    right -= 1                else:                    return target        return res\n\n28.实现strStr（kmp算法）\nkmp算法需要多复习，关键在于next数组的构建，文本串和字符串匹配的过程 O(n+m)class Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        # 如果模式串为空，则返回0（在面试中可以问这个问题）        if needle == &quot;&quot;:            return 0        # 构建空next数组        nex = [0] * len(needle)        def findnext(nex:List[int], s:str):            # 初始化j为前缀起始，            j = -1            nex[0] = j            # i为后缀起始，定位为1            for i in range(1, len(s)):                while j &gt;= 0 and s[i] != s[j+1]: # 前后缀不同                    # 找j+1前一个元素在next里的值，赋值给j                    j = nex[j]                if s[i] == s[j+1]: # 前后缀相同                    # 指针往后移动                    j += 1                # 赋值到相应的后缀next数值中                nex[i] = j            return nex        # 构建模式串的next数组        Next = findnext(nex, needle)        j = -1        # 此处的i定位在文本串起始处 为0        for i in range(len(haystack)):            while j &gt;= 0 and haystack[i] != needle[j+1]:                j = Next[j]            if haystack[i] == needle[j+1]:                j += 1            if j == len(needle) - 1:                return (i - len(needle) + 1)        return -1\n\n8.字符串转换整数\n不太知道为什么美区企业题库里有这道题，但还是得硬着头皮做\n题解是用有限状态机写的，不使用ifelse来判断\n实际上得考虑边界条件，就当是练习一下怎么用python写class了INT_MAX = 2**31 -1INT_MIN = -2**31class Dfa:    def __init__(self):        self.state = &#x27;start&#x27;        self.sign = 1        self.ans = 0        # 关键是这个状态转换表，把表画出来之后就很容易了        self.table = &#123;            &#x27;start&#x27;: [&#x27;start&#x27;, &#x27;signed&#x27;, &#x27;in_num&#x27;, &#x27;end&#x27;],            &#x27;signed&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_num&#x27;, &#x27;end&#x27;],            &#x27;in_num&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_num&#x27;, &#x27;end&#x27;],            &#x27;end&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;]        &#125;    # 根据输入的字符和当前状态寻找下一转换状态    def get_col(self,c):        if c.isspace():            return 0        if c == &#x27;+&#x27; or c == &#x27;-&#x27;:            return 1        if c.isdigit():            return 2        return 3    # 只有其中两个状态的时候才需要改变，判断边界条件    def get(self, c):        self.state = self.table[self.state][self.get_col(c)]        if self.state == &quot;in_num&quot;:            self.ans = self.ans * 10 + int(c)            if self.sign == 1:                self.ans = min(self.ans, INT_MAX)            else:                self.ans = min(self.ans, -INT_MIN)        elif self.state == &quot;signed&quot;:            if c == &quot;+&quot;:                self.sign = 1            else:                self.sign = -1class Solution:    def myAtoi(self, s: str) -&gt; int:        dfa = Dfa()        for c in s:            dfa.get(c)        return dfa.sign * dfa.ans\n\n链表2. 两数相加*注意进位问题\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        node1, node2 = l1, l2        res = cur = ListNode()        carry = v = 0        while node1 or node2:            if node1 and node2:                v = node1.val + node2.val + carry                node1 = node1.next                node2 = node2.next            elif node1 == None:                v = node2.val + carry                node2 = node2.next            else: # node2 == None                v = node1.val + carry                node1 = node1.next                        carry, v = divmod(v, 10)            cur.next = ListNode(v)            cur = cur.next                if carry:            cur.next = ListNode(1)        return(res.next)\n\n21.合并两个有序链表\n基本思想和上题一样\n注意对链表空或非空的判断，注意移动cur指针# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        res = cur = ListNode()        node1, node2 = list1, list2        while node1 or node2:            if node1 and node2:                if node2.val &gt;= node1.val:                    cur.next = ListNode(node1.val)                    node1 = node1.next                else:                    cur.next = ListNode(node2.val)                    node2 = node2.next            elif node1 == None:                cur.next = node2                node2 = node2.next            else: # node2 == None                cur.next = node1                node1 = node1.next            cur = cur.next        return res.next\n\n二叉树和图设计"},{"title":"关于在winter break摆烂的随笔小记1","url":"/2021/12/20/%E5%85%B3%E4%BA%8E%E5%9C%A8winter-break%E6%91%86%E7%83%82%E7%9A%84%E9%9A%8F%E7%AC%94%E5%B0%8F%E8%AE%B01/","content":"“突然想起了学生公寓门口的拌饺，吃完一顿要打满六个小时的韭菜味饱嗝。以前想不到吃什么的时候总会买一份拌饺加一份水果捞，拎着回宿舍和朋友一起看剧。让人怀念的还有那个摊位卖的福鼎肉片，大晚上偷偷溜出去踩水之后总会买一份的宵夜，想起来总是很快乐的日子。不想看的曾经，但又想分享的曾经。”  \n\n\n\n\n\n本来想在微博上碎碎念的文字，后来突然想起自己刚搭建的秘密基地，也成为了我码字第一个博客的契机。当然了，这种废话文学只能被归类到“随笔”中，那干脆也来写写我winter break中的摆烂一天，好歹也是记录我存在过的证据了。以后我的孙子孙女可以直接摸过来看我的日记咯，还挺有趣的。  \n今天早上是和阿叶约的“芝加哥圣诞集市之行”，一直想去感受一下这边的圣诞氛围，苦于没有车，我和阿叶总是得等到有intercampus的时候，才敢出趟“远门”。去之前倒是很期待在集市里买到可爱的纪念杯，听说上面会印有每年的年份，就蛮有意义。还打算买个我最爱的pretzel和芝士法棍三明治，捧着热红酒慢慢悠悠的逛一圈。  \n然而人们对圣诞的热情还是远超我的想象。有点像市中心“义乌小市场”的圣诞集市，就连进去也要排队，简直是梦回迪士尼四小时玩俩机动游戏的噩梦了。  \n","categories":["随笔"]}]