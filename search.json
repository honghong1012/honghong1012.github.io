[{"title":"GreatFrontEnd Coding","url":"/2024/05/11/GreatFrontEnd-Coding/","content":"GetUnique ArrayContact FormNote\nhow to use form and submit its data with only html\na11y for label and input\n\nSolutionimport &#x27;./styles.css&#x27;;import submitForm from &#x27;./submitForm&#x27;;export default function App() &#123;  return (    &lt;form      // Ignore the onSubmit prop, it&#x27;s used by GFE to      // intercept the form submit event to check your solution.      onSubmit=&#123;submitForm&#125;      action=&quot;https://www.greatfrontend.com/api/questions/contact-form&quot;      method=&quot;POST&quot;      &gt;      &lt;div&gt;        &lt;label htmlFor=&quot;Name&quot;&gt;Name: &lt;/label&gt;        &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;/&gt;      &lt;/div&gt;      &lt;br/&gt;      &lt;div&gt;        &lt;label htmlFor=&quot;Email&quot;&gt;Email: &lt;/label&gt;        &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot;/&gt;      &lt;/div&gt;      &lt;br /&gt;      &lt;div&gt;        &lt;label htmlFor=&quot;Message&quot;&gt;Message: &lt;/label&gt;        &lt;textarea type=&quot;text&quot; name=&quot;message&quot; id=&quot;message&quot; /&gt;      &lt;/div&gt;      &lt;br/&gt;      &lt;button type=&quot;submit&quot;&gt;Send&lt;/button&gt;    &lt;/form&gt;  );&#125;\n\nHoly Grail Solution \n\nNote\nflex-based css\nflex-grow, flex-shrink\n#root\n\nArray.prototype.filterNote\nprototype\ncall(), apply(), bind()\nSolutionArray.prototype.myFilter = function (callbackFn, thisArg) &#123;  const len = this.length;  const result = [];  for (let i = 0; i &lt; len; i++)&#123;    const arrayValue = this[i]    if(Object.hasOwn(this,i) &amp;&amp; callbackFn.call(thisArg, arrayValue, i, this))&#123;      result.push(arrayValue)    &#125;  &#125;    return result;&#125;;\nArray.prototype.reduce\n\nEdge case\nEmpty array, with and without the initialValue argument.\nSingle-value array, with and without the initialValue argument.\nPassing the index and array to the reducer callback.\nSparse arrays, e.g. [1, 2, , 4]. The empty values should be ignored while traversing the array.\n\nSolutionArray.prototype.myReduce = function (callbackFn, initialValue) &#123;  const len = this.length;  const noInitialValue = initialValue === undefined;  if(noInitialValue &amp;&amp; len === 0)&#123;    throw new TypeError(&#x27;Reduce of empty array with no initial value&#x27;);  &#125;  let acc = noInitialValue ? this[0] : initialValue;  let startingIndex = noInitialValue ? 1 : 0;  for(let i = startingIndex; i &lt; len; i++)&#123;    // Sparse array    if(Object.hasOwn(this, i))&#123;      acc = callbackFn(acc, this[i], i, this)    &#125;  &#125;  return acc;&#125;;\n\nArray.prototype.squareSolutionArray.prototype.square = function () &#123;  return this.map((num) =&gt; num * num)&#125;;\n\n\nLodash_.Chunk\narray.slice(a, b) =&gt; [a, b)\nedge case, isArray? size input?\n\nSolution/** * @template T * @param &#123;Array&lt;T&gt;&#125; array The array to process. * @param &#123;number&#125; [size=1] The length of each chunk. * @returns &#123;Array&lt;Array&lt;T&gt;&gt;&#125; The new array of chunks. */export default function chunk(array, size = 1) &#123;  if(!Array.isArray(array) || size &lt; 1) return [];  const result = [];  const len = array.length;  for(let i = 0; i &lt; len; i = i + size) &#123;    result.push(array.slice(i, i + size))  &#125;  return result&#125;\n\n\nLodash_.CompactSolution/** * @param &#123;Array&#125; array: The array to compact. * @return &#123;Array&#125; Returns the new array of filtered values. */export default function compact(array) &#123;  const result = [];  for(let i = 0; i &lt; array.length; i++)&#123;    if(array[i])&#123;      result.push(array[i])    &#125;  &#125;  return result&#125;\n\nexport default function compact(array) &#123;  return array.filter(Boolean)&#125;\n\n\nLodash_.differenceSolution/** * @param &#123;Array&#125; array - Array from which different elements are to be removed. * @param &#123;Array&#125; values - Array of values that are to be removed from the original array. * @return &#123;Array&#125; Returns filtered array. */export default function difference(array, values) &#123;  const valueSet = new Set(values);  const result = [];  for (let i = 0; i &lt; array.length; i++)&#123;    if(!valueSet.has(array[i]) &amp;&amp; !(!(i in array) &amp;&amp; array[i] === undefined) )&#123;      result.push(array[i])    &#125;  &#125;  return result&#125;\n\nexport default function difference(array, values) &#123;  const valueSet = new Set(values);  return array.filter((arrayValue) =&gt; !valueSet.has(arrayValue) )&#125;\n\nLodash_.dropRightWhileSolution/** * @param &#123;Array&#125; array - The array to iterate over. * @param &#123;Function&#125; predicate - The function invoked per iteration. * @return &#123;Array&#125; Returns the slice of `array`. */export default function dropRightWhile(array, predicate) &#123;  let i = array.length - 1;  while(i &gt;=0 &amp;&amp; predicate(array[i], i, array))&#123;    i--;  &#125;  return array.slice(0, i+1)&#125;\n\nLodash_.dropWhileSolution/** * @param &#123;Array&#125; array - The array to iterate over. * @param &#123;Function&#125; predicate - The function invoked per iteration. * @return &#123;Array&#125; Returns the slice of `array`. */export default function dropWhile(array, predicate) &#123;  let i = 0;  while(i &lt; array.length &amp;&amp; predicate(array[i], i, array))&#123;    i++;  &#125;  return array.slice(i)&#125;\n\nLodash_.dropWhileEdge cases:\nEmpty, one, two-element arrays.\nNegative indices.\nend is smaller than start.Solution/** * @param &#123;Array&#125; array - The array to fill. * @param &#123;*&#125; value - The value to fill array with. * @param &#123;number&#125; [start=0] - The start position. * @param &#123;number&#125; [end=array.length] - The end position. * @return &#123;Array&#125; Returns the filled array. */export default function fill(array, value, start = 0, end = array.length) &#123;  const len = array.length;  if(start &lt; 0)&#123;    start = -start &gt; len ? 0 : len + start  &#125;  if(end &gt; len)&#123;    end = len + 1  &#125;  if(end &lt; 0)&#123;    end = len + end  &#125;  for (let i = start; i &lt; Math.min(end, len); i++)&#123;    array[i] = value  &#125;  return array&#125;\n\nLodash_.findIndexEdge cases:\nnegative and out of bound starting indexSolution/** * This function returns the index of the first element in the array that satisfies the provided testing function. * Otherwise, it returns -1, indicating that no element passed the test. * * @param &#123;Array&#125; array - The array to search. * @param &#123;Function&#125; predicate - The function invoked per iteration. * @param &#123;number&#125; [fromIndex=0] - The index to start searching from. * @returns The index of the found element, else -1. */export default function findIndex(array, predicate, fromIndex = 0) &#123;  let arrayLen = array.length;  if(fromIndex &lt; 0)&#123;    fromIndex = -fromIndex &gt; arrayLen ? 0 : arrayLen + fromIndex  &#125;  if (fromIndex &gt; arrayLen) return -1;  for (let i = fromIndex; i &lt; arrayLen; i++)&#123;    if(predicate(array[i], i, array)) return i  &#125;  return -1&#125;\n\nLodash_.findLastIndexEdge cases:\nnegative and out of bound starting indexSolution/** * This function returns the index of the last element in the array that satisfies the provided testing function. * Otherwise, it returns -1. * * @param &#123;Array&#125; array - The array to search. * @param &#123;Function&#125; predicate - The function invoked per iteration. * @param &#123;number&#125; [fromIndex=array.length-1] - The index to start searching from. * @returns The index of the found element, else -1. */export default function findLastIndex(  array,  predicate,  fromIndex = array.length - 1,) &#123;  let startIndex =    fromIndex &lt; 0      ? Math.max(array.length + fromIndex, 0)      : Math.min(fromIndex, array.length - 1);  let index = startIndex;  // Iterate from the right.  while (index &gt;= 0) &#123;    if (predicate(array[index], index, array)) &#123;      return index;    &#125;    index--;  &#125;  return -1;&#125;\n\nLodash_.fromPairsSolution/** * Creates an object from an array of key-value pairs. * * @param &#123;Array&#125; pairs - An array of key-value pairs. * @returns &#123;Object&#125; - The object composed from the key-value pairs. */export default function fromPairs(pairs) &#123;  const result = &#123;&#125;  for(const [key, value] of pairs)&#123;    result[key] = value;  &#125;  return result&#125;\n\nexport default function fromPairs(pairs) &#123;  return Object.fromEntries(pairs)&#125;\n\nLodash_.intersectionSolution/** * Computes the intersection of arrays, returning a new array containing unique values present in all given arrays. * * @param &#123;Array[]&#125; arrays - The arrays to perform the intersection on. * @returns &#123;Array&#125; - A new array containing the unique values present in all given arrays. */export default function intersection(...arrays) &#123;  if(arrays.length &lt;= 0) return []  const inspectSet = new Set(arrays[0]);  for(let i = 1; i &lt; arrays.length; i++)&#123;    inspectSet.forEach((value) =&gt; &#123;      if(!arrays[i].includes(value))&#123;        inspectSet.delete(value)      &#125;    &#125;)  &#125;  return Array.from(inspectSet)&#125;\n\nObject map/** * @param &#123;Object&#125; obj * @param &#123;Function&#125; fn * @returns Object */export default function objectMap(obj, fn) &#123;  const result = &#123;&#125;;  for(const key in obj)&#123;    if(Object.prototype.hasOwnProperty.call(obj, key))&#123;      result[key] = fn.call(obj, obj[key])    &#125;  &#125;  return result&#125;\n\nOnce/** * @template &#123;Function&#125; T * @param &#123;T&#125; func * @return &#123;T&#125; */export default function once(func) &#123;  let invokeBoolean = false;  let value;  return function (...args)&#123;    if(!invokeBoolean)&#123;      value = func.apply(this, args)      invokeBoolean = true    &#125;    return value  &#125;&#125;\n\nProject.reject/** * @param &#123;*&#125; reason * @returns Promise */export default function promiseReject(reason) &#123;  return new Promise((_, reject) =&gt; reject(reason))&#125;\n\nRange/** * @param &#123;Number&#125; start - The first number of the resultant array. * @param &#123;Number&#125; end - The value where the resultant array will stop at and not contain it. * @param &#123;Number&#125; step - The step / increment value of each number in the array. * @return &#123;Array&lt;Number&gt;&#125; Returns the array with the sequence of numbers in the specified range. */export default function range(start = 0, end, step = 1) &#123;  const result = [];  // swap end and start  if(end === undefined)&#123;    end = start;    start = 0;  &#125;  // adjust step for descending sequences  if(end &lt; start &amp;&amp; step === 1)&#123;    step = -1  &#125;  // determine the number of elements in result  const len = (end - start) / (step || 1);  for(let i = 0; i &lt; len; i++)&#123;    result.push(start + i * step)  &#125;  return result&#125;\n\nRange Right/** * @param &#123;Number&#125; start - The first number of the resultant array. * @param &#123;Number&#125; end - The value where the resultant array will stop at and not contain it. * @param &#123;Number&#125; step - The step / increment value of each number in the array. * @return &#123;Array&lt;Number&gt;&#125; Returns the array with the sequence of numbers in the specified range. */export default function rangeRight(start = 0, end, step = 1) &#123;  const result = [];  if(end === undefined)&#123;    end = start;    start = 0;  &#125;  if(end &lt; start &amp;&amp; step === 1)&#123;    step = -1  &#125;  const len = (end - start) / (step || 1);  for(let i = 0; i &lt; len; i++)&#123;    result.unshift(start + i * step)  &#125;  return result&#125;\n\nArray.prototype.atsolution/** * @param &#123;number&#125; index * @return &#123;any | undefined&#125; */Array.prototype.myAt = function (index) &#123;  const len = this.length;  if(index &lt; 0)&#123;    index = -index &gt; len ? len : len + index  &#125;  if(index &gt;= len) return undefined  return this[index]&#125;;\n\nselection sort/** * @param &#123;Array&lt;number&gt;&#125; arr The input integer array to be sorted. * @return &#123;Array&lt;number&gt;&#125; */export default function selectionSort(arr) &#123;  for(let i = 0; i &lt; arr.length; i++)&#123;    let minIndex = i;    for(let j = i + 1; j &lt; arr.length; j++)&#123;      if(arr[j] &lt; arr[minIndex])&#123;        minIndex = j      &#125;    &#125;    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]  &#125;    return arr&#125;\n\ninsertion sort/** * @param &#123;Array&lt;number&gt;&#125; arr The input integer array to be sorted. * @return &#123;Array&lt;number&gt;&#125; */export default function insertionSort(arr) &#123;  for(let i = 1; i &lt; arr.length; i ++)&#123;    let currentValue = arr[i];    let j = i - 1;    while(j &gt;= 0 &amp;&amp; currentValue &lt; arr[j])&#123;      arr[j+1] = arr[j]      j--    &#125;    arr[j+1] = currentValue;   &#125;  return arr&#125;\n\nbinary search/** * @param &#123;Array&lt;number&gt;&#125; arr The input integer array to be searched. * @param &#123;number&#125; target The target integer to search within the array. * @return &#123;number&#125; The index of target element in the array, or -1 if not found. */export default function binarySearch(arr, target) &#123;  let left = 0;  let right = arr.length - 1;  while(left &lt;= right)&#123;    const mid = Math.floor((left + right) / 2)    const midValue = arr[mid]    if(midValue === target) return mid;    if(midValue &lt; target)&#123;      left = mid + 1;    &#125;    if(midValue &gt; target)&#123;      right = mid - 1    &#125;  &#125;  return -1&#125;","categories":["刷题笔记"]},{"title":"HTML","url":"/2022/12/29/HTML/","content":"IntroductionHTML(Hyper Text Markup Language)\nMDN/W3 school/devdocs.io for documentation\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;!-- character setting, ensure the character used in website get displayed correctly --&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;...&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p&gt;Just example&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;"},{"title":"Javascript challenges","url":"/2024/04/21/Javascript-challenges/","content":"Preparing for Job transfer, this is for the Javascript basics\n","categories":["刷题笔记"]},{"title":"css","url":"/2023/04/17/css/","content":"Box modelbasic concept in web design -&gt; how the elements are structured and interactevery html element -&gt; rectangular box -&gt; contains content,padding,border,margincontent -&gt; text/mediapadding -&gt; space between border and contentborder -&gt; line surround padding and contentmargin -&gt; space between boarder and neighbor element\nBox-sizingproperty specify how total width/height of element is calculatedtaking into accounts -&gt; content padding border marginthere are 2 values for this property\n\ncontent-box -&gt; default value + specify width/height of the element only includes content\nborder-box -&gt; includes content padding border but without margin\n\nHTML5 new feature\nlocal storage and session storage -&gt; allow web pages to store data on the user’s device.\nimprovements in forms, some attributes in input fields like placeholders/emails\nsemantic tags -&gt; provide more descriptive information to the search engines and web crawlers.\naudio and video support tags -&gt; without plugins\nweb workers -&gt; allow for the execution of JavaScript code in the background, freeing up the main thread for other tasks.\n\nlocal storage / session storage / cookiesall mechanism to store data on client side\ncookies -&gt; text files\nstore information that needs to be retained between browsing sessions -&gt; user login info\ncan be used to identify computer/tracking\n4kb, send withing http requestlocal storage and session storage\n5mb, design for storing data on the browser\nnot sended with http request\nlocal storage dont have expiration -&gt; user preference\nsession storage only availabe for the duration of the browser session -&gt; form data/page-specific setting\n\nStatic / relative / absolute / fixed / sticky position\nstatic: default unpositioned\nrelative: original position as a reference -&gt; other ele won’t take its place\nabsolute: use the closet positioned element as a reference, otherwise, use body\nfixed: use viewport as reference\nsticky: combination of relative and fixed -&gt; relative on default -&gt; fixed when scroll out of the web page\n\nz-indexproperty to decide the stacking order -&gt; only works for positioned elements\nvisibility: hidden / display: nonevisibility: hidden;hides an element from view, but the element still takes up space on the web page. The element is not visible, but its layout and size are still preserved, so other elements on the page are positioned as if it were still visible.\ndisplay: none; completely removes an element from the web page, including its layout and size.\npx / em / rem / vh vw / %Px, em, rem, vh, vw, and % are all units of measurement in CSS\n\nPx (pixels) -&gt; absolute unit of measurement -&gt; a single dot on a screen. It’s commonly used for precise measurements and when creating fixed-width layouts.\nEm -&gt; relative unit -&gt; based on the font size of the parent element.\nRem (root em) relative unit -&gt; based on the font size of the root element (typically the  element).\nVh (viewport height) and vw (viewport width) -&gt; relative units of measurement -&gt; based on the height and width of the browser viewport, respectively. \n% (percentages) -&gt; relative unit -&gt; based on the size of the parent element.\n\nFlex / grid\nAxis: Flexbox is designed for one-dimensional layouts, either in a row or a column, while CSS Grid is designed for two-dimensional layouts with rows and columns.\nItem placement: Flexbox provides a way to align and distribute items along the main axis and cross axis, while CSS Grid allows for more fine-grained placement of items in a grid, with control over row and column placement, spanning, and alignment.\nBrowser support: CSS Grid is supported by most modern browsers, including all major desktop and mobile browsers. Flexbox has wider support, but some older browsers may not support all of its features.\n\nWhen to choose Flexbox:For simpler layouts that only require one-dimensional alignment of items, such as navigation menus, card layouts, or simple lists.\nWhen to choose grid:For more complex layouts that require precise placement of items in rows and columns, such as magazine-style layouts, image galleries, or dashboard designs.\nBlock / Inline / inline-blockblock\n\nrespect all of those\nforce a line break after the block element\nbreaks the flow\n\ninline:\n\nrespect left &amp; right margins and padding, but not top &amp; bottom\ncannot have a width and height set\nmargin and padding will push other elements horizontally not vertically\nallow other elements to sit to their left and right.\nelements do not break the flow\n\ninline-block:\n\nallow other elements to sit to their left and right\nrespect top &amp; bottom margins and padding\nrespect height and width\n\npseudo-elements / pseudo-classcss pre-processorA CSS pre-processor is a tool that extends the functionality of CSS by adding programming-like constructs such as variables, mixins, functions, and conditionals\nSASS (SCSS)LESSStylusPostCSS\nresetting / normalizingResetting - Resetting is meant to strip all default browser styling on elements. For e.g. margins, paddings, font-sizes of all elements are reset to be the same. You will have to redeclare styling for common typographic elements.\nNormalizing - Normalizing preserves useful default styles rather than “unstyling” everything. It also corrects bugs for common browser dependencies.\nSemantic tags / importance\nSearch Engine Optimization, accessibility, repurposing, light code.\nMany visually impaired person rely on browser speech and semantic tag helps to interpret page content clearly.Search engine needs to understand page content to rank and semantic tag helps.\nsemantic code aids accessibility. Specially, many people whose eyes are not good rely on speech browsers to read pages to them. These programs cannot interpret pages very well unless they are clearly explained.\nHelp Search engines to better understand pages. Search engine need to understand what your content is about when rank you properly on search engines. Semantic code tends to improve your placement on search engines, as it is easier for the “search engine spiders” to understand.\nIt’s easier to read and edit, which saves time and money during maintenance.\n\nspecificityIn CSS, specificity is a way of determining which style rules should be applied to an element when multiple rules could apply to the same element. \nIt is used to resolve conflicts between different style rules that target the same element, by giving priority to the most specific rule.\nSpecificity is calculated using a system of values assigned to different parts of a CSS selector. The selector with the highest specificity will override any conflicting rules with lower specificity.\nThe specificity values are calculated as follows:\nID selectors: 100Class selectors, attribute selectors, and pseudo-classes: 10Type selectors and pseudo-elements: 1Universal selector (*), combinators (+, &gt;, ~), and the negation pseudo-class (:not()) have no specificity value.To calculate the specificity of a selector, you add up the specificity values of each of its parts. For example, the selector “body .wrapper div#content p” would have a specificity of 111 (1 for the type selector p, 10 for the ID selector #content, 10 for the class selector .wrapper, and 100 for the type selector div inside the ID selector).\nWhen multiple rules have the same specificity, the last one declared in the stylesheet takes precedence.\nWhat happens when DOCTYPE is not given?The web page is rendered in quirks mode. The web browsers engines use quirks mode to support older browsers which does not follow the W3C spec.\nIn quirks mode CSS class and id names are case insensitive. In standards mode they are case sensitive.\nWhat kind of things must you be wary of when design or developing for multilingual sites?Use lang attribute in your HTML.\nmeta tagSEO information\nEmbed cssInlineStyle tagLink@import in css file\nWhat does a DOCTYPE do?DOCTYPE is an abbreviation for DOCument TYPE.A DOCTYPE is always associated to a DTD for Document Type Definition.\nA DTD defines how documents of a certain type should be structured (i.e. a button can contain a span but not a div), whereas a DOCTYPE declares what DTD a document supposedly respects (i.e. this document respects the HTML DTD).\nFor webpages, the DOCTYPE declaration is required. It is used to tell user agents what version of the HTML specifications your document respects.Once a user agent has recognized a correct DOCTYPE, it will trigger the no-quirks mode matching this DOCTYPE for reading the document.If a user agent doesn’t recognize a correct DOCTYPE, it will trigger the quirks mode.\nThe DOCTYPE declaration for the HTML5 standards is .\nit controls whether the browsers uses “standards” or “quirks” mode to render the document.\naltThe alt attribute provides alternative information for an image if a user cannot view it. The alt attribute should be used to describe any images except those which only serve a decorative purposes, in which case it should be left empty.\nb and strongThe b tag is a presentational tag that simply makes text bold. \nThe strong tag, on the other hand, is a semantic tag that is used to indicate that the enclosed text is of particular importance or significance.\nb should be used for presentational purposes, such as making text bold for aesthetic reasons, while should be used to indicate the importance or significance of text for semantic and accessibility purposes.\nResponsive designResponsive design is an approach to web design and development that aims to create websites and applications that provide an optimal viewing and interaction experience across a wide range of devices and screen sizes, from desktop computers to mobile phones.\nuse @media to query the user’s device width or height to override the styles\nMobile first designMobile first design is an approach to web design that prioritizes the design and development of the mobile version of a website or application before creating the desktop version. This means that designers and developers focus on designing for smaller screens first, and then gradually add more complex features and layout elements as the screen size increases.\nThe mobile first approach is driven by the increasing use of mobile devices to access the internet and the need for websites and applications to be optimized for smaller screens.\nflexbox"},{"title":"Hello World","url":"/2021/12/18/hello-world/","content":"Welcome to my blog! This is my very first post. Actually I’ve been setting up my blog for a long time(even though I often found excuses not to implement anything on the website)\n"},{"title":"js","url":"/2023/04/18/js/","content":"Data types\n7 primitive types: Number Boolean Null Undefined String + (BigInt Symbol in ES6)\nArray, Function, Object\n\nValue type / Reference typeValue types, also known as primitive types, include strings, numbers, booleans, null, and undefined. \n\nvalue type is assigned to a variable or passed as an argument to a function -&gt; a copy of the value is created and stored in a new location in memory\nAny changes made to the variable or parameter do not affect the original value.\n\nReference types, on the other hand, include objects, arrays, and functions. \n\nWhen a reference type is assigned to a variable or passed as an argument to a function -&gt; a reference to the original object is created and stored in memory\nThis means that changes made to the variable or parameter affect the original object, since they are both pointing to the same location in memory.\n\nTo compare value types, you can simply use the === operator, which checks for strict equality.To compare reference types, however, you need to be careful. The === operator checks for equality of reference, not equality of content. loop + JSON.stringify() to compare the content\nShallow copy / deep copytechniques used to create copies of objects or arrays\nShallow copy\nCreate a new obj/array and copy the properties of ele of the original one to the new one\nHowever if original one contains nested, the references to those would be copied. -&gt; changes to nested would affect\nUseful when only need to modify the top-level properties or ele of an obj/array or create light-weight copy of large data structure\nMethod: Object.assign(), spread operator(…)\n\nDeep copy\nCreate a new obj/array and recursively copy all the properties/eles, including nested ones. -&gt; changes would not affect original\nSlower and more memory-intensive\nMethod: Lodash library, JSON.parse(JSON.stringify())\n\nvar / let / constvariable can be declared using these keywords\nvar\noldest way to declare\nfunction scope -&gt; variable is accessible within the function it is defined in, as well as the any nested function -&gt; outside the function becomes a global variable\nre-declared and updated within the same scope\nvariable hoisting -&gt; declarations are moved to top\n\nlet / const\nintroduced in ES6\nblock scope -&gt; block is a section of code surrounded by curly braces(if/else, loop)\nlet can be updated but not re-declared within same scope\nconst cannot be reassigned or re-declared\n\nclosureA closure is an inner function that has access to the outer function’s variables.It has three scope chains: access to its own scope -&gt; outer function’s variables -&gt; global variables\nEvent loop\nkey concept in the JS runtime environment -&gt; enables asynchronous programming. \nIn JS, code is executed in a single-threaded environment, which means that only one task can be processed at a time. -&gt;  However, JavaScript also supports non-blocking I/O operations, which allow for asynchronous code execution.\nTo manage asynchronous operations, JS uses the event loop. \nThe event loop is a continuous process that monitors the call stack and the task queue. Whenever the call stack is empty, the event loop looks at the task queue and adds any pending tasks to the call stack. This way, asynchronous tasks can be executed when they are ready, without blocking the main thread.\nmicro(promise callback) &gt; macro(setTimeout/setInterval)\n\nBasic workflow\nWhen a task is added to the task queue, it is marked as “pending”.\nWhen the call stack is empty, the event loop checks the task queue for any pending tasks.\nIf there is a pending task, it is added to the call stack and executed.\nOnce the task is complete, the call stack is empty again and the event loop checks for any new pending tasks.\n\nPromise\ncontainer -&gt; have the result of the future things\nprovides cleaner and intuitive way to deal with asynchronous tasks, avoid callback hell\ntwo states: pending and settled, settled includes fulfilled + rejected\nuses method “then” and “catch” to deal with all kinds of asynchronous operation\n\nAsync / whyEvent loop. We want non-blocking and avoid DOM render conflicting\nasync / await difference with Promisesame thing -&gt; syntax sugar that allows to write async code like sync code.\n“this” in js“this” means the environment object where the function is running.With “Function” keyword:\n\n“this” in constructor function. -&gt; the function called with “new” -&gt; this refers the instance\n“this” in an object method function -&gt; refers to who call the function (the thing before the “.”)\n“this” in a plain function -&gt; window\n“this” in event handler -&gt; the element fires the event\n\nArrow function“this” points to closest “this” when create the function, it is lexical scopeArrow function cannot be the constructor function\nbind / apply / callThe purpose is to change the “this” referring.\n\nbind takes one or more arguments, the first would be the new “this” value -&gt; const newFunc = func.bind(antherObj);\n“apply” method calls a function with a specified “this” value and arguments provided as an array. The first argument to the “apply” method is the new “this” value, and the second argument is an array of arguments to be passed to the function. -&gt; apply(anotherObj, [arg1, arg2])\n“call” method is similar to the “apply” method, but the arguments are passed individually rather than as an array. The first argument to the “call” method is the new “this” value, and the remaining arguments are individual arguments to be passed to the function.\n\n -&gt; call(anotherObj, arg1, arg2)\nEvent bubbling / Event capturingbubbling\nmechanism in JS that allows an event to propagate through the DOM hierarchy -&gt; from the innermost element to the outermost element. \nWhen an event occurs on an element, such as a click or a keypress, the event is first handled by the element itself. Then, the event “bubbles up” to its parent element, and so on, until it reaches the top-level document object.\nAllows us to capture an event on a parent element rather than handling it on every child element individually. This can be useful when working with dynamic HTML content or when we want to minimize the number of event listeners in our code.\n\ncapturingEvent capturing is another mechanism in JavaScript that allows an event to be captured and handled by a parent element before it reaches the target element. In contrast to event bubbling, event capturing starts from the outermost parent element and propagates towards the target element.\ne.target / e.currentTargete.target: The thing under the mouse (the thing that triggers the event).e.currentTarget is the  element with the added event listener.\nEvent delegationEvent Delegation is the method. this method will let you create one event listener to trigger all child elements. Each child element will be targeted by a unique ID.\nJS prototype\nWhy do we need the “prototype”? To re-use method in the object\nEach function automatically has a “prototype” property. The value of “prototype” is an object.\n Each object(instance) has a “__proto__” property. The “__proto__” refers the “prototype” of its creator(the function). \nYou can use a function(constructor) with “new” keyword to create an object(instance). Then the created object’s “__proto__” refers the “prototype” of the function(constructor)\nthe object will have a “constructor” property automatically, which refers to the constructor(the function)\nArrow function cannot be a constructor\nWhen accessing a property of an object, JS will look at itself first. If no, it will look at the “proto__”, If still no, it will look at “__proto.__proto__” until the “__proto__” is null. (the prototype chain)\n\nWhy put the tag in the last of HTML file?Putting the script tag in the last can reduce the delay time, users won’t wait a long time to open the webpage. Because the render direction is from top to bottom.\nIIFE (Immediately Invoked Function Expression)IIFE stands for Immediately Invoked Function Expression. It is a JavaScript design pattern that involves defining and immediately invoking a function, usually for the purpose of creating a private scope for variables and functions.\nES6 featuressetTimeout / setIntervalarray dot reversemap / reducepromise / callback"},{"title":"react","url":"/2023/04/18/react/","content":"JSX\nXML-like syntax extension to ECMAScript (the acronym stands for JavaScript XML). \nBasically it provides syntactic sugar for the React.createElement() function, giving us expressiveness of JavaScript along with HTML like template syntax.\n\nclass component / function componentIn React, class components and function components are two ways to define a component. The main difference between them is the syntax and the way they handle state and lifecycle methods.\n\nClass components are defined using the ES6 class syntax and extend the React.Component class. They have a constructor method where you can initialize the component’s state and also have access to lifecycle methods such as componentDidMount, componentDidUpdate, etc. Class components also have access to a wider range of features such as the ability to define instance methods and static methods.\n\nFunction components, on the other hand, are defined using a JavaScript function and return a JSX element. They do not have access to state or lifecycle methods, but they can receive props as function arguments and can use hooks such as useState and useEffect to handle state and side effects respectively. \n\n\nwhen to useIf the component needs state or lifecycle methods then use class component otherwise use function component. However, from React 16.8 with the addition of Hooks, you could use state , lifecycle methods and other features that were only available in class component right in your function component.\nstateInternal property,that is used to contain data or information about the component. State change will trigger re-render of the component.\npropsshort for propertiesis being used for passing data from one component to another. But data with props are being passed in one way from parent to child.\nwhy should we not update the state directlyIf you try to update state directly then it won’t re-render the component.\npurpose of callback function as an argument of setState() and useStateThe callback function is invoked when setState finished and the component gets rendered. Since setState() is asynchronous the callback function is used for any post action.\nWhat is the difference between HTML and React event handling?In HTML, the event name should be in lowercase:\n&lt;button onclick=&#x27;activateLasers()&#x27;&gt;\n\nin React\n&lt;button onClick=&#123;activateLasers&#125;&gt;\n\nIn HTML, you can return false to prevent default behavior:\n&lt;a href=&#x27;#&#x27; onclick=&#x27;console.log(&quot;The link was clicked.&quot;); return false;&#x27; /&gt;e.preventDefault()\nin React you must call preventDefault() explicitly:\nfunction handleClick(event) &#123;  event.preventDefault()  console.log(&#x27;The link was clicked.&#x27;)&#125;\nsynthetic events\nSyntheticEvent is a cross-browser wrapper around the browser’s native event. \nIt’s API is same as the browser’s native event, including stopPropagation() and preventDefault(), except the events work identically across all browsers.\n\nkey props and benefit\nA key is a special string attribute you should include when creating arrays of elements. \nKey prop helps React identify which items have changed, are added, or are removed.\n\nthe use of refsThe ref is used to return a reference to the element. They should be avoided in most cases, however, they can be useful when you need a direct access to the DOM element or an instance of a component.\nVirtual DOMThe Virtual DOM (VDOM) is an in-memory representation of Real DOM. \n\nIn a traditional web application, whenever the state of a component changes, the entire HTML DOM tree is updated to reflect the new state, which can be slow and inefficient.(DOM manipulation is expensive)\nWith the Virtual DOM, instead of directly manipulating the actual DOM, React creates a lightweight virtual representation of the DOM, which is a copy of the actual DOM.\nWhen the state of a component changes, React compares the current virtual DOM with the previous one to determine what has changed. It then updates the actual DOM only with the parts that have changed, rather than updating the entire DOM tree.\nIt’s a step that happens between the render function being called and the displaying of elements on the screen. This entire process is called reconciliation.\n\nReact FiberFiber is the new reconciliation engine or reimplementation of the core algorithm in React v16. \n\nThe goal is to increase its suitability for areas like animation, layout, gestures, and new concurrency primitives. -&gt; increase performance\n\ncontrolled component / uncontrolled component\nControlled components are React components where the value of the input field is controlled by React state. \nUncontrolled components are form inputs where the value is handled by the DOM itself, rather than by React state. It need ref to access.\n\nControlled component, controlled by state or props. Uncontrolled component need ref to access.\n&lt;input value=&#123;valueState&#125;, onChange=&#123;handleChange&#125;/&gt; -&gt; controlled element&lt;input /&gt; -&gt; uncontrolled element\n\nReact lifecycleIn React, the term “lifecycle” refers to the series of methods that a component goes through during its existence. These methods can be categorized into three main phases: mounting, updating, and unmounting.\n\n mounting phase occurs when a component is first created and added to the DOM. During this phase, the following methods are called in order:constructor()render()componentDidMount()\n\nupdating phase occurs when a component’s props or state change, causing it to re-render. During this phase, the following methods are called in order:shouldComponentUpdate()render()componentDidUpdate()\n\nunmounting phase occurs when a component is removed from the DOM. During this phase, the following method is called:componentWillUnmount()\n\n\ndifferent phases of the component lifecycleRender: pure and has no side effects. May be paused, aborted or restarted by ReactPre-commit: can read the DOMCommit: Can work with the DOM, run side effects, schedule updates.\nHOC / FACA higher-order component (HOC) is a function that takes a base component and returns a new component. -&gt;  inject props -&gt; re-use logicFunction as Children: render props.children as a function\nBoth are for re-use\nContextContext provides a way to pass data through the component tree without having to pass props down manually at every level.const {Provider, Consumer} = React.createContext(defaultValue)useContext\nChildren propIn React, every component can receive props as input, which are essentially parameters that can be used to customize the behavior and appearance of the component. The “children” prop is a special prop that allows a component to pass its child components (i.e., the components that are nested inside it) as props.\nReconciliationWhen a component’s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM. This process is called reconciliation.\nPerformanceReact.lazy -&gt; load component as needed. To improve the loading speed -&gt; lazy loadingWebpack -&gt; minify / uglify plugin (new trends -&gt; vite.js)(https://reactjs.org/docs/code-splitting.html)PureComponent &amp; shouldComponentUpdate -&gt; improve rendering performance -&gt; to avoid unnecessary re-render\nPure componentsReact.PureComponent is exactly the same as React.Component except that it handles the shouldComponentUpdate() method for you.When props or state changes, PureComponent will do a shallow comparison on both props and state. Component on the other hand won’t compare current props and state to next out of the box.Thus, the component will re-render by default whenever shouldComponentUpdate is called.\nWhy React uses className over class attribute?class is a keyword in JavaScript\nFragmentsIn React, a fragment is a component that allows you to group a list of child elements or components without adding an extra node to the DOM (Document Object Model).\n&lt;React.Fragment&gt; &lt;/React.Fragment&gt; &lt;&gt;&lt;/&gt;\n\nPortalPortal is a recommended way to render children into a DOM node that exists outside the DOMhttps://reactjs.org/docs/portals.html usually used to implement modal, dialog, popover\nstateless components vs stateful componentsStateless components, also known as functional components, are defined as simple functions that take props as input and return a React element. They do not have any state of their own and are mainly used to represent UI elements or to encapsulate a small piece of functionality.\nValidation on propsIn React, you can apply validation on props using the built-in PropTypes library, which provides a set of validators for different data types.\nError boundariesAllow app handle error from UI gracefullyOnly handle UI error.https://reactjs.org/docs/error-boundaries.html\nSSR sever side renderingServer renders the react application page and sends to client. Good for SEO. Framework Next.jsvs CSR -&gt; client side rendering\nCRAThe create-react-app CLI tool allows you to quickly create &amp; run React applications with no configuration step.Customization without eject -&gt; react-scripts-rewired library\nFlux It is not a framework or a library but a new kind of architecture that complements React and the concept of Unidirectional Data Flow\nReduxRedux is a state container for JavaScript applications, most commonly used with React. \n\nIt provides a central store to manage the state of an application and a set of rules to ensure that the state can only be modified in a predictable way.\nThe core idea is that the entire state of an application is kept in a single store, represented as a plain JavaScript object. The state can only be modified by dispatching actions, which are plain JavaScript objects that describe what happened in the application.\nWhen an action is dispatched, it is sent to a reducer, which is a pure function that takes the current state and the action and returns a new state. The reducer is responsible for updating the state based on the action, and returning the new state.\nRedux makes it easier to reason about the behavior of an application and easier to debug issues. Additionally, because the state is stored in a central store, it can be easily shared across different parts of an application.\n\ncore principleSingle source of truth: The state of your whole application is stored in an object tree within a single store. The single state tree makes it easier to keep track of changes over time and debug or inspect the application.\nState is read-only: The only way to change the state is to emit an action, an object describing what happened. This ensures that neither the views nor the network callbacks will ever write directly to the state.\nChanges are made with pure functions: To specify how the state tree is transformed by actions, you write reducers. Reducers are just pure functions that take the previous state and an action as parameters, and return the next state.\nExplain Data flow of ReduxView -&gt; dispatch action -&gt; trigger reducer -&gt; update store data -&gt; re-render in view\nReact context / React Redux / React state?You can use Context in your application directly and is going to be great for passing down data to deeply nested components which what it was designed for.\nWhereas Redux is much more powerful and provides a large number of features that the Context API doesn’t provide. Also, React Redux uses context internally but it doesn’t expose this fact in the public API.\nState: Some simple state, like input text value, show/hide dropdown.Context: inside a module that needs to pass between componentsRedux: data that needs to be shared across modules.\nRedux is a state management library that provides a centralized store for your application’s state. Redux can be a good choice for large, complex applications that have a lot of shared state, as it provides a predictable way to manage that state and make updates to it.\nOn the other hand, useContext is a React Hook that provides a way to consume data from a context, which is a way to pass data down the component tree without the need to pass props manually at every level. Context is typically used for small amounts of data that need to be shared across many components, such as a theme or a user’s authentication status. \nRedux middleware\nMiddleware provides a way to interact with actions that have been dispatched to the store before they reach the store’s reducer. \nExamples of different uses for middleware include logging actions, reporting errors, making asynchronous requests, and dispatching new actions.\n\nAJAX request in Redux?use redux-thunk / redux-saga middleware which allows you to define async actions.\npresentational component / container in React Redux?Component is a class or function component that describes the presentational part of your application.\nContainer is an informal term for a component that is connected to a Redux store. Containers subscribe to Redux state updates and dispatch actions, and they usually don’t render DOM elements; they delegate rendering to presentational child components.\nHooksNew api from 16.8allows to have state and simulate lifecycles in functional component.Less and clean Code.Custom reuse-logic\ncommon hooks\nuseState: This hook allows you to add state to a function component. It returns a state variable and a function to update that state.\n\nuseEffect: This hook allows you to perform side effects, such as fetching data, setting up event listeners, or updating the document title. It takes a function as an argument and runs that function after every render.\n\nuseContext: This hook allows you to consume a context created with React.createContext() in a function component. It returns the current context value.\n\nuseReducer: This hook allows you to manage complex state with a reducer function, similar to how Redux works. It returns a state variable and a dispatch function to update that state.\n\nuseCallback: This hook allows you to memoize a function so that it only changes when its dependencies change. This can help optimize performance in certain cases.\n\nuseMemo: This hook allows you to memoize a value so that it only changes when its dependencies change. This can help optimize performance in certain cases.\n\nuseRef: This hook allows you to create a mutable ref object, which can be used to store a value between renders, or to get a reference to a DOM element or a child component.\n\n\nrules needed to follow for hooks?\nCall Hooks only at the top level of your react functions. i.e, You shouldn’t call Hooks inside loops, conditions, or nested functions. This will ensure that Hooks are called in the same order each time a component renders and it preserves the state of Hooks between multiple useState and useEffect calls.\nCall Hooks from React Functions only. i.e, You shouldn’t call Hooks from regular JavaScript functions.\n\nTestTDD vs BDDTDD(Test-Driven Development) is a software development technique that involves writing automated test cases prior to writing functional pieces of the code.    \nBDD(Behavior Driven Development) is a software development technique that defines the user behavior prior to writing test automation scripts or the functional pieces of code.\nFlaky test:A ﬂaky test is an analysis of web application code that fails to produce the same result each time the same analysis is run\nE2E test:Cypress vs Selenium test\nTesting pyramid\n"},{"title":"react-coding","url":"/2023/04/19/react-coding/","content":"Todo listimport &quot;./styles.css&quot;;import &#123; useState &#125; from &quot;react&quot;;export default function App() &#123;  const [newToDo, setNewToDo] = useState(&quot;&quot;);  const [todos, setTodos] = useState([]);  const [editingIndex, setEditingIndex] = useState(null);  const [editingText, setEditingText] = useState(&quot;&quot;);  const handleAddTodo = () =&gt; &#123;    setTodos([...todos, newToDo]);    setNewToDo(&quot;&quot;);  &#125;;  const handleDeleteTodo = (idx) =&gt; &#123;    setTodos(      todos.filter((td, index) =&gt; &#123;        return index !== idx;      &#125;)    );    setEditingIndex(null);  &#125;;  const handleEditTodo = (idx) =&gt; &#123;    setEditingIndex(idx);    setEditingText(todos[idx]);  &#125;;  const handleCancel = () =&gt; &#123;    setEditingIndex(null);    setEditingText(&quot;&quot;);  &#125;;  const handleSubmit = (idx) =&gt; &#123;    const updatedTodos = [...todos];    updatedTodos[idx] = editingText;    setTodos(updatedTodos);    setEditingIndex(null);    setEditingText(&quot;&quot;);  &#125;;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;div&gt;        &lt;input          type=&quot;text&quot;          onChange=&#123;(e) =&gt; setNewToDo(e.target.value)&#125;          value=&#123;newToDo&#125;        /&gt;        &lt;button onClick=&#123;handleAddTodo&#125;&gt;Add&lt;/button&gt;      &lt;/div&gt;      &lt;ul&gt;        &#123;todos.map((todo, idx) =&gt; &#123;          return (            &lt;li key=&#123;idx&#125;&gt;              &#123;editingIndex === idx ? (                &lt;&gt;                  &lt;input                    type=&quot;text&quot;                    value=&#123;editingText&#125;                    onChange=&#123;(e) =&gt; setEditingText(e.target.value)&#125;                  /&gt;                  &lt;button onClick=&#123;() =&gt; handleSubmit(idx)&#125;&gt;Submit&lt;/button&gt;                  &lt;button onClick=&#123;() =&gt; handleCancel()&#125;&gt;Cancel&lt;/button&gt;                &lt;/&gt;              ) : (                &lt;&gt;                  &#123;todo&#125;                  &lt;button                    onClick=&#123;() =&gt; &#123;                      handleEditTodo(idx);                    &#125;&#125;                  &gt;                    Edit                  &lt;/button&gt;                  &lt;button                    onClick=&#123;() =&gt; &#123;                      handleDeleteTodo(idx);                    &#125;&#125;                  &gt;                    Delete                  &lt;/button&gt;                &lt;/&gt;              )&#125;            &lt;/li&gt;          );        &#125;)&#125;      &lt;/ul&gt;    &lt;/div&gt;  );&#125;\n\nPhoto albumimport React, &#123; useState, useEffect &#125; from &quot;react&quot;;import &quot;./styles.css&quot;;export default function App() &#123;  const [photoData, setPhotoData] = useState([]);  const [inputValue, setInputValue] = useState(&quot;&quot;);  const [loading, setLoading] = useState(true);  const handleInput = (e) =&gt; &#123;    setInputValue(e.target.value);  &#125;;  useEffect(() =&gt; &#123;    fetch(&quot;https://jsonplaceholder.typicode.com/photos&quot;)      .then((res) =&gt; res.json())      .then((data) =&gt; &#123;        const newPhotoData = data.slice(0, 20);        setPhotoData(newPhotoData);        setLoading(false);      &#125;);  &#125;, []);  const filteredData = photoData.filter((photo) =&gt;    photo.title.includes(inputValue)  );  return (    &lt;div&gt;      &lt;div className=&quot;input-container&quot;&gt;        &lt;input          type=&quot;text&quot;          placeholder=&quot;type...&quot;          value=&#123;inputValue&#125;          onChange=&#123;handleInput&#125;        &gt;&lt;/input&gt;      &lt;/div&gt;      &#123;loading ? (        &lt;p&gt;Loading...&lt;/p&gt;      ) : (        &lt;div className=&quot;grid-container&quot;&gt;          &#123;filteredData.map((photo, index) =&gt; (            &lt;div key=&#123;index&#125; className=&quot;photo-card&quot;&gt;              &lt;img src=&#123;photo.url&#125; alt=&quot;apiPhoto&quot; width=&quot;100%&quot; /&gt;              &lt;p&gt;&#123;photo.title&#125;&lt;/p&gt;            &lt;/div&gt;          ))&#125;        &lt;/div&gt;      )&#125;    &lt;/div&gt;  );&#125;\n.App &#123;  font-family: sans-serif;  text-align: center;&#125;p &#123;  text-align: center;&#125;.input-container &#123;  display: flex;  justify-content: center;  margin: 10px;&#125;.grid-container &#123;  display: grid;  grid-template-columns: repeat(5, 1fr);  gap: 50px;  /* margin: 50px; */&#125;\n\nRunning clockimport &#123; useState, useEffect &#125; from &quot;react&quot;;import &quot;./styles.css&quot;;const App1 = () =&gt; &#123;  const [mins, setMins] = useState(0);  const [sec, setSec] = useState(0);  const [time, setTime] = useState(&#123;    minutes: parseInt(mins),    seconds: parseInt(sec)  &#125;);  const [start, setStart] = useState(false);  const [pause, setPause] = useState(false);  const [over, setOver] = useState(false);  useEffect(() =&gt; &#123;    if ((sec === 0 &amp;&amp; mins === 0) || !start) return;    let timer = setInterval(() =&gt; tick(), 1000);    return () =&gt; clearInterval(timer);  &#125;);  const tick = () =&gt; &#123;    if (pause || over) &#123;      return;    &#125;    if (time.minutes === 0 &amp;&amp; time.seconds === 0) &#123;      setOver(true);    &#125; else if (time.seconds === 0) &#123;      setTime(&#123;        minutes: time.minutes - 1,        seconds: 59      &#125;);    &#125; else &#123;      setTime(&#123;        minutes: time.minutes,        seconds: time.seconds - 1      &#125;);    &#125;  &#125;;  const reset = () =&gt; &#123;    setTime(&#123;      minutes: parseInt(0),      seconds: parseInt(0)    &#125;);    setPause(false);    setOver(false);    setStart(false);  &#125;;  const handleStart = () =&gt; &#123;    setTime(&#123;      minutes: sec &gt; 60 ? parseInt(mins) + 1 : parseInt(mins),      seconds: sec &gt; 60 ? parseInt(sec - 60) : parseInt(sec)    &#125;);    setStart(!start);  &#125;;  const handleMin = (e) =&gt; &#123;    setMins(e.target.value);  &#125;;  const handleSec = (e) =&gt; &#123;    setSec(e.target.value);  &#125;;  return (    &lt;div&gt;      &lt;label&gt;        Minutes        &lt;input type=&quot;number&quot; value=&#123;mins&#125; onChange=&#123;handleMin&#125; /&gt;      &lt;/label&gt;      &lt;label&gt;        Seconds        &lt;input type=&quot;number&quot; value=&#123;sec&#125; onChange=&#123;handleSec&#125; /&gt;      &lt;/label&gt;      &lt;button onClick=&#123;handleStart&#125;&gt;Start&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; setPause(!pause)&#125;&gt;Pause / resume&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; reset()&#125;&gt;Reset&lt;/button&gt;      &lt;h1&gt;&#123;`$&#123;time.minutes        .toString()        .padStart(2, &quot;0&quot;)&#125; : $&#123;time.seconds.toString().padStart(2, &quot;0&quot;)&#125;`&#125;&lt;/h1&gt;    &lt;/div&gt;  );&#125;;export default App1;\n\nTime trackerimport &quot;./styles.css&quot;;import &#123; useState, useEffect &#125; from &quot;react&quot;;export default function App() &#123;  const [task, setTask] = useState(&quot;&quot;);  const [time, setTime] = useState(0);  const [start, setStart] = useState(false);  const [stop, setStop] = useState(false);  const [list, setList] = useState([]);  useEffect(() =&gt; &#123;    let timer;    if (start) &#123;      timer = setTimeout(() =&gt; &#123;        setTime(time + 1);      &#125;, 1000);    &#125;    return () =&gt; clearTimeout(timer);  &#125;, [start, time]);  const handleTaskChange = (e) =&gt; &#123;    setTask(e.target.value);  &#125;;  const handleTimeChange = (e) =&gt; &#123;    setTime(Number(e.target.value));  &#125;;  const handleStartClick = () =&gt; &#123;    setStart(true);  &#125;;  const handleStopClick = () =&gt; &#123;    setStop(true);    setStart(false);    setTime(0);    let tem = [...list],      check = false;    tem = tem.map((ele) =&gt; &#123;      const temp = ele.split(&quot; &quot;);      if (temp[1] === task) &#123;        temp[2] = Number(temp[2]) + Number(time);        check = true;      &#125;      return temp.join(&quot; &quot;);    &#125;);    if (!check) &#123;      setList([...tem, tem.length + 1 + &quot; &quot; + task + &quot; &quot; + time]);    &#125; else &#123;      setList(tem);    &#125;  &#125;;  return (    &lt;div className=&quot;App&quot;&gt;      Task Name: &lt;input value=&#123;task&#125; onChange=&#123;handleTaskChange&#125; /&gt;      Time elapsed:      &lt;input value=&#123;time&#125; onChange=&#123;handleTimeChange&#125; /&gt;      &lt;button onClick=&#123;handleStartClick&#125;&gt;start&lt;/button&gt;      &lt;button onClick=&#123;handleStopClick&#125;&gt;stop&lt;/button&gt;      &lt;div&gt;        Amount:        &#123;list.reduce((acc, cur) =&gt; &#123;          return (acc += Number(cur.split(&quot; &quot;)[2]));        &#125;, 0)&#125;        &#123;list.length !== 0 &amp;&amp;          list.map((ele, idx) =&gt; &#123;            return &lt;li key=&#123;idx&#125;&gt;&#123;ele&#125;&lt;/li&gt;;          &#125;)&#125;      &lt;/div&gt;    &lt;/div&gt;  );&#125;\n\nside menuimport &quot;./styles.css&quot;;import &#123; useState &#125; from &quot;react&quot;;const menuConfig = [  &#123;    title: &quot;Home&quot;  &#125;,  &#123;    title: &quot;Services&quot;,    subItems: [&quot;Cooking&quot;, &quot;Cleaning&quot;]  &#125;,  &#123;    title: &quot;Contact&quot;,    subItems: [&quot;Phone&quot;, &quot;Mail&quot;]  &#125;];export const Item = (&#123; element, children &#125;) =&gt; &#123;  const [show, setShow] = useState(false);  return (    &lt;li&gt;      &#123;element.title || element&#125;      &#123;element.subItems &amp;&amp; (        &lt;button onClick=&#123;() =&gt; setShow(!show)&#125;&gt;          &#123;show ? &quot;hide&quot; : &quot;expand&quot;&#125;        &lt;/button&gt;      )&#125;      &#123;show &amp;&amp; children&#125;    &lt;/li&gt;  );&#125;;export default function App() &#123;  const renderChildrenMenu = (items) =&gt; &#123;    return items.map((ele) =&gt; &#123;      return (        &lt;Item element=&#123;ele&#125;&gt;          &#123;ele.subItems &amp;&amp; &lt;ul&gt;&#123;renderChildrenMenu(ele.subItems)&#125;&lt;/ul&gt;&#125;        &lt;/Item&gt;      );    &#125;);  &#125;;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;ul&gt;&#123;renderChildrenMenu(menuConfig)&#125;&lt;/ul&gt;    &lt;/div&gt;  );&#125;\nversion2:\nimport React from &#x27;react&#x27;;import &#x27;./style.css&#x27;;import &#123; useState, useEffect &#125; from &#x27;react&#x27;;const menuConfig = [  &#123;    title: &#x27;Home&#x27;,  &#125;,  &#123;    title: &#x27;Services&#x27;,    subItems: [&#x27;Cooking&#x27;, &#x27;Cleaning&#x27;],  &#125;,  &#123;    title: &#x27;Contact&#x27;,    subItems: [&#x27;Phone&#x27;, &#x27;Mail&#x27;],  &#125;,];export default function App() &#123;  const [menuState, setMenuState] = useState(menuConfig);  return (    &lt;div&gt;      &lt;Sidemenu menuConfig=&#123;menuState&#125; /&gt;    &lt;/div&gt;  );&#125;function Sidemenu(&#123; menuConfig &#125;) &#123;  const [show, setShow] = useState(&#x27;&#x27;);  return (    &lt;div className=&quot;menu-wrapper&quot;&gt;      &#123;menuConfig.map((menuItem) =&gt; &#123;        return (          &lt;div            key=&#123;menuItem.title.toLowerCase()&#125;            data-test-id=&#123;`first-level-$&#123;menuItem.title.toLowerCase()&#125;`&#125;          &gt;            &#123;menuItem.title || menuItem&#125;            &#123;menuItem.subItems &amp;&amp; (              &lt;button                data-test-id=&#123;`button-$&#123;menuItem.title.toLowerCase()&#125;`&#125;                onClick=&#123;() =&gt; &#123;                  show === menuItem.title                    ? setShow(&#x27;&#x27;)                    : setShow(menuItem.title);                &#125;&#125;              &gt;                &#123;show === menuItem.title ? &#x27;Hide&#x27; : &#x27;Expand&#x27;&#125;              &lt;/button&gt;            )&#125;            &#123;show === menuItem.title &amp;&amp; menuItem.subItems &amp;&amp; (              &lt;ul data-test-id=&#123;`ul-$&#123;menuItem.title.toLowerCase()&#125;`&#125;&gt;                &#123;menuItem.subItems.map((subItem) =&gt; &#123;                  return (                    &lt;li                      key=&#123;`li-$&#123;menuItem.title.toLowerCase()&#125;-$&#123;subItem.toLowerCase()&#125;`&#125;                      data-test-id=&#123;`li-$&#123;menuItem.title.toLowerCase()&#125;-$&#123;subItem.toLowerCase()&#125;`&#125;                    &gt;                      &#123;subItem&#125;                    &lt;/li&gt;                  );                &#125;)&#125;              &lt;/ul&gt;            )&#125;          &lt;/div&gt;        );      &#125;)&#125;    &lt;/div&gt;  );&#125;\n\nCascading country/state/cityimport &quot;./styles.css&quot;;import React, &#123;useState, useEffect&#125; from &#x27;react&#x27;;const data = &#123;  countries: [    &#123;      name: &quot;Germany&quot;,      states: [        &#123;          name: &quot;A&quot;,          cities: [&quot;Duesseldorf&quot;, &quot;Leinfelden-Echterdingen&quot;, &quot;Eschborn&quot;]        &#125;      ]    &#125;,    &#123; name: &quot;Spain&quot;, states: [&#123; name: &quot;B&quot;, cities: [&quot;Barcelona&quot;] &#125;] &#125;,    &#123; name: &quot;USA&quot;, states: [&#123; name: &quot;C&quot;, cities: [&quot;Downers Grove&quot;] &#125;] &#125;,    &#123;      name: &quot;Mexico&quot;,      states: [&#123; name: [&quot;D&quot;, &quot;F&quot;, &quot;H&quot;], cities: [&quot;Puebla&quot;] &#125;]    &#125;,    &#123;      name: &quot;India&quot;,      states: [        &#123; name: &quot;E&quot;, cities: [&quot;Delhi&quot;, &quot;Kolkata&quot;, &quot;Mumbai&quot;, &quot;Bangalore&quot;] &#125;      ]    &#125;  ]&#125;;export default function App() &#123;  const [country, setCountry] = useState(&quot;&quot;);  const [city, setCity] = useState(&quot;&quot;);  const [state, setState] = useState(&quot;&quot;);  const selectedCounrty = data.countries.map((ele) =&gt; ele.name);  const selectedState = country !== &quot;&quot; ? data.countries.filter((ele) =&gt; ele.name === country)[0].states.map((ele) =&gt; ele.name) : [];  const selectedCity = state !== &quot;&quot; ? data.countries.filter((ele) =&gt; ele.name === country)[0].states.filter((ele) =&gt; ele.name === state)[0].cities : [];  const handleSelectChange = (e) =&gt; &#123;    if(country === &quot;&quot;)&#123;      setCountry(e.target.value);    &#125;else if(country !== &quot;&quot; &amp;&amp; state === &quot;&quot;)&#123;      setState(e.target.value)    &#125;else&#123;      setCity(e.target.value);    &#125;  &#125;  const renderUI = (arr) =&gt; &#123;    return (      &lt;React.Fragment&gt;        &lt;select onChange=&#123;handleSelectChange&#125;&gt;          &lt;option&gt;select&lt;/option&gt;          &#123;arr.map((ele) =&gt; &lt;option value=&#123;ele&#125;&gt;&#123;ele&#125;&lt;/option&gt;)&#125;        &lt;/select&gt;      &lt;/React.Fragment&gt;    )  &#125;  return &lt;div className=&quot;App&quot;&gt;    Country: &#123;renderUI(selectedCounrty)&#125;    State: &#123;renderUI(selectedState)&#125;    City: &#123;renderUI(selectedCity)&#125;  &lt;/div&gt;;&#125;\nversion2\nimport &quot;./styles.css&quot;;import * as React from &quot;react&quot;;const data = &#123;  countries: [    &#123;      name: &quot;Germany&quot;,      states: [        &#123;          name: &quot;A&quot;,          cities: [&quot;Duesseldorf&quot;, &quot;Leinfelden-Echterdingen&quot;, &quot;Eschborn&quot;]        &#125;      ]    &#125;,    &#123; name: &quot;Spain&quot;, states: [&#123; name: &quot;B&quot;, cities: [&quot;Barcelona&quot;] &#125;] &#125;,    &#123; name: &quot;USA&quot;, states: [&#123; name: &quot;C&quot;, cities: [&quot;Downers Grove&quot;] &#125;] &#125;,    &#123;      name: &quot;Mexico&quot;,      states: [&#123; name: [&quot;D&quot;, &quot;F&quot;, &quot;H&quot;], cities: [&quot;Puebla&quot;] &#125;]    &#125;,    &#123;      name: &quot;India&quot;,      states: [        &#123; name: &quot;E&quot;, cities: [&quot;Delhi&quot;, &quot;Kolkata&quot;, &quot;Mumbai&quot;, &quot;Bangalore&quot;] &#125;      ]    &#125;  ]&#125;;export default function App() &#123;  const [selectedCountry, setSelectedCountry] = React.useState();  const [selectedState, setSelectedState] = React.useState();  const [selectedCity, setSelectedCity] = React.useState();  const availableState = data.countries.find((c) =&gt; c.name === selectedCountry);  const availableCities = availableState?.states?.find(    (s) =&gt; s.name === selectedState  );  return (    &lt;div id=&quot;container&quot;&gt;      &lt;h2&gt;Cascading or Dependent Dropdown using React&lt;/h2&gt;      &lt;div&gt;        &lt;label&gt;Country&lt;/label&gt;        &lt;select          placeholder=&quot;Country&quot;          value=&#123;selectedCountry&#125;          onChange=&#123;(e) =&gt; setSelectedCountry(e.target.value)&#125;        &gt;          &lt;option&gt;--Choose Country--&lt;/option&gt;          &#123;data.countries.map((value, key) =&gt; &#123;            return (              &lt;option value=&#123;value.name&#125; key=&#123;key&#125;&gt;                &#123;value.name&#125;              &lt;/option&gt;            );          &#125;)&#125;        &lt;/select&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;label&gt;State&lt;/label&gt;        &lt;select          placeholder=&quot;State&quot;          value=&#123;selectedState&#125;          onChange=&#123;(e) =&gt; setSelectedState(e.target.value)&#125;        &gt;          &lt;option&gt;--Choose State--&lt;/option&gt;          &#123;availableState?.states.map((e, key) =&gt; &#123;            return (              &lt;option value=&#123;e.name&#125; key=&#123;key&#125;&gt;                &#123;e.name&#125;              &lt;/option&gt;            );          &#125;)&#125;        &lt;/select&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;label&gt;City&lt;/label&gt;        &lt;select          placeholder=&quot;City&quot;          value=&#123;selectedCity&#125;          onChange=&#123;(e) =&gt; setSelectedCity(e.target.value)&#125;        &gt;          &lt;option&gt;--Choose City--&lt;/option&gt;          &#123;availableCities?.cities.map((e, key) =&gt; &#123;            return (              &lt;option value=&#123;e.name&#125; key=&#123;key&#125;&gt;                &#123;e&#125;              &lt;/option&gt;            );          &#125;)&#125;        &lt;/select&gt;      &lt;/div&gt;    &lt;/div&gt;  );&#125;\n\ncalculatorimport &quot;./styles.css&quot;;import React, &#123; useState &#125; from &quot;react&quot;;function Calculator() &#123;  const [displayValue, setDisplayValue] = useState(&quot;0&quot;);  const [waitingForOperand, setWaitingForOperand] = useState(false);  const [operator, setOperator] = useState(null);  const [value, setValue] = useState(null);  const inputDigit = (e) =&gt; &#123;    const digit = e.target.textContent;    if (waitingForOperand) &#123;      setDisplayValue(String(digit));      setWaitingForOperand(false);    &#125; else &#123;      setDisplayValue(        displayValue.charAt(0) === &quot;0&quot; ? digit : displayValue + digit      );    &#125;  &#125;;  function inputDot() &#123;    if (waitingForOperand) &#123;      setDisplayValue(&quot;.&quot;);      setWaitingForOperand(false);    &#125; else if (displayValue.indexOf(&quot;.&quot;) === -1) &#123;      setDisplayValue(displayValue + &quot;.&quot;);      setWaitingForOperand(false);    &#125;  &#125;  function clearDisplay() &#123;    setDisplayValue(&quot;0&quot;);    setValue(null);  &#125;  function toggleSign() &#123;    setDisplayValue(      displayValue.charAt(0) !== &quot;-&quot;        ? &quot;-&quot; + displayValue        : displayValue.substr(1)    );  &#125;  function convertPercent() &#123;    const value = parseFloat(displayValue);    setDisplayValue(String(value / 100));  &#125;  function performOperation(e) &#123;    const nextOperator = e.target.textContent;    const nextValue = parseFloat(displayValue);    const operations = &#123;      &quot;/&quot;: (prevValue, nextValue) =&gt; prevValue / nextValue,      x: (prevValue, nextValue) =&gt; prevValue * nextValue,      &quot;-&quot;: (prevValue, nextValue) =&gt; prevValue - nextValue,      &quot;+&quot;: (prevValue, nextValue) =&gt; prevValue + nextValue,      &quot;=&quot;: (prevValue, nextValue) =&gt; nextValue    &#125;;    if (value === null) &#123;      setValue(nextValue);    &#125; else if (operator) &#123;      const currentValue = value || 0;      const computedValue = operations[operator](currentValue, nextValue);      setValue(computedValue);      setDisplayValue(String(computedValue));    &#125;    setWaitingForOperand(true);    setOperator(nextOperator);  &#125;  return (    &lt;div className=&quot;calculator&quot;&gt;      &lt;div className=&quot;displayPanel&quot;&gt;&#123;displayValue&#125;&lt;/div&gt;      &lt;div className=&quot;inputPanel&quot;&gt;        &lt;button onClick=&#123;clearDisplay&#125;&gt;AC&lt;/button&gt;        &lt;button onClick=&#123;toggleSign&#125;&gt;+/-&lt;/button&gt;        &lt;button onClick=&#123;convertPercent&#125;&gt;%&lt;/button&gt;        &lt;button className=&quot;operators&quot; onClick=&#123;performOperation&#125;&gt;          /        &lt;/button&gt;        &lt;button onClick=&#123;inputDigit&#125;&gt;7&lt;/button&gt;        &lt;button onClick=&#123;inputDigit&#125;&gt;8&lt;/button&gt;        &lt;button onClick=&#123;inputDigit&#125;&gt;9&lt;/button&gt;        &lt;button className=&quot;operators&quot; onClick=&#123;performOperation&#125;&gt;          x        &lt;/button&gt;        &lt;button onClick=&#123;inputDigit&#125;&gt;4&lt;/button&gt;        &lt;button onClick=&#123;inputDigit&#125;&gt;5&lt;/button&gt;        &lt;button onClick=&#123;inputDigit&#125;&gt;6&lt;/button&gt;        &lt;button className=&quot;operators&quot; onClick=&#123;performOperation&#125;&gt;          -        &lt;/button&gt;        &lt;button onClick=&#123;inputDigit&#125;&gt;1&lt;/button&gt;        &lt;button onClick=&#123;inputDigit&#125;&gt;2&lt;/button&gt;        &lt;button onClick=&#123;inputDigit&#125;&gt;3&lt;/button&gt;        &lt;button className=&quot;operators&quot; onClick=&#123;performOperation&#125;&gt;          +        &lt;/button&gt;        &lt;button onClick=&#123;inputDigit&#125; id=&quot;zero&quot;&gt;          0        &lt;/button&gt;        &lt;button onClick=&#123;inputDot&#125;&gt;.&lt;/button&gt;        &lt;button className=&quot;operators&quot; onClick=&#123;performOperation&#125;&gt;          =        &lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  );&#125;export default function App() &#123;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;Calculator /&gt;;    &lt;/div&gt;  );&#125;\n\nTableimport React from &#x27;react&#x27;;function Table(props) &#123;  return (    &lt;table&gt;      &lt;thead&gt;        &lt;tr&gt;          &lt;th&gt;Name&lt;/th&gt;          &lt;th&gt;Age&lt;/th&gt;          &lt;th&gt;Gender&lt;/th&gt;        &lt;/tr&gt;      &lt;/thead&gt;      &lt;tbody&gt;        &#123;props.data.map((item, index) =&gt; (          &lt;tr key=&#123;index&#125;&gt;            &lt;td&gt;&#123;item.name&#125;&lt;/td&gt;            &lt;td&gt;&#123;item.age&#125;&lt;/td&gt;            &lt;td&gt;&#123;item.gender&#125;&lt;/td&gt;          &lt;/tr&gt;        ))&#125;      &lt;/tbody&gt;    &lt;/table&gt;  );&#125;export default Table;\n\n15 pizzle\nhttps://codesandbox.io/s/homework-8-22-react15puzzle-ewun6o?file=/src/readme.mdimport React from &#x27;react&#x27;;import &#x27;./style.css&#x27;;const initialBoard = [1, 2, 0, 4, 5, 6, 3, 8, 9, 10, 7, 12, 13, 14, 11, 15];const onSolveCallback = () =&gt; &#123;  alert(&quot;Congratuate! You have solve the puzzles!&quot;)&#125;export default function App() &#123;    return (    &lt;div&gt;      &lt;h1&gt;Hello StackBlitz!&lt;/h1&gt;      &lt;p&gt;Start editing to see some magic happen :)&lt;/p&gt;      &lt;Board initialBoard=&#123;initialBoard&#125; onSolveCallback=&#123;onSolveCallback&#125; /&gt;    &lt;/div&gt;  );&#125;function Board(&#123; initialBoard, onSolveCallback &#125;) &#123;  const [boardState, setBoardState] = React.useState(initialBoard);  const [solveAlertShow, setSolveAlertShow] = React.useState(false);  const handleMoveTile = (tile) =&gt; &#123;    const indexZero = boardState.indexOf(0);    const indexTile = boardState.indexOf(tile);    const tempBoardState = [...boardState];    if (      (indexTile - indexZero === 1 &amp;&amp; Math.floor(indexTile / 4) === Math.floor(indexZero / 4)) ||      (indexTile - indexZero === -1 &amp;&amp; Math.floor(indexTile / 4) === Math.floor(indexZero / 4)) ||      indexTile - indexZero === 4 ||      indexTile - indexZero === -4    ) &#123;      tempBoardState[indexZero] = tile;      tempBoardState[indexTile] = 0;    &#125;    setBoardState(tempBoardState);  &#125;;  function checkSolve()&#123;    let i = 1;    const tempBoradState = [...boardState];    tempBoradState.pop();    const solve = tempBoradState.reduce((acc, currentValue) =&gt; &#123;      if(currentValue - i++ === 0)&#123;        acc = true;        return acc;      &#125;else&#123;        acc = false;        return acc;      &#125;    &#125;, false)    return solve;  &#125;  React.useEffect(() =&gt; &#123;    if(boardState[boardState.length - 1] === 0 &amp;&amp; checkSolve())&#123;      console.log(&quot;congrats!&quot;);      setSolveAlertShow(true);    &#125;    if(solveAlertShow)&#123;      onSolveCallback();    &#125;  &#125;, [boardState, solveAlertShow])  return (    &lt;div className=&quot;board&quot;&gt;      &#123;boardState.map((tile) =&gt; &#123;        return &lt;Tile key=&#123;tile&#125; tile=&#123;tile&#125; handleMoveTile=&#123;handleMoveTile&#125; /&gt;;      &#125;)&#125;    &lt;/div&gt;  );&#125;function Tile(&#123; tile, handleMoveTile &#125;) &#123;  return (    &lt;div      className=&#123;tile === 0 ? &quot;empty&quot; : &quot;tile&quot;&#125;      onClick=&#123;() =&gt; &#123;        handleMoveTile(tile);      &#125;&#125;    &gt;      &#123;tile&#125;    &lt;/div&gt;  );&#125;\n.board &#123;  display: grid;  grid-template-columns: repeat(4, 1fr);  width: 500px;  height: 500px;  gap: 10px;&#125;.tile &#123;  border: 1px solid black;  text-align: center;  font-size: 2rem;  border-radius: 5px;  display: flex;  justify-content: center;  align-items: center;&#125;.empty &#123;  color: transparent;&#125;\n\nRunning clock2import React from &#x27;react&#x27;;import &#x27;./style.css&#x27;;import &#123; useState, useEffect &#125; from &#x27;react&#x27;;export default function App() &#123;  const [userInputMinute, setUserInputMinute] = useState(0);  const [userInputSecond, setUserInputSecond] = useState(0);  const [time, setTime] = useState(&#123;    minutes: parseInt(userInputMinute),    seconds: parseInt(userInputSecond),  &#125;);  const [start, setStart] = useState(false);  const [pause, setPause] = useState(false);  const [over, setOver] = useState(false);  useEffect(() =&gt; &#123;    if((userInputMinute === 0 &amp;&amp; userInputSecond === 0) || !start) return;    let timer = setInterval(() =&gt; &#123;tick()&#125;, 1000);    return () =&gt; clearInterval(timer);  &#125;);  const tick = () =&gt; &#123;    if(pause || over) return;    if(time.minutes === 0 &amp;&amp; time.seconds === 0)&#123;      setOver(true)    &#125;else if(time.seconds === 0)&#123;      setTime(&#123;        minutes: time.minutes - 1,        seconds: 59      &#125;)    &#125;else&#123;      setTime(&#123;        minutes: time.minutes,        seconds: time.seconds - 1      &#125;)    &#125;  &#125;  const handleClockStart = () =&gt; &#123;    if (userInputSecond &lt; 60) &#123;      setTime(&#123;        minutes: parseInt(userInputMinute),        seconds: parseInt(userInputSecond),      &#125;);    &#125; else &#123;      let secondTimes = Math.floor(userInputSecond / 60);      setTime(&#123;        minutes: parseInt(userInputMinute) + secondTimes,        seconds: parseInt(userInputSecond - secondTimes * 60),      &#125;);    &#125;    setStart(true);  &#125;;  const handleClockPause = () =&gt; &#123;    setPause(!pause);  &#125;  const handleClockRestart = () =&gt; &#123;    setTime(&#123;      minutes: parseInt(0),      seconds: parseInt(0)    &#125;)    setUserInputMinute(0);    setUserInputSecond(0);    setStart(false);    setPause(false);    setOver(false);  &#125;  return (    &lt;div&gt;      &lt;div className=&quot;container&quot;&gt;        &lt;label&gt;          &lt;input            type=&quot;number&quot;            value=&#123;userInputMinute&#125;            onChange=&#123;(e) =&gt; setUserInputMinute(e.target.value)&#125;          /&gt;          Minutes        &lt;/label&gt;        &lt;label&gt;          &lt;input            type=&quot;number&quot;            value=&#123;userInputSecond&#125;            onChange=&#123;(e) =&gt; setUserInputSecond(e.target.value)&#125;          /&gt;          Seconds        &lt;/label&gt;        &lt;button onClick=&#123;handleClockStart&#125;&gt;START&lt;/button&gt;        &lt;button onClick=&#123;handleClockPause&#125;&gt;PAUSE / RESUME&lt;/button&gt;        &lt;button onClick=&#123;handleClockRestart&#125;&gt;RESET&lt;/button&gt;      &lt;/div&gt;      &lt;h1 data-testid=&quot;running-clock&quot;&gt;        &#123;`$&#123;time.minutes.toString().padStart(2, &#x27;0&#x27;)&#125;`&#125;:        &#123;`$&#123;time.seconds.toString().padStart(2, &#x27;0&#x27;)&#125;`&#125;      &lt;/h1&gt;    &lt;/div&gt;  );&#125;\n.container &#123;  display: flex;  justify-content: center;  align-items: center;&#125;\n\nactive tabsimport React from &#x27;react&#x27;;import &#x27;./style.css&#x27;;import &#123; useState, useEffect &#125; from &#x27;react&#x27;;const tabs = [  &#123;    title: &#x27;section title 1&#x27;,    content: &#x27;content of section 1&#x27;,  &#125;,  &#123;    title: &#x27;section title 2&#x27;,    content: &#x27;content of section 2&#x27;,  &#125;,  &#123;    title: &#x27;section title 3&#x27;,    content: &#x27;content of section 3&#x27;,  &#125;,];export default function App() &#123;  const [tabsState, setTabsState] = useState(tabs);  return (    &lt;div&gt;      &lt;Tabs tabs=&#123;tabsState&#125; /&gt;    &lt;/div&gt;  );&#125;function Tabs(&#123; tabs &#125;) &#123;  const [activeTabIndex, setActiveTabIndex] = useState(0);  return (    &lt;div className=&quot;tabs&quot;&gt;      &lt;div className=&quot;flex-container&quot;&gt;        &#123;tabs.map((tab, idx) =&gt; &#123;          return (            &lt;div key=&#123;idx&#125;&gt;              &lt;button                className=&quot;btn&quot;                disabled=&#123;activeTabIndex === idx&#125;                onClick=&#123;() =&gt; setActiveTabIndex(idx)&#125;              &gt;                &#123;tab.title&#125;              &lt;/button&gt;            &lt;/div&gt;          );        &#125;)&#125;      &lt;/div&gt;      &#123;tabs[activeTabIndex].content&#125;    &lt;/div&gt;  );&#125;\n.flex-container &#123;  display: flex;&#125;\n\n\n\nimport &quot;./styles.css&quot;;import &#123; useState, useEffect &#125; from &quot;react&quot;;export default function App() &#123;  const [task, setTask] = useState(&quot;&quot;);  const [time, setTime] = useState(0);  const [start, setStart] = useState(false);  const [stop, setStop] = useState(false);  const [list, setList] = useState([]);  useEffect(() =&gt; &#123;    let timer;    if (start) &#123;      timer = setTimeout(() =&gt; &#123;        setTime(time + 1);      &#125;, 1000);    &#125;    return () =&gt; clearTimeout(timer);  &#125;, [start, time]);  const handleTaskChange = (e) =&gt; &#123;    setTask(e.target.value);  &#125;;  const handleTimeChange = (e) =&gt; &#123;    setTime(Number(e.target.value));  &#125;;  const handleStartClick = () =&gt; &#123;    setStart(true);  &#125;;  const handleStopClick = () =&gt; &#123;    setStop(true);    setStart(false);    setTime(0);    let tem = [...list],      check = false;    tem = tem.map((ele) =&gt; &#123;      const temp = ele.split(&quot; &quot;);      if (temp[1] === task) &#123;        temp[2] = Number(temp[2]) + Number(time);        check = true;      &#125;      return temp.join(&quot; &quot;);    &#125;);    if (!check) &#123;      setList([...tem, tem.length + 1 + &quot; &quot; + task + &quot; &quot; + time]);    &#125; else &#123;      setList(tem);    &#125;  &#125;;  return (    &lt;div className=&quot;App&quot;&gt;      Task Name: &lt;input value=&#123;task&#125; onChange=&#123;handleTaskChange&#125; /&gt;      Time elapsed:      &lt;input value=&#123;time&#125; onChange=&#123;handleTimeChange&#125; /&gt;      &lt;button onClick=&#123;handleStartClick&#125;&gt;start&lt;/button&gt;      &lt;button onClick=&#123;handleStopClick&#125;&gt;stop&lt;/button&gt;      &lt;div&gt;        Amount:        &#123;list.reduce((acc, cur) =&gt; &#123;          return (acc += Number(cur.split(&quot; &quot;)[2]));        &#125;, 0)&#125;        &#123;list.length !== 0 &amp;&amp;          list.map((ele, idx) =&gt; &#123;            return &lt;li key=&#123;idx&#125;&gt;&#123;ele&#125;&lt;/li&gt;;          &#125;)&#125;      &lt;/div&gt;    &lt;/div&gt;  );&#125;\n\nimport React, &#123; useEffect, useCallback, useMemo &#125; from &quot;react&quot;;import &quot;./styles.css&quot;;// the exported component can be either a function or a classexport default function Board(&#123; initialConfiguration, onSolveCallback &#125;) &#123;  const [list, setList] = React.useState(initialConfiguration);  const [show, setShow] = React.useState(false);  // useMemo, useCallback  const check = useCallback(() =&gt; &#123;    let i = 1;    const temp = [...list];    temp.pop();    const result = temp.reduce((acc, cur, idx) =&gt; &#123;      if (cur - i++ === 0) &#123;        return (acc = true);      &#125; else return (acc = false);    &#125;, false);    return result;  &#125;, [list]);  useEffect(() =&gt; &#123;    if (list[list.length - 1] === 0 &amp;&amp; check()) &#123;      setShow(true);    &#125;    if (show) &#123;      onSolveCallback();    &#125;  &#125;, [list, check, show, onSolveCallback]);  const handleClick = (target) =&gt; &#123;    const index0 = list.indexOf(0);    const indexTarget = list.indexOf(target);    const temp = [...list];    if (      indexTarget - index0 === 4 ||      indexTarget - index0 === -4 ||      indexTarget - index0 === 1 ||      indexTarget - index0 === -1    ) &#123;      const temEle = temp[index0];      temp[index0] = temp[indexTarget];      temp[indexTarget] = temEle;    &#125;    setList(temp);  &#125;;  return (    &lt;div className=&quot;board&quot;&gt;      &#123;list.map((ele, idx) =&gt; (        &lt;div          onClick=&#123;() =&gt; handleClick(ele)&#125;          className=&#123;ele !== 0 ? &quot;tile&quot; : &quot;tile-empty&quot;&#125;        &gt;          &#123;ele !== 0 ? ele : &quot;&quot;&#125;        &lt;/div&gt;      ))&#125;    &lt;/div&gt;  );&#125;\n\n\nimport &quot;./styles.css&quot;;import * as React from &quot;react&quot;;const data = &#123;  countries: [    &#123;      name: &quot;Germany&quot;,      states: [        &#123;          name: &quot;A&quot;,          cities: [&quot;Duesseldorf&quot;, &quot;Leinfelden-Echterdingen&quot;, &quot;Eschborn&quot;]        &#125;      ]    &#125;,    &#123; name: &quot;Spain&quot;, states: [&#123; name: &quot;B&quot;, cities: [&quot;Barcelona&quot;] &#125;] &#125;,    &#123; name: &quot;USA&quot;, states: [&#123; name: &quot;C&quot;, cities: [&quot;Downers Grove&quot;] &#125;] &#125;,    &#123;      name: &quot;Mexico&quot;,      states: [&#123; name: [&quot;D&quot;, &quot;F&quot;, &quot;H&quot;], cities: [&quot;Puebla&quot;] &#125;]    &#125;,    &#123;      name: &quot;India&quot;,      states: [        &#123; name: &quot;E&quot;, cities: [&quot;Delhi&quot;, &quot;Kolkata&quot;, &quot;Mumbai&quot;, &quot;Bangalore&quot;] &#125;      ]    &#125;  ]&#125;;export default function App() &#123;  const [selectedCountry, setSelectedCountry] = React.useState();  const [selectedState, setSelectedState] = React.useState();  const [selectedCity, setSelectedCity] = React.useState();  const availableState = data.countries.find((c) =&gt; c.name === selectedCountry);  const availableCities = availableState?.states?.find(    (s) =&gt; s.name === selectedState  );  return (    &lt;div id=&quot;container&quot;&gt;      &lt;h2&gt;Cascading or Dependent Dropdown using React&lt;/h2&gt;      &lt;div&gt;        &lt;label&gt;Country&lt;/label&gt;        &lt;select          placeholder=&quot;Country&quot;          value=&#123;selectedCountry&#125;          onChange=&#123;(e) =&gt; setSelectedCountry(e.target.value)&#125;        &gt;          &lt;option&gt;--Choose Country--&lt;/option&gt;          &#123;data.countries.map((value, key) =&gt; &#123;            return (              &lt;option value=&#123;value.name&#125; key=&#123;key&#125;&gt;                &#123;value.name&#125;              &lt;/option&gt;            );          &#125;)&#125;        &lt;/select&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;label&gt;State&lt;/label&gt;        &lt;select          placeholder=&quot;State&quot;          value=&#123;selectedState&#125;          onChange=&#123;(e) =&gt; setSelectedState(e.target.value)&#125;        &gt;          &lt;option&gt;--Choose State--&lt;/option&gt;          &#123;availableState?.states.map((e, key) =&gt; &#123;            return (              &lt;option value=&#123;e.name&#125; key=&#123;key&#125;&gt;                &#123;e.name&#125;              &lt;/option&gt;            );          &#125;)&#125;        &lt;/select&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;label&gt;City&lt;/label&gt;        &lt;select          placeholder=&quot;City&quot;          value=&#123;selectedCity&#125;          onChange=&#123;(e) =&gt; setSelectedCity(e.target.value)&#125;        &gt;          &lt;option&gt;--Choose City--&lt;/option&gt;          &#123;availableCities?.cities.map((e, key) =&gt; &#123;            return (              &lt;option value=&#123;e.name&#125; key=&#123;key&#125;&gt;                &#123;e&#125;              &lt;/option&gt;            );          &#125;)&#125;        &lt;/select&gt;      &lt;/div&gt;    &lt;/div&gt;  );&#125;\n\nimport &quot;./styles.css&quot;;import &#123; useState, useEffect &#125; from &quot;react&quot;;const data = [1, 2, 3, 1, 2, 3];export default function App() &#123;  const [list, setList] = useState(data);  const [preCard, setPreCard] = useState(null);    useEffect(() =&gt; &#123;    setList(      data.map((ele, idx) =&gt; &#123;        const obj = &#123;          id: idx,          val: ele,          isTurn: false        &#125;;        return obj;      &#125;)    );  &#125;, []);  const handleClick = (target) =&gt; &#123;    setList(      [...list].map((ele) =&gt; &#123;        if (ele.id === target.id) &#123;          ele.isTurn = !ele.isTurn;        &#125;        return ele;      &#125;)    );    if (!preCard) &#123;      setPreCard(target);    &#125; else &#123;      if (preCard &amp;&amp; preCard.val === target.val) &#123;        setTimeout(() =&gt; &#123;          setList(            [...list].filter((ele) =&gt; &#123;              if (ele.id !== preCard.id &amp;&amp; ele.id !== target.id) &#123;                return ele;              &#125;            &#125;)          );        &#125;, 1000);      &#125; else &#123;        setTimeout(() =&gt; &#123;          setList(            [...list].map((ele) =&gt; &#123;              ele.isTurn = false;              return ele;            &#125;)          );        &#125;, 1000);      &#125;      setPreCard(null);    &#125;  &#125;;  return (    &lt;div className=&quot;App&quot;&gt;      &#123;list.length !== 0 &amp;&amp;        list.map((ele) =&gt; (          &lt;div key=&#123;ele.id&#125; className=&quot;card&quot; onClick=&#123;() =&gt; handleClick(ele)&#125;&gt;            &#123;ele.isTurn &amp;&amp; ele.val&#125;          &lt;/div&gt;        ))&#125;      &#123;list.length === 0 &amp;&amp; &lt;h1&gt;Success!!!&lt;/h1&gt;&#125;    &lt;/div&gt;  );&#125;\n\nExam Calendarimport React from &#x27;react&#x27;;import &#x27;./style.css&#x27;;import &#123; useState, useEffect &#125; from &#x27;react&#x27;;const data = [  &#123; month: 1, day: 30 &#125;,  &#123; month: 2, day: 31 &#125;,];const week = [&#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;, &#x27;Sun&#x27;];export default function App() &#123;  const [selectedDay, setSelectedDay] = useState(null);  const [selectedMonth, setSelectedMonth] = useState(1);  const daysForSelectedMonth = data.find((item) =&gt; &#123;    return item.month === selectedMonth;  &#125;)?.day;  let daysArray = [];  for (let i = 1; i &lt;= daysForSelectedMonth; i++) &#123;    console.log(i);    daysArray.push(i);  &#125;  const classes = &#x27;tile&#x27;;  return (    &lt;div&gt;      &lt;h1&gt;        Month &#123;selectedMonth&#125;, Selected Day: &#123;selectedDay&#125;      &lt;/h1&gt;      &lt;div className=&quot;calendar&quot;&gt;        &#123;daysArray.map((day) =&gt; &#123;          return (            &lt;div              key=&#123;day&#125;              className=&#123;selectedDay === day ? classes + &#x27; selected&#x27; : classes&#125;              onClick=&#123;() =&gt; &#123;                setSelectedDay(day);              &#125;&#125;            &gt;              &#123;week[(day - 1) % 7]&#125; &#123;day&#125;            &lt;/div&gt;          );        &#125;)&#125;      &lt;/div&gt;    &lt;/div&gt;  );&#125;\n\n.tile &#123;  border: 1px solid black;  text-align: center;  font-size: 2rem;  border-radius: 5px;  display: flex;  justify-content: center;  align-items: center;&#125;.calendar&#123;  display: grid;  grid-template-columns: repeat(7, 1fr);&#125;.selected&#123;  background-color: red;&#125;\n"},{"title":"二叉树","url":"/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"什么是二叉树？\n相关的python lib：\n\ndeque（doubly ended queue) in Python is implemented using the module “collections“\nDeque is preferred over a list in the cases where we need quicker append and pop operations from both the ends of the container, \ndeque provides an O(1) time complexity for append and pop operations as compared to list which provides O(n) time complexity.from collections import deque # Declaring deque queue = deque([&#x27;name&#x27;,&#x27;age&#x27;,&#x27;DOB&#x27;])  \n\nN个节点BST的高度：分类讨论\n144. 二叉树前序遍历/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var preorderTraversal = function(root) &#123;    let res = []    const dfs = function(root)&#123;        if(root === null) return;        res.push(root.val)        dfs(root.left)        dfs(root.right)    &#125;    dfs(root)    return res&#125;;\n\n94. 二叉树中序遍历/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var inorderTraversal = function(root) &#123;    let res = []    const dfs = function(root)&#123;        if(root === null) return        dfs(root.left)        res.push(root.val)        dfs(root.right)    &#125;    dfs(root)    return res&#125;;\n\n145. 二叉树后序遍历/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var postorderTraversal = function(root) &#123;    let res = []    const dfs = function(root)&#123;        if(root === null) return;        dfs(root.left)        dfs(root.right)        res.push(root.val)    &#125;    dfs(root)    return res&#125;;\n\n102. 层序遍历# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        res = []        if not root:            return res                from collections import deque        que = deque([root])        while que:            result = []            size = len(que)            for _ in range(size):                cur = que.popleft()                result.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)            res.append(result)                return res\n/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function(root) &#123;    let results = [], temp = []    temp.push(root)    if(root === null) return results    while(temp.length)&#123;        let size = temp.length        let res = []        for(let i = 0; i &lt; size; i++)&#123;            let node = temp.shift()            res.push(node.val)            node.left &amp;&amp; temp.push(node.left)            node.right &amp;&amp; temp.push(node.right)        &#125;        results.push(res)    &#125;    return results&#125;;\n\n107. 层序遍历II# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:        results = []        if not root:            return results                from collections import deque        que = deque([root])        while que:            size = len(que)            result = []            for _ in range(size):                cur = que.popleft()                result.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)            results.append(result)        return results[::-1]\n\n199. 二叉树的右视图\n注意子节点压入的顺序， 设置flag\n从左到右遍历，最后一个压入val，则是先append左孩子\n从右到左遍历，第一个压入val，则是先append右孩子# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:        results = []        if not root:            return results                from collections import deque        que = deque([root])        while que:            size = len(que)            flag = 0            for _ in range(size):                cur = que.popleft()                if flag == 0:                    results.append(cur.val)                    flag = 1                if cur.right:                   que.append(cur.right)                if cur.left:                    que.append(cur.left)                return results \n\n637. 二叉树的层平均值# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def averageOfLevels(self, root: Optional[TreeNode]) -&gt; List[float]:        results = []        if not root:            return results                from collections import deque        que = deque([root])        while que:            size = len(que)            sum_level = 0            for _ in range(size):                cur = que.popleft()                sum_level += cur.val                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)            ave = float(sum_level / size)            results.append(ave)                return results\n\n429. N叉树的层序遍历\n对给的children定义一开始不懂，可以理解为list中存放了children节点，直接进行遍历append就可以&quot;&quot;&quot;# Definition for a Node.class Node:    def __init__(self, val=None, children=None):        self.val = val        self.children = children&quot;&quot;&quot;class Solution:    def levelOrder(self, root: &#x27;Node&#x27;) -&gt; List[List[int]]:        results = []        if not root:            return results                from collections import deque        que = deque([root])        while que:            result = []            for _ in range(len(que)):                cur = que.popleft()                result.append(cur.val)                for child in cur.children:                    que.append(child)            results.append(result)                return results\n\n116. 填充每个节点的下一个右侧节点\nperfect binary tree，每一层的节点都是满的\n处理好填充节点的逻辑，每层的最后一个指针指向空\n同时popleft的节点别忘记appendleft，同时要append当前节点的孩子节点&quot;&quot;&quot;# Definition for a Node.class Node:    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):        self.val = val        self.left = left        self.right = right        self.next = next&quot;&quot;&quot;class Solution:    def connect(self, root: &#x27;Optional[Node]&#x27;) -&gt; &#x27;Optional[Node]&#x27;:        if not root:            return root                from collections import deque        que = deque([root])        while que:            size = len(que)            for i in range(size):                cur = que.popleft()                if i == size - 1: # last one of this level                    cur.next = None                else:                    nex = que.popleft()                    cur.next = nex                    que.appendleft(nex)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)                return root\n\n117. 填充每个节点的下一个右侧节点II\nnot perfect binary tree\n处理逻辑同116，代码也可以完全复用class Solution:    def connect(self, root: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;:        if not root:            return root                from collections import deque        que = deque([root])        while que:            size = len(que)            for i in range(size):                cur = que.popleft()                if i == size - 1:                    cur.next = None                else:                    nex = que.popleft()                    cur.next = nex                    que.appendleft(nex)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)        return root\n\n104. 二叉树的最大深度\n层序遍历实现# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:        results = []        if not root:            return len(results)                from collections import deque        que = deque([root])        while que:            size = len(que)            result = []            for _ in range(size):                cur = que.popleft()                result.append(cur.val)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)            results.append(result)                return len(results)\n\n111. 二叉树的最小深度\n一开始判断条件写错了，在判断是否有孩子节点的时候，不能轻易写elif语句# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def minDepth(self, root: TreeNode) -&gt; int:        results = []        if not root:            return len(results)        from collections import deque        que = deque([root])        while que:            size = len(que)            result = []            for _ in range(size):                cur = que.popleft()                result.append(cur.val)                if not cur.left and not cur.right:                    results.append(result)                    return len(results)                if cur.left:                    que.append(cur.left)                if cur.right:                    que.append(cur.right)            results.append(result)        return len(results)\n\n226.翻转二叉树\n前序遍历或者层序遍历，对左右子节点进行交换即可\n无需想的太复杂# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def invertTree(self, root: TreeNode) -&gt; TreeNode:        if not root:            return None        root.left, root.right = root.right, root.left        self.invertTree(root.left)        self.invertTree(root.right)            return root\n\n100.相同的树# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:        if p == None and q == None:            return True        if p == None and q != None:            return False        if p != None and q == None:            return False        if p.val != q.val:            return False                left = self.isSameTree(p.left, q.left)        right = self.isSameTree(p.right, q.right)        return left and right\n\n572. 另一棵树的子树599. N叉树的最大深度\n关键是每次都不知道怎么遍历children\n其实就是个list，挨个遍历就行！挨个遍历！\n\n&quot;&quot;&quot;# Definition for a Node.class Node:    def __init__(self, val=None, children=None):        self.val = val        self.children = children&quot;&quot;&quot;class Solution:    def maxDepth(self, root: &#x27;Node&#x27;) -&gt; int:        if not root:            return 0        depth = 0        for i in range(len(root.children)):            depth = max(depth, self.maxDepth(root.children[i]))        return depth + 1\n\n110.平衡二叉树\n关键是一个类里的函数如何调用 不能忘记self\n同时一个函数返回多个值不需要声明输出的类型\n递归函数最开始加了判读，后面可以不需要判断叶子节点是否存在\n递归函数可以不返回true或者false， 只需要把值设置成-1即可# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def isBalanced(self, root: TreeNode) -&gt; bool:        # 遍历每个根节点的左右子树， 如果高度差大于1则返回false， 最后返回and条件        ok, num = self.travel(root)        return ok                def travel(self, root: TreeNode):        if not root:            return True, 0        leftDepth = 0        rightDepth = 0        leftOk, l = self.travel(root.left)        rightOk, r = self.travel(root.right)        leftDepth = max(leftDepth, l)        rightDepth = max(rightDepth, r)        if abs(leftDepth - rightDepth) &gt; 1:            return False, 0        if leftOk and rightOk:            return True, max(leftDepth, rightDepth) + 1        else:            return False, 0\n\n257. 二叉树的所有路径# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def binaryTreePaths(self, root: Optional[TreeNode]) -&gt; List[str]:        # 传递一个跟随路径改变的list， 同时返回一个结果list        # 需要判断什么时候压入栈        # 注意结果的格式 需要做转换        results = []        result = &#x27;&#x27;        self.findPath(root,result,results)        return results    def findPath(self, root, result,results) -&gt; None:        if root.left or root.right:            temp = result            result += str(root.val) + &quot;-&gt;&quot;            if root.left:                self.findPath(root.left, result,results)            if root.right:                self.findPath(root.right, result,results)            result = temp        if not root.right and not root.left:            result += str(root.val)            results.append(result)        \n\n404. 左叶子之和\n这题的思路我还是想的挺清楚的，相比于我第一次写这道题的时候（虽然我真的很困了\n需要通过父节点来判断是不是左叶子，所以我在传参的时候多了一个参数\n第一次是因为根节点，不属于左叶子，所以参数需要直接传入一个false\n本来想通过一个int直接加起来，但发现int没办法完成递归回溯，于是直接改成list进行求和\n相比于我看的参考网站可能这个比较好理解一点 可能因为我真的很困# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -&gt; int:        # 判断左叶子        # 存在父节点且同时是父节点的左孩子        # 上一层传入时添加左叶子的标记如果同时是叶子则加入总和        # 需要参数为root， 父节点bool， sum        # 返回参数None        leafSum = []        self.travel(root, False, leafSum)        return sum(leafSum)        def travel(self, root, father, leafSum) -&gt; None:        if root.left:            self.travel(root.left, True, leafSum)        if root.right:            self.travel(root.right, False, leafSum)        if not root.left and not root.right:            if father == True:                leafSum.append(root.val)\n\n513. 左下角值的和# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def findBottomLeftValue(self, root: Optional[TreeNode]) -&gt; int:        from collections import deque        queue = deque([root])        result = []        while queue:            size = len(queue)            for i in range(size):                cur = queue.popleft()                if i == 0:                    if len(result) &gt; 0:                        result.pop()                    result.append(cur.val)                if cur.left:                    queue.append(cur.left)                if cur.right:                    queue.append(cur.right)        return result[0]\n\n112. 路径总和\n关键是要确定好return条件！路径总和，意味着要遍历到叶子节点，不能随便剪枝\n一定要确定好返回为True的条件，既是叶子节点同时totalSum符合要求class Solution:    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; bool:        if not root:            return False        # 递归+回溯        # 和记录路径的那道题很像        if not root.left and not root.right and targetSum - root.val == 0:            return True        if not root.left and not root.right:            return False        leftOk = False        rightOk = False        if root.left:            leftOk = self.hasPathSum(root.left, targetSum - root.val)        if root.right:            rightOk = self.hasPathSum(root.right, targetSum - root.val)                return leftOk or rightOk\n\n113. 路径总和II\n类似的题目 竟然整整做了一个小时！！！\n首先是python3 的list append 方法，以前可以直接在一个list中append另一个list 如：results.append(result)\n但现在不行， 如果不指明则默认只append后一个list的index0数值的list，需要写清楚 results.append(result[:])\n其次全局变量不需要传参，并且要注意函数的书写# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; List[List[int]]:                def travel(root, targetSum):            if not root.left and not root.right and targetSum == 0:                results.append(result[:])                return            if not root.left and not root.right:                return            if root.left:                result.append(root.left.val)                travel(root.left, targetSum - root.left.val)                result.pop()            if root.right:                                result.append(root.right.val)                travel(root.right, targetSum - root.right.val)                result.pop()        result, results = [], []        if not root:            return results        result.append(root.val)        travel(root, targetSum - root.val)        return results\n\n106. 后序中序数组构建二叉树\n关键是数组需要进行划分\n递归构建左右子树的思想# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode:        # 如果递归进来的后序数组已经为空 则返回        if not postorder:            return None        # 否则，取传进来的后续数组最后一位为这个子树的根节点        root_val = postorder[-1]        root_index = inorder.index(root_val)        root = TreeNode(root_val)                # 利用根节点进行中序数组的划分，需要继续传递进入递归函数        inorder_left = inorder[:root_index]        inorder_right = inorder[root_index+1:]        # 后序数组根据划分出来的中序数组进行划分        postorder_left = postorder[:len(inorder_left)]        postorder_right = postorder[len(inorder_left):len(postorder)-1]        # 依次进行左右子树的递归构建        root.left = self.buildTree(inorder_left, postorder_left)        root.right = self.buildTree(inorder_right, postorder_right)        return root\n\n105. 前序中序数组构建二叉树\n关键注意数组分割的时候# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:        if not preorder:            return None        root_val = preorder[0]        print(root_val)        print(inorder)        root_index = inorder.index(root_val)        root = TreeNode(root_val)        inorder_left = inorder[:root_index]        inorder_right = inorder[root_index+1:]        preorder_left = preorder[1:len(inorder_left)+1]        preorder_right = preorder[1+len(inorder_left):] # ！此处需要注意 不然容易出错        root.left = self.buildTree(preorder_left, inorder_left)        root.right = self.buildTree(preorder_right, inorder_right)        return root\n\n654. 构造最大的二叉树\n仔细阅读题目就可以class Solution:    def constructMaximumBinaryTree(self, nums: List[int]) -&gt; TreeNode:        if not nums:            return None                # find the max        root_val = max(nums)        root_index = nums.index(root_val)        root = TreeNode(root_val)        left_prefix = nums[:root_index]        right_suffix = nums[root_index+1:]        root.left = self.constructMaximumBinaryTree(left_prefix)        root.right = self.constructMaximumBinaryTree(right_suffix)        return root\n\n700. 二叉搜索树中的搜索\n利用二叉搜索树的特性搜索就可以class Solution:    def searchBST(self, root: TreeNode, val: int) -&gt; TreeNode:        if not root:            return None                if root.val == val:            return root        if val &gt; root.val:            return self.searchBST(root.right, val)              if val &lt; root.val:            return self.searchBST(root.left, val)\n\n98. 验证二叉搜索树\n实际上要利用二叉搜索树的特性\n中序遍历 而不是左右子树同时遍历！ 思路记得拐弯# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def isValidBST(self, root: Optional[TreeNode]) -&gt; bool:        cur_max = -float(&quot;INF&quot;)        def validBST(root) -&gt; bool:            nonlocal cur_max            if not root:                return True            left = validBST(root.left)            if cur_max &lt; root.val:                cur_max = root.val            else:                return False                        right = validBST(root.right)            return left and right        return validBST(root)\n\n530. bst的最小绝对差\n依旧中序遍历class Solution:    def getMinimumDifference(self, root: TreeNode) -&gt; int:        cur_min = float(&quot;INF&quot;)        pre_val = -1        def travel(root) -&gt; int:            nonlocal cur_min, pre_val            cur_diff = cur_min            if root.left:                travel(root.left)                        if pre_val == -1:                pre_val = root.val            else:                cur_diff = abs(root.val - pre_val)                pre_val = root.val            if cur_min &gt; cur_diff:                cur_min = cur_diff                        if root.right:                travel(root.right)                    travel(root)        return cur_min\n\n236. 二叉树的最近公共祖先\n后续遍历 巧妙使用返回none来判断\nleft right同时为真 证明最近公共祖先为当前节点class Solution:    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        if not root or root == p or root == q:            return root        left = self.lowestCommonAncestor(root.left, p, q)        right = self.lowestCommonAncestor(root.right, p, q)        if left and right:            return root        elif left:            return left        return right\n\n701. Insert into a Binary Search Treeclass Solution:    def insertIntoBST(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:        if not root:            return TreeNode(val)                    if (val&lt;root.val):            if (root.left):                self.insertIntoBST(root.left, val)                return root            root.left = TreeNode(val)                else:            if(root.right):                self.insertIntoBST(root.right, val)                return root            root.right = TreeNode(val)        return root\n\n450. Delete Node in a BST\n其实最重要是对如何删除和拼接子树的情况考虑清楚\n先写好边界条件，并善于利用whileclass Solution:    def deleteNode(self, root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:        if not root:            return None                if(root.val &lt; key):            root.right = self.deleteNode(root.right, key)        elif(root.val &gt; key):            root.left = self.deleteNode(root.left, key)        else: # root.val == key            if not root.left:                return root.right            if not root.right:                return root.left            new_node = root.right            while new_node.left:                new_node = new_node.left            new_node.left = root.left            root = root.right        return root\n\n124. Binary Tree Maximum Path Sum\n理解路径的关键，使用递归来统计左右子树的路径最大值，进行更新取舍class Solution:    def maxPathSum(self, root: Optional[TreeNode]) -&gt; int:        max_path_length = -float(&quot;inf&quot;)        def dfs(root) -&gt; int:            nonlocal  max_path_length            if not root:                return 0                        left_value = max(0, dfs(root.left))            right_value = max(0, dfs(root.right))            max_path_length = max(max_path_length, root.val + left_value + right_value)            return root.val + max(left_value, right_value)        dfs(root)        return max_path_length\n\n","categories":["刷题笔记"]},{"title":"动态规划","url":"/2022/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"算法本质动态规划（Dynamic Programming),简称dp问题，dp中的每一个状态由上一个状态推导出来\n构建步骤\n确定dp table及其下标的含义\n确定递推公式\ndp数组初始化\n确定遍历顺序\n举例推导dp数组\n\ndebug方法\n打印tb table\n模拟dp table中的状态转移\n\nleetcode相关题目509.斐波那契数题目链接：https://leetcode-cn.com/problems/fibonacci-number/\n\n本题主要用于熟悉dp\n然而我的做法不是基于dp思路推导，选择了今天算法课上老师说的速度较快，内存占用较小的方法（避免了递归，重复计算）class Solution:    def fib(self, n: int) -&gt; int:        num = []        num.append(0)        num.append(1)        for i in range(n):            temp = num[1]            num[1] = num[0] + num[1]            num[0] = temp        return num[0]\n\n70.爬楼梯（climbing stairs）题目链接：https://leetcode-cn.com/problems/climbing-stairs/\n\ndp[i]：爬到第i层楼的方法数\n由于本题中一次只能跨1或2个台阶，所以dp[i] = dp[i-1] + dp[i-2]\ndp[0]的初始化，本题其实无需讨论，但要做到心里有数\n延伸到一步跨不同台阶数到做法class Solution:    def climbStairs(self, n: int) -&gt; int:        dp = [0] * (n+1)        dp[0] = 1        for i in range(n+1):            for j in range(1,3):                if i &gt;= j:                    dp[i] += dp[i-j] # j的范围可改 适应不同的跨过台阶数        return dp[-1]\n\n746.使用最小花费爬楼梯（min cost climbing stairs)题目链接：\n\ndp[i]:爬到第i层的最小花费\ndp的递推公式其实有两种，每种都考虑到了，但对于不同的递推公式，有不同的初始化\ndp[i] = min(dp[i-1],dp[i-2]) + cost[i] 或 dp[i] = min(dp[i-1]+cost[i-i], dp[i-2]+cost[i-2])我的版本：class Solution:    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:        dp = [0] * (len(cost)+1)        if len(cost) == 2:            return min(cost)        for i in range(2, len(cost)+1):            dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])        return dp[-1]\n\n题解版本：\nclass Solution:    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:        dp = [0] * (len(cost))        dp[0] = cost[0]        dp[1] = cost[1]        for i in range(2, len(cost)):            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]        return min(dp[len(cost) - 1], dp[len(cost) - 2])\n\n62.不同路径（unique paths)题目链接：https://leetcode-cn.com/problems/unique-paths/\n\n题目结合高中数学的知识可推导出dp的递推公式\ndp[i][j] = dp[i-1][j] + dp[i][j-1] 因为只能向右走或者向下走\n所以就引出dp数组的初始化问题，我采用了遍历过程中初始化的方法，也可以直接全部初始化为1，修改遍历的起始点我的版本：class Solution:    def uniquePaths(self, m: int, n: int) -&gt; int:        dp = [[0] * n] * m        for i in range(0, m):            for j in range(0, n):                if i != 0 and j != 0:                    dp[i][j] = dp[i-1][j] + dp[i][j-1]                else:                    dp[i][j] = 1        return dp[-1][-1]\n\n63.不同路径II题目链接：https://leetcode-cn.com/problems/unique-paths-ii/submissions/\n\n在62的基础上，多增设了障碍\n思考过程其实与62相似，dp递推公式类似，而遇到障碍的时候，该维度的dp数组就置0，意味着没有别的通路能够通往此处/或者从此处走出\n判断条件要加上，第一格，第一行，第一列的区别我的版本：class Solution:    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:        m = len(obstacleGrid)        n = len(obstacleGrid[0])        dp = [[0]*n]*m # 构造dp table        for i in range(m):            for j in range(n):                if i != 0 and j != 0:                    if obstacleGrid[i][j] != 1:                        dp[i][j] = dp[i-1][j] + dp[i][j-1]                    else:                        dp[i][j] = 0                elif i == 0 and j != 0: # 第一行                    if obstacleGrid[i][j]!= 1:                        dp[i][j] = dp[i][j-1]                    else:                        dp[i][j] = 0                elif j == 0 and i != 0: # 第一列                    if obstacleGrid[i][j]!= 1:                        dp[i][j] = dp[i-1][j]                    else:                        dp[i][j] = 0                else: # 第一格的情况                    if obstacleGrid[i][j]!= 1:                        dp[i][j] = 1                    else:                        dp[i][j] = 0        return dp[-1][-1]\n\n343.整数拆分题目链接：https://leetcode-cn.com/problems/integer-break/submissions/\n\n本题关键在于如何确定递推公式，将数拆分的过程\n严格意义上dp[0]和dp[1]无需赋值\nO(n^2)class Solution:    def integerBreak(self, n: int) -&gt; int:        dp = [0] * (n+1)        dp[2] = 1        for i in range(3, n+1):            for j in range(1, i-1):                # 假设对正整数i拆分出的第一个数为j（此时遍历j）                # 若将i拆封成两部分：i与i-j的乘积，则此时拆分部分乘积为j*(i-j)                # 若继续将（i-j）进行拆分，则此时拆分部分乘积为j*dp[i-j]                dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j])) # 不断迭代最大值        return dp[n]\n\n96.不同的二叉搜索树(unique binary search trees)题目链接：https://leetcode-cn.com/problems/unique-binary-search-trees/submissions/\n\n本题堪称最近最有成就感的一题（大概因为想了很久吧）\n其实线索可以从leetcode上的图中观察得出，下图中已经用颜色分类，首先可以看出树的形状是对称的，接着观察以1为头节点的下半部分，实际上是当n=2时bst的形状\n最后结合二叉搜索树左右节点的特点，则可以知道dp的递推公式，由此也可以想到初始化dp[0]=1(理论上也符合)\n\n我的版本：\nclass Solution:    def numTrees(self, n: int) -&gt; int:        dp = [0] * (n+1)        dp[0] = 1        dp[1] = 1        if n == 1: return 1        for i in range(2, n+1):            for j in range(0, int(i/2)):                dp[i] += 2*dp[j]*dp[i-1-j] # 相对于题解版本，我稍微减小了内层循环的长度，实际上相差不多            if i % 2 != 0: # 加上奇偶判断                dp[i] += dp[int((i-1)/2)]*dp[int((i-1)/2)]        return dp[n]\n\n416.分割等和子集partition equal subset sum题目链接：https://leetcode-cn.com/problems/partition-equal-subset-sum/\n\n实际上这题没有理解得十分透彻\n使用了滚动数组，得注意dp的定义以及遍历顺序class Solution:    def canPartition(self, nums: List[int]) -&gt; bool:        target = sum(nums)        if target % 2 != 0:            return False        target //= 2        dp = [0] * 10001        for i in range(len(nums)):            for j in range(target, nums[i]-1, -1):                dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])        return dp[target] == target\n\ncs336 homeworkhw2.1 checker collectorConsider the following single-player game played on a game board with dimensions 4 × n.  Each square of the game board has a prize given by a positive real number.  You would like to collect prizes to maximize the sum of prizes; however, you have to satisfy the following no two adjacent prizes can be collected.  In other words, if you collect the prize at location (i,j), you cannot collect the prize at (i±1,j) or (i,j±1) (assuming those indices exist).   For example, if you checkered the game board, then one solution could be to take all the black squares, another solution could be to take all the white squares.  You could also take some white squares and some black squares as long as none of are next to each other\nInput：\n\nA 4 × n matrix Q, with prize values qijOutput: The subset S of the entries of qij such that:\nif (i,j) in S, then (i±1,j)∉ S and (i,j±1)∉S.\nΣ(i,j)∈S qij is maximized.\n\ndef print_dp(matrix):    n = len(matrix[0])    # base case? need minimum?    d = [[0 for i in range(8)] for j in range(n + 1)]  # d[][]    val = [[0 for i in range(8)] for j in range(n + 1)]  # val(j,c)    C = [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;, &#x27;0001&#x27;, &#x27;1010&#x27;, &#x27;0101&#x27;, &#x27;1001&#x27;]    idx_c = &#123;&#x27;0000&#x27;: 0, &#x27;1000&#x27;: 1, &#x27;0100&#x27;: 2, &#x27;0010&#x27;: 3, &#x27;0001&#x27;: 4, &#x27;1010&#x27;: 5, &#x27;0101&#x27;: 6, &#x27;1001&#x27;: 7&#125;    # compute all the possible solution/compatible    compatible = &#123;&#x27;0000&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;, &#x27;0001&#x27;, &#x27;1010&#x27;, &#x27;0101&#x27;, &#x27;1001&#x27;],                  &#x27;1000&#x27;: [&#x27;0000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;, &#x27;0001&#x27;, &#x27;0101&#x27;],                  &#x27;0100&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0010&#x27;, &#x27;0001&#x27;, &#x27;1010&#x27;, &#x27;1001&#x27;],                  &#x27;0010&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0100&#x27;, &#x27;0001&#x27;, &#x27;0101&#x27;, &#x27;1001&#x27;],                  &#x27;0001&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;, &#x27;1010&#x27;],                  &#x27;1010&#x27;: [&#x27;0000&#x27;, &#x27;0100&#x27;, &#x27;0001&#x27;, &#x27;0101&#x27;],                  &#x27;0101&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0010&#x27;, &#x27;1010&#x27;],                  &#x27;1001&#x27;: [&#x27;0000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;]&#125;    # compute all the val(j,c)    for j in range(1, n+1):        for index, c in enumerate(C):            if c == &#x27;0000&#x27;:                val[j][index] = 0            if c == &#x27;1000&#x27;:                val[j][index] = matrix[0][j-1]            if c == &#x27;0100&#x27;:                val[j][index] = matrix[1][j-1]            if c == &#x27;0010&#x27;:                val[j][index] = matrix[2][j-1]            if c == &#x27;0001&#x27;:                val[j][index] = matrix[3][j-1]            if c == &#x27;1010&#x27;:                val[j][index] = matrix[0][j-1] + matrix[2][j-1]            if c == &#x27;0101&#x27;:                val[j][index] = matrix[1][j-1] + matrix[3][j-1]            if c == &#x27;1001&#x27;:                val[j][index] = matrix[0][j-1] + matrix[3][j-1]    # dp    for j in range(1, n+1):        for index, c in enumerate(C):            for id, m in enumerate(compatible[c]):                idx = idx_c[m]                d[j][index] = max(d[j][index], val[j][idx] + d[j-1][idx])    # debug    print(d)    # optimal prize    print(max(d[n][0:7]))# Press the green button in the gutter to run the script.if __name__ == &#x27;__main__&#x27;:    # design a 4*n matrix m, we use 4*5 as an example    M = [[1, 10, 1, 10, 1],         [10, 1, 10, 1, 10],         [2, 10, 2, 2, 1],         [3, 2, 10, 3, 2]]    C = [[0, 1, 2, 3, 9, 2, 12, 13, 14, 15],         [2, 5, 6, 1, 9, 2, 1, 3, 9, 12],         [2, 10, 6, 2, 5, 7, 2, 5, 6, 8],         [3, 2, 7, 8, 1, 4, 2, 6, 7, 8],         ]    N = [[1, 2, 3],         [5, 6, 1],         [10, 6, 2],         [20, 7, 8]]    print_dp(M)\n\n5. Longest Palindromic Substring\n注意遍历顺序， 从下至上，从左至右遍历\n判断条件// 动态规划/** * @param &#123;string&#125; s * @return &#123;string&#125; */var longestPalindrome = function(s) &#123;    const strLength = s.length    let maxLenSubstring = &quot;&quot;;    let dp = Array.from(Array(strLength), ()=&gt; Array(strLength).fill(false))        for(let i = strLength - 1; i &gt;= 0 ; i--)&#123;        for(let j = 0; j &lt; strLength; j++)&#123;            if(s[i] === s[j])&#123;                if(j - i &lt;= 1)&#123;                    dp[i][j] = true                    if(j - i + 1 &gt; maxLenSubstring.length)&#123;                    maxLenSubstring = s.slice(i, j+1)                &#125;                &#125;else if (dp[i + 1][j - 1])&#123;                    dp[i][j] = true                    if(j - i + 1 &gt; maxLenSubstring.length)&#123;                    maxLenSubstring = s.slice(i, j+1)                &#125;                &#125;                            &#125;        &#125;    &#125;    return maxLenSubstring&#125;;// 中心扩散法var longestPalindrome = function(s) &#123;    const strLength = s.length    let maxLenSubstring = &quot;&quot;    for(let i = 0; i &lt; strLength; i++)&#123;        result1 = extend(i, i, strLength, maxLenSubstring)        result2 = extend(i, i+1, strLength, maxLenSubstring)        maxLenSubstring = result1.length &gt; result2.length ? result1: result2    &#125;    function extend(left, right, strSize, maxLenString)&#123;        let res = maxLenString        while(left &gt;= 0 &amp;&amp; right &lt; strSize &amp;&amp; s[left] === s[right])&#123;            res = (right - left + 1) &gt; res.length ? s.slice(left, right + 1): res            left --            right ++        &#125;        return res    &#125;    return maxLenSubstring&#125;;\n\n64. Minimum path sumclass Solution:    def minPathSum(self, grid: List[List[int]]) -&gt; int:        m = len(grid)        n = len(grid[0])        dp = [[0] * n for i in range(m)]        for i in range(m):            for j in range(n):                if i == 0 and j == 0:                    dp[i][j] = grid[i][i]                elif i == 0 and j!= 0:                    dp[i][j] = dp[i][j-1] + grid[i][j]                elif i != 0 and j == 0:                    dp[i][j] = dp[i-1][j] + grid[i][j]                else:                    dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j]        return dp[-1][-1]","categories":["刷题笔记"]},{"title":"回溯","url":"/2023/03/27/%E5%9B%9E%E6%BA%AF/","content":"22. Generate parenthesesclass Solution:    def generateParenthesis(self, n: int) -&gt; List[str]:        res = []        def backtrack(s, left, right):            if len(s) == 2*n:                res.append(&quot;&quot;.join(s))                return            if left &lt; n:                s.append(&quot;(&quot;)                backtrack(s, left + 1, right)                s.pop()                        if right &lt; left:                s.append(&quot;)&quot;)                backtrack(s, left, right+1)                s.pop()        backtrack([], 0, 0)        return res\n\n39. Combination Sumclass Solution:    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:        if len(candidates) == 0:            return []                res = []        path = []        def backtracking(candidates, path, start, target):            if target == 0 :                res.append(path[:])                return            if target &lt; 0:                return                        for i in range(start, len(candidates)):                path.append(candidates[i])                backtracking(candidates, path, i, target - candidates[i], )                path.pop()               backtracking(candidates, path, 0, target)        return res\nvar combinationSum = function(candidates, target) &#123;    if(candidates.length === 0) return []    let res = []    let path = []    const backtracking = (candidates, start, target, path) =&gt; &#123;        if(target === 0)&#123;            res.push([...path])            return        &#125;        if(target &lt; 0) return        for(let i = start; i &lt; candidates.length; i++)&#123;            path.push(candidates[i])            backtracking(candidates, i, target - candidates[i], path)            path.pop()        &#125;    &#125;    backtracking(candidates, 0, target, path)    return res    &#125;;\n\n40.Combination Sum 2\nuse startIndex to 剪枝class Solution:    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:        if len(candidates) == 0:            return []                res = []        path = []        candidates.sort()        def backtracking(candidates, path, startIndex, target):            if target == 0:                res.append(path[:])                return            if target &lt; 0:                return                         for i in range(startIndex, len(candidates)):                if i &gt; startIndex and candidates[i] == candidates[i-1]:                    continue                path.append(candidates[i])                backtracking(candidates, path, i + 1, target - candidates[i])                path.pop()                backtracking(candidates, path, 0, target)        return res\n\n46. permutationsclass Solution:    def permute(self, nums: List[int]) -&gt; List[List[int]]:        if len(nums) == 0:            return []        res = []        path = []        def backtracking(candidates, path):            if len(path) == len(nums):                res.append(path[:])                return                         for i in range(len(candidates)):                path.append(candidates[i])                backtracking(candidates[:i] + candidates[i+1:], path)                path.pop()                backtracking(nums, path)        return res\n\n47. permutations 2class Solution:    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:        if len(nums) == 0:            return 0                nums.sort()        res = []        path = []        def backtracking(candidates, path):            if len(path) == len(nums):                res.append(path[:])                return                        for i in range(len(candidates)):                if i &gt; 0 and candidates[i] == candidates[i-1]:                    continue                path.append(candidates[i])                backtracking(candidates[:i] + candidates[i+1:], path)                path.pop()        backtracking(nums, path)        return res\n\n77. Combinationsclass Solution:    def combine(self, n: int, k: int) -&gt; List[List[int]]:        res = []        def backtrack(path, start):            if len(path) == k:                res.append(path[:])                return                        for i in range(start, n+1):                path.append(i)                backtrack(path, i+1)                path.pop()                backtrack([], 1)        return res\n\n78. Subsetsclass Solution:    def subsets(self, nums: List[int]) -&gt; List[List[int]]:        res = []        def backtrack(path, start):                        res.append(path[:])            if len(path) == len(nums):                return            for i in range(start, len(nums)):                path.append(nums[i])                backtrack(path, i+1)                path.pop()                    backtrack([], 0)        return res\n\n79.\n深度搜索+回溯class Solution:    def exist(self, board: List[List[str]], word: str) -&gt; bool:        row = len(board)        column = len(board[0])        direction = [[-1, 0], [0, -1], [0, 1], [1, 0]]        mark = [[0] * column for i in range(row)]                def backtrack(mark, i, j, word):            if len(word) == 0:                return True                        for di in direction:                cur_i = i + di[0]                cur_j = j + di[1]                if cur_i &gt;= 0 and cur_i &lt; row and cur_j &gt;= 0 and cur_j &lt; column and board[cur_i][cur_j] == word[0]:                    if mark[cur_i][cur_j] == 1:                        continue                    mark[cur_i][cur_j] = 1                    if backtrack(mark, cur_i, cur_j, word[1:]) == True:                        return True                    else:                        mark[cur_i][cur_j] = 0        for i in range(row):            for j in range(column):                if board[i][j] == word[0]:                    mark[i][j] = 1                    if backtrack(mark, i, j, word[1:]) == True:                        return True                    else:                        mark[i][j] = 0                return False\n\n","categories":["刷题笔记"]},{"title":"栈和队列","url":"/2022/12/19/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","content":"232.implement queue using stacksvar MyQueue = function() &#123;    this.stackIn = []    this.stackOut = []&#125;;/**  * @param &#123;number&#125; x * @return &#123;void&#125; */MyQueue.prototype.push = function(x) &#123;    this.stackIn.push(x)&#125;;/** * @return &#123;number&#125; */MyQueue.prototype.pop = function() &#123;    const size = this.stackOut.length    if(size)&#123;        return this.stackOut.pop()    &#125;    while(this.stackIn.length)&#123;        this.stackOut.push(this.stackIn.pop())    &#125;    return this.stackOut.pop()&#125;;/** * @return &#123;number&#125; */MyQueue.prototype.peek = function() &#123;    const p = this.pop()    this.stackOut.push(p)    return p&#125;;/** * @return &#123;boolean&#125; */MyQueue.prototype.empty = function() &#123;    return !this.stackIn.length &amp;&amp; !this.stackOut.length&#125;;/** * Your MyQueue object will be instantiated and called as such: * var obj = new MyQueue() * obj.push(x) * var param_2 = obj.pop() * var param_3 = obj.peek() * var param_4 = obj.empty() */\n\n225. implement stack using queuesvar MyStack = function() &#123;    this.q1 = []    this.q2 = []&#125;;/**  * @param &#123;number&#125; x * @return &#123;void&#125; */MyStack.prototype.push = function(x) &#123;    this.q1.push(x)&#125;;/** * @return &#123;number&#125; */MyStack.prototype.pop = function() &#123;    if(!this.q1.length)&#123;        [this.q1, this.q2] = [this.q2, this.q1];    &#125;    while(this.q1.length &gt; 1)&#123;        this.q2.push(this.q1.shift())    &#125;    return this.q1.shift()&#125;;/** * @return &#123;number&#125; */MyStack.prototype.top = function() &#123;    const x = this.pop()    this.q1.push(x)    return x&#125;;/** * @return &#123;boolean&#125; */MyStack.prototype.empty = function() &#123;    return !this.q1.length&amp;&amp; !this.q2.length&#125;;/** * Your MyStack object will be instantiated and called as such: * var obj = new MyStack() * obj.push(x) * var param_2 = obj.pop() * var param_3 = obj.top() * var param_4 = obj.empty() */\n\n20. valid parentheses/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123;    const res = []    const m = &#123;&quot;&#123;&quot;:&quot;&#125;&quot;, &quot;(&quot;:&quot;)&quot;, &quot;[&quot;:&quot;]&quot;&#125;    for(const i of s)&#123;        if(i in m)&#123;            res.push(i)            continue        &#125;        if(m[res.pop()]!== i) return false;    &#125;    return !res.length&#125;;","categories":["刷题笔记"]},{"title":"数组和字符串","url":"/2022/02/22/%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"151.Reverse Words in a Stringhttps://leetcode-cn.com/problems/reverse-words-in-a-string/\nclass Solution:    def reverseWords(self, s: str) -&gt; str:        l = s.split()        n = len(l)        left, right = 0, n-1        while left &lt; right:            temp = l[left]            l[left] = l[right]            l[right] = temp            left += 1            right -= 1        return &quot; &quot;.join(l)\n\n35. Search Insert Positionhttps://leetcode-cn.com/problems/search-insert-position/需要好好了解二分查找的原理和结果，别想的太复杂\nclass Solution:    def searchInsert(self, nums: List[int], target: int) -&gt; int:        left, right = 0, len(nums) - 1        while left &lt;= right:            mid = (left+right) // 2            if nums[mid] == target:                return mid            elif nums[mid] &gt; target:                right = mid - 1            else:                left = mid + 1                return left\n\n704. Binary Searchhttps://leetcode-cn.com/problems/binary-search/\nclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        l, r = 0, len(nums)-1        while l &lt;= r:            m = (l + r) // 2            if nums[m] == target:                return m            elif nums[m] &gt; target:                r = m - 1            else:                l = m + 1        return -1\n/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var search = function(nums, target) &#123;    let mid, left = 0, right = nums.length - 1;    while(left &lt;= right)&#123;        mid = left + ((right - left) &gt;&gt; 1);        if(nums[mid] &lt; target)&#123;            left = mid + 1;        &#125;else if(nums[mid] &gt; target)&#123;            right = mid - 1;        &#125;else&#123;            return mid;        &#125;    &#125;    return -1;&#125;;\n\n35. search insert positionhttps://leetcode.cn/problems/search-insert-position/ \n/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var searchInsert = function(nums, target) &#123;    let mid, left = 0, right = nums.length - 1;    while(left &lt;= right)&#123;        mid = left + ((right - left) &gt;&gt; 1)        if(nums[mid] &gt; target)&#123;            right = mid - 1;        &#125;else if(nums[mid] &lt; target)&#123;            left = mid + 1;        &#125;else&#123;            return mid;        &#125;    &#125;    return right + 1;&#125;;\n\n\n34. Find first and last position of element in sorted arrayhttps://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/\n/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var searchRange = function(nums, target) &#123;    const findLeftBound = (nums, target) =&gt; &#123;        let mid, left = 0, right = nums.length - 1;        let leftB = -3;        while(left &lt;= right)&#123;            mid = left + ((right - left) &gt;&gt; 1);            if (nums[mid] &lt; target)&#123;                left = mid + 1;            &#125;else&#123;                right = mid - 1;                leftB = right;            &#125;        &#125;        return leftB;    &#125;;    const findRightBound = (nums, target) =&gt; &#123;        let mid, left = 0, right = nums.length - 1;        let rightB = -3;        while(left &lt;= right)&#123;            mid = left + ((right - left) &gt;&gt; 1);            if(nums[mid] &gt; target)&#123;                right = mid -1;            &#125;else&#123;                left = mid + 1;                rightB = left;            &#125;        &#125;        return rightB;    &#125;;    let leftBound = findLeftBound(nums, target);    let rightBound = findRightBound(nums,target);    if(leftBound === -3 || rightBound === -3) return [-1, -1];    if (rightBound - leftBound &gt; 1) return[leftBound + 1, rightBound - 1];    return [-1, -1];&#125;;\n\n69. sqrt xhttps://leetcode.cn/problems/sqrtx/\n/** * @param &#123;number&#125; x * @return &#123;number&#125; */var mySqrt = function(x) &#123;    if(x === 0 || x === 1) return x;    let left = 0;    let right = x &gt;&gt; 1;    while(left &lt;= right)&#123;        mid = left + ((right - left) &gt;&gt; 1);        if(mid * mid &gt; x)&#123;            right = mid - 1;        &#125;else if(mid * mid &lt; x)&#123;            left = mid + 1;        &#125;else&#123;            return mid;        &#125;    &#125;    return right;&#125;;\nclass Solution:    def mySqrt(self, x: int) -&gt; int:        left, right = 0, x        res = -1        while left &lt;= right:            mid = (left + right) // 2            s = mid * mid            if s &lt;= x:                res = mid                left = mid + 1            else:                right = mid - 1        return res\n\n209. min size subarray sumhttps://leetcode.cn/problems/minimum-size-subarray-sum/\nsliding window\n/** * @param &#123;number&#125; target * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var minSubArrayLen = function(target, nums) &#123;    let start = 0, end = 0;    let sum = 0;    let len = nums.length;    let ans = Infinity;    while(end &lt; len)&#123;        sum += nums[end];        while(sum &gt;= target)&#123;            ans = Math.min(ans, end - start + 1);            sum -= nums[start];            start ++;        &#125;        end++;    &#125;    return ans === Infinity ? 0 : ans;&#125;;\n\n904. fruits baskets/** * @param &#123;number[]&#125; fruits * @return &#123;number&#125; */var totalFruit = function(fruits) &#123;    let start = 0, end = 0;    let ans = -Infinity;    let len = fruits.length    let numOfFruit = &#123;&#125;;    while(end &lt; len)&#123;        if(fruits[end] in numOfFruit)&#123;            numOfFruit[fruits[end]] ++;        &#125;else&#123;            numOfFruit[fruits[end]] = 1;        &#125;        while(Object.keys(numOfFruit).length &gt; 2 &amp;&amp; numOfFruit[fruits[start]] &gt; 0)&#123;            if(numOfFruit[fruits[start]] === 1)&#123;                delete numOfFruit[fruits[start]];            &#125;else&#123;                numOfFruit[fruits[start]] -- ;            &#125;            start++;        &#125;        ans = Math.max(ans, end - start + 1);        end++;    &#125;    return ans;&#125;;\n242. valid anagramclass Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        from collections import Counter        a = Counter(s)        b = Counter(t)        return a == b\n\n/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isAnagram = function(s, t) &#123;    if (s.length !== t.length) return false;    const res = new Array(26).fill(0);    const base = &#x27;a&#x27;.charCodeAt();    for(const i of s)&#123;        res[i.charCodeAt()-base]++;    &#125;    for(const i of t)&#123;        if(!res[i.charCodeAt()-base]) return false;        res[i.charCodeAt()-base]--;    &#125;    return true;&#125;;\n\n1002. find common charactersclass Solution:    def commonChars(self, words: List[str]) -&gt; List[str]:        from collections import Counter        temp = Counter(words[0])        l = []        for i in range(1, len(words)):            temp = temp &amp; Counter(words[i])                for j in temp:            num = temp[j]            while(num):                l.append(j)                num -= 1        return l\n/** * @param &#123;string[]&#125; words * @return &#123;string[]&#125; */var commonChars = function(words) &#123;    let res = [];    let firstMap = new Array(26).fill(0);    const b = &quot;a&quot;.charCodeAt();    for(const i of words[0])&#123;        firstMap[i.charCodeAt() - b] ++;    &#125;    let newMap = new Array(26).fill(0);    for(let j = 1; j &lt; words.length; j++)&#123;        for(const m of words[j])&#123;            newMap[m.charCodeAt()-b]++;        &#125;        for(let i = 0; i &lt; 26; i++)&#123;            firstMap[i] = Math.min(firstMap[i], newMap[i])        &#125;        newMap.fill(0);    &#125;    for(let i = 0; i &lt; 26; i++)&#123;        while(firstMap[i] &gt; 0)&#123;            res.push(String.fromCharCode(i+b))            firstMap[i]--        &#125;    &#125;    return res&#125;;\n\n349. intersection of two arraysclass Solution:    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        from collections import Counter        a = Counter(nums1)        b = Counter(nums2)        temp = a &amp; b        res = []        for i in temp:            res.append(i)        return res\n/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123;    if(nums1.length &lt; nums2.length)&#123;        const temp = nums1        nums1 = nums2        nums2 = temp    &#125;    const firstSet = new Set(nums1)    const restSet = new Set()    for(i = 0; i &lt; nums2.length; i++)&#123;        if(firstSet.has(nums2[i]))&#123;            restSet.add(nums2[i])        &#125;    &#125;    return Array.from(restSet)&#125;;\n\n1. two sum/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123;    let map = new Map()    for(let i = 0; i &lt; nums.length; i++)&#123;        let targetNum = target - nums[i]        if(map.has(targetNum))&#123;            return [i, map.get(targetNum)]        &#125;else&#123;            map.set(nums[i], i)        &#125;    &#125;    return []&#125;;\n\nclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        d = &#123;&#125;        for i in range(len(nums)):            targetNum = target - nums[i]            if(targetNum in d):                return [i, d[targetNum]]            else:                d[nums[i]] = i        return []\n454. 4sum II/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @param &#123;number[]&#125; nums3 * @param &#123;number[]&#125; nums4 * @return &#123;number&#125; */var fourSumCount = function(nums1, nums2, nums3, nums4) &#123;    let map = new Map()    let count = 0    for(const i of nums1)&#123;        for(const j of nums2)&#123;            map.set(i+j, (map.get(i+j) || 0) + 1)        &#125;    &#125;    for(const n3 of nums3)&#123;        for(const n4 of nums4)&#123;            count += (map.get(-n3-n4) || 0 )        &#125;    &#125;    return count;&#125;;\n\n344. reverse string/** * @param &#123;character[]&#125; s * @return &#123;void&#125; Do not return anything, modify s in-place instead. */var reverseString = function(s) &#123;    let left = -1, right = s.length    while(++left &lt; --right)&#123;        [s[left], s[right]] = [s[right], s[left]]    &#125;&#125;;\n\n541. reverse string II/** * @param &#123;string&#125; s * @param &#123;number&#125; k * @return &#123;string&#125; */var reverseStr = function(s, k) &#123;    let m = s.split(&quot;&quot;)    for(let i = 0; i &lt; s.length; i = i + 2 * k)&#123;        reverse(m, i, i+k-1)    &#125;    return m.join(&quot;&quot;)&#125;;var reverse = function(x,left, right)&#123;    while(left &lt; right)&#123;        [x[left], x[right]] = [x[right], x[left]]        left ++;        right --;    &#125;&#125;\n\n252. Meeting rooms\n关键是要了解每种语言排序的方法\n\n\n  \n\n\n/** * @param &#123;number[][]&#125; intervals * @return &#123;boolean&#125; */var canAttendMeetings = function(intervals) &#123;    // sort    intervals.sort((a,b)=&gt;&#123;        return a[0] - b[0]    &#125;)    for(let i = 1; i&lt; intervals.length; i++)&#123;        if(intervals[i][0] &lt; intervals[i - 1][1]) return false    &#125;    return true&#125;;\n\n66. Plus one\n思路整理清楚，carry初始化为1，从后往前遍历即可\n妙用javascript的列表unshift操作/** * @param &#123;number[]&#125; digits * @return &#123;number[]&#125; */var plusOne = function(digits) &#123;    let carry = 1;    for(let i = digits.length - 1; i &gt;=0 ; i--)&#123;        let s = digits[i] + carry        carry = Math.floor(s/ 10) //求进位        let num = s % 10 //求余        digits[i] = num    &#125;    if(carry &gt; 0)&#123; // 如果最后一位有进位        digits.unshift(carry)    &#125;    return digits&#125;;\nclass Solution:    def plusOne(self, digits: List[int]) -&gt; List[int]:        carry = 0        for i in range(len(digits)-1, -1, -1):            if i == len(digits)-1:                s = digits[i] + 1            else:                s = digits[i] + carry            carry = s // 10            n = s % 10            digits[i] = n            if carry == 0:                return digits        if carry == 0:            return digits        return [carry]+digits[:]\n88. merge sorted array\n三指针尾插法，因为原数组有充足的空间，从尾部开始class Solution:    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums1 in-place instead.        &quot;&quot;&quot;        len1, len2 = m-1, n-1        tail = m+n-1        while len1 &gt;= 0 or len2 &gt;= 0:            if(len1 == -1):                cur = nums2[len2]                len2 -=1            elif len2 == -1:                cur = nums1[len1]                len1 -= 1            elif nums1[len1] &gt;= nums2[len2]:                cur = nums1[len1]                len1 -= 1            else:                cur = nums2[len2]                len2 -= 1            nums1[tail] = cur            tail -= 1\n/** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) &#123;    let len1 = m - 1, len2 = n - 1;    let tail = m + n - 1;    var cur    while(len1 &gt;= 0 || len2 &gt;= 0)&#123;        if(len1 === -1)&#123;// 第一个数组已被比较完            cur = nums2[len2--] // 数组二中的元素直接赋值给指针        &#125;else if(len2 === -1)&#123;            cur = nums1[len1--]        &#125;else if(nums1[len1] &gt; nums2[len2])&#123;            cur = nums1[len1--] // 把较大的元素赋值给指针        &#125;else&#123;            cur = nums2[len2--]        &#125;        nums1[tail--] = cur // 指针的数覆盖原数组    &#125;&#125;;\n\n3. longest substring without repeating characters\n关键思想 滑动窗口 + map，存储已有字符及其index\n别忘记比较当前slowIndex和需要缩小的index大小， corner case‘abba’会出错/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123;    let characterMap = new Map();    let longestLength = 0;        // corner case    if(s.length === 0) return longestLength;    let slowIndex = 0, fastIndex = 0;    while(slowIndex &lt; s.length &amp;&amp; fastIndex &lt; s.length)&#123;        // check the fastIndex character in the map        let character = s[fastIndex];        // if no, save it and index, calculate the length and refersh the longest        // if yes, showIndex move to the savedIndex, and refresh the key, calculate or not?        if(!characterMap.has(character))&#123;            characterMap.set(character, fastIndex);            let currentLength = fastIndex - slowIndex + 1;                if(currentLength &gt; longestLength) longestLength = currentLength;            fastIndex ++;            continue;        &#125;else&#123;            // remember to compare the index, &#x27;abba&#x27; situation            slowIndex = characterMap.get(character) &gt;= slowIndex ? characterMap.get(character) + 1 : slowIndex            characterMap.set(character, fastIndex);            let currentLength = fastIndex - slowIndex + 1;                 if(currentLength &gt; longestLength) longestLength = currentLength;            fastIndex ++;            continue;        &#125;    &#125;    return longestLength&#125;;\n\n6. zigzag conversion\n可以根据变换的周期进行判断，寻找其中的规律。边界条件先处理\n本来也考虑过二维数组进行顺序存储，但空间复杂度会更大。// version 1// 这个版本是我ac的一个版本，其实思想就是直接构造，但代码不够简洁，可以优化的地方很多。var convert = function(s, numRows) &#123;    // clarify the number of one set    if(numRows === 1) return s    let stepLength = numRows + numRows - 2    let stringLen = s.length    let res = &quot;&quot;;    // i points to the very first element of every set    // check the array bound    for(let i = 0; i &lt; numRows; i ++)&#123;        let step1;        let step2;         let m = i        step1 = stepLength - i * 2;        step2 = stepLength - step1;        while(m &lt; stringLen)&#123;            if(!(step1&amp;&amp;step2))&#123;                let step = step1 !== 0? step1 : step2;                res = res.concat(s[m])                m += step             &#125; else&#123;                if(s[m+step1] !== undefined)&#123;                    res = res.concat(s[m], s[m+step1])                &#125;else &#123;                    res =res.concat(s[m])                &#125;                m = m + stepLength            &#125;         &#125;    &#125;    return res&#125;;// version 2// 直接构造的简化版本var convert = function(s, numRows) &#123;    const strLength = s.length    if(numRows === 1 || numRows &gt;= strLength) return s    const period = numRows * 2 - 2    let res = []    for(let i = 0; i &lt; numRows; i++)&#123;        for(let j = 0; j &lt; strLength - i; j += period)&#123;            res.push(s[i + j])            if(i &gt; 0 &amp;&amp; i &lt; numRows - 1 &amp;&amp; j + period - i &lt; strLength)&#123;                 // 不是最上面也不是最下面的行，同时判断一个周期里的最后一个字符是否存在                res.push(s[j + period - i])            &#125;        &#125;    &#125;    return res.join(&#x27;&#x27;)&#125;;\n\n7. reverse integer\n~是一个二进制的非操作，对于以下代码来说，执行两次非操作是更快的Math.floor()操作，并且对negative没有影响\nvar reverse = function(x) &#123;    let rev = 0    while(x !== 0)&#123;        digit = x % 10        x = ~~(x / 10) // 直接去掉了小数点右边的结果并且不影响正负        rev = rev * 10 + digit        if(rev &lt; -Math.pow(2, 31) || rev &gt; Math.pow(2,31)-1) return 0 //防止溢出进行判断    &#125;    return rev&#125;;\n\n8. String to integer(atoi)\n状态转换机/** * @param &#123;string&#125; s * @return &#123;number&#125; */// 这个写法基本思想是一样的，但没有利用状态转换机，比较臃肿的解题方式var myAtoi = function(s) &#123;    if(s.length === 0) return 0    let res = 0        for(let i = 0; i &lt; s.length; i++)&#123;        if(s[i] === &#x27; &#x27;)&#123;            continue        &#125;        if(s[i] === &#x27;+&#x27; || s[i] ===&#x27;-&#x27;)&#123;            //check the following digit            return checkFollowingDigit(s[i], i+1, res)        &#125;        if(!(s[i] &gt;= &#x27;0&#x27;&amp;&amp; s[i] &lt;= &#x27;9&#x27;))&#123;            return 0        &#125;        if(s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;)&#123;            //check the following digit            return checkFollowingDigit(&#x27;+&#x27;,i, res)        &#125;    &#125;    function checkFollowingDigit(flag, startIndex, res)&#123;        while(s[startIndex] &gt;= &#x27;0&#x27; &amp;&amp; s[startIndex] &lt;= &#x27;9&#x27; &amp;&amp; startIndex &lt; s.length)&#123;                        res = res * 10 + Number(s[startIndex])            console.log(res)            startIndex ++        &#125;        if(flag === &#x27;-&#x27;)&#123;            res = -res        &#125;        if(res &lt; -Math.pow(2, 31))&#123;            return -Math.pow(2, 31)        &#125;else if(res &gt; Math.pow(2, 31) - 1)&#123;            return Math.pow(2, 31) - 1        &#125;        console.log(res)        return res    &#125;    return 0&#125;;\n9.Palindrome Numbervar isPalindrome = function(x) &#123;    if(x &lt; 0) return false    let strX = String(x)    let left = 0, right = strX.length - 1    while(left &lt;= right)&#123;        if(strX[left] !== strX[right])&#123;            return false        &#125;        left ++        right --    &#125;    return true&#125;;\n11. Container with watervar maxArea = function(height) &#123; let left = 0, right = height.length - 1 let ans = 0 while(left &lt; right)&#123;     let shortestBorder = Math.min(height[left], height[right])     let container = shortestBorder * (right - left)     ans = Math.max(ans, container)     // the logic that move the border     if(height[left] &lt;= height[right])&#123;         left ++     &#125;else&#123;         right --     &#125; &#125; return ans&#125;;\n\n12. Integer to Roman// 更优解是这个， 做一个二维数组来存储key-value。主要是用object的iteration比较麻烦// 时间复杂度是O（1），由于这个dict的长度是固定的，在本题的数据范围中，循环次数有上限。var intToRoman = function(num) &#123;    const romanNumberDict = [[1000, &#x27;M&#x27;], [900, &#x27;CM&#x27;], [500,&#x27;D&#x27;], [400, &#x27;CD&#x27;], [100,&#x27;C&#x27;], [90,&#x27;XC&#x27;], [50, &#x27;L&#x27;], [40, &#x27;XL&#x27;],[10,&#x27;X&#x27;], [9,&#x27;IX&#x27;], [5, &#x27;V&#x27;], [4,&#x27;IV&#x27;],[ 1, &#x27;I&#x27;]]            let romanString = []    for(const [value, roman] of romanNumberDict)&#123;        while(num &gt;= value)&#123;            romanString.push(roman)            num -= value        &#125;    &#125;    return romanString.join(&#x27;&#x27;)&#125;;// 这种方法有点hard coded的感觉了var intToRoman = function(num) &#123;    const romanNumberDict = &#123;        1000: &#x27;M&#x27;, 900: &#x27;CM&#x27;, 500:&#x27;D&#x27;, 400: &#x27;CD&#x27;, 100:&#x27;C&#x27;, 90:&#x27;XC&#x27;, 50: &#x27;L&#x27;, 40: &#x27;XL&#x27;,        10:&#x27;X&#x27;, 9:&#x27;IX&#x27;, 5: &#x27;V&#x27;, 4:&#x27;IV&#x27;, 1: &#x27;I&#x27;    &#125;    let romanString = []    while(num &gt; 0)&#123;        if(num &gt;= 1000)&#123;            romanString.push(romanNumberDict[1000])            num -= 1000            continue        &#125;else if(num &gt;= 900)&#123;            romanString.push(romanNumberDict[900])            num -= 900            continue        &#125;else if(num &gt;= 500)&#123;            romanString.push(romanNumberDict[500])            num -= 500            continue        &#125;else if(num &gt;= 400)&#123;            romanString.push(romanNumberDict[400])            num -= 400            continue        &#125;else if(num &gt;= 100)&#123;            romanString.push(romanNumberDict[100])            num -= 100            continue        &#125;else if(num &gt;= 90)&#123;            romanString.push(romanNumberDict[90])            num -= 90            continue        &#125;else if(num &gt;= 50)&#123;            romanString.push(romanNumberDict[50])            num -= 50            continue        &#125;else if(num &gt;= 40)&#123;            romanString.push(romanNumberDict[40])            num -= 40            continue        &#125;else if(num &gt;= 10)&#123;            romanString.push(romanNumberDict[10])            num -= 10            continue        &#125;else if(num &gt;= 9)&#123;            romanString.push(romanNumberDict[9])            num -= 9            continue        &#125;else if(num &gt;= 5)&#123;            romanString.push(romanNumberDict[5])            num -= 5            continue        &#125;else if(num &gt;= 4)&#123;            romanString.push(romanNumberDict[4])            num -= 4            continue        &#125;else if(num &gt;= 1)&#123;            romanString.push(romanNumberDict[1])            num -= 1            continue        &#125;    &#125;    return romanString.join(&#x27;&#x27;)&#125;;\n\n13. Roman to integer//使用倒过来的顺序进行遍历/** * @param &#123;string&#125; s * @return &#123;number&#125; */var romanToInt = function(s) &#123;    const romanIntDict = &#123;        &#x27;I&#x27;: 1, &#x27;V&#x27;:5, &#x27;X&#x27;:10, &#x27;L&#x27;:50, &#x27;C&#x27;:100, &#x27;D&#x27;: 500, &#x27;M&#x27;:1000,    &#125;    let ans = 0, previousNum = 0;    for(let i = s.length-1; i &gt;= 0; i --)&#123;        let roman = romanIntDict[s[i]]        if(roman &lt; previousNum)&#123;            roman = -1 * roman        &#125;        previousNum = Math.abs(roman)        ans += roman    &#125;    return ans&#125;;\n\n14.Longest Common Prefixvar longestCommonPrefix = function(strs) &#123;    strs.sort((a,b)=&gt;&#123;return a.length - b.length&#125;)    let longestPrefix = strs[0].split(&#x27;&#x27;)    for(let i = 1; i &lt; strs.length; i++)&#123;        for(let j = 0; j &lt; strs[i].length; j++)&#123;            if(strs[i][j] === longestPrefix[j]) continue            longestPrefix = longestPrefix.slice(0, j)            break        &#125;    &#125;    return longestPrefix.join(&#x27;&#x27;)&#125;;\n\n15. Three sumvar threeSum = function(nums) &#123;    nums.sort((a, b) =&gt;  a - b)    let res = []    let len = nums.length    for(let i = 0; i &lt; len; i++)&#123;        let iValue = nums[i]        if(iValue &gt; 0) return res        if(iValue == nums[i - 1]) continue        let left = i + 1, right = len - 1        while(left &lt; right)&#123;            let lValue = nums[left], rValue = nums[right]            let sumOfThree = iValue + lValue + rValue            if(sumOfThree &gt; 0)&#123;                 right --            &#125;else if (sumOfThree &lt; 0)&#123;                left ++            &#125;else&#123;                res.push([iValue, lValue, rValue])                while(left &lt; right &amp;&amp; nums[left] === nums[left+1]) left ++                while(left &lt; right &amp;&amp; nums[right] === nums[right - 1]) right --                left ++                right --            &#125;        &#125;    &#125;    return res&#125;;\n\n16.3Sum Closetvar threeSumClosest = function(nums, target) &#123;    nums.sort((a, b) =&gt; a - b)    console.log(nums)    let closetTarget = Infinity    let len = nums.length    for(let i = 0; i &lt; len; i++)&#123;        let left = i + 1, right = len - 1        let iValue = nums[i]        if(closetTarget === target) return target        if(iValue === nums[i-1]) continue        while(left &lt; right)&#123;            let lValue = nums[left], rValue = nums[right]            let sumOfThree = iValue + lValue + rValue            closetTarget = Math.abs(sumOfThree - target) &lt; Math.abs(closetTarget-target)? sumOfThree : closetTarget            if(sumOfThree &lt; target)&#123;                left ++            &#125;else if(sumOfThree &gt; target)&#123;                right --            &#125;else&#123;                return target            &#125;        &#125;    &#125;    return closetTarget&#125;;\n\n17.Letter Combinations of a Phone Numbervar letterCombinations = function(digits) &#123;    if(digits.length === 0) return []    let res = []    const numberLetterDict = &#123;        &#x27;2&#x27;: &#x27;abc&#x27;, &#x27;3&#x27;:&#x27;def&#x27;, &#x27;4&#x27;:&#x27;ghi&#x27;, &#x27;5&#x27;:&#x27;jkl&#x27;, &#x27;6&#x27;:&#x27;mno&#x27;, &#x27;7&#x27;:&#x27;pqrs&#x27;, &#x27;8&#x27;:&#x27;tuv&#x27;, &#x27;9&#x27;:&#x27;wxyz&#x27;    &#125;    const dfs = (curStr, i) =&gt; &#123;        if(i &gt;= digits.length)&#123;            res.push(curStr)            return        &#125;        let letters = numberLetterDict[digits[i]]        for(const letter of letters)&#123;            dfs(curStr+letter, i+1)        &#125;    &#125;    dfs(&#x27;&#x27;,0)    return res&#125;;\n\n28. find the index of the first occurrence in a stringclass Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        lena = len(haystack)        lenb = len(needle)        for i in range(0, lena - lenb + 1):            starta = i            startb = 0            while startb &lt; lenb and haystack[starta] == needle[startb]:                starta += 1                startb += 1            if startb &gt;= lenb:                return i                return -1\n\n31.Next Permutationclass Solution:    def nextPermutation(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        i = len(nums) - 2        while i &gt;= 0 and nums[i] &gt;= nums[i+1]:            i -= 1        if i &gt;= 0:            j = len(nums) - 1            while j &gt;= 0 and nums[j] &lt;= nums[i]:                j -= 1            nums[i], nums[j] = nums[j], nums[i]                left, right = i+1, len(nums) - 1        while left &lt;= right:            nums[left], nums[right] = nums[right], nums[left]            left += 1            right -=1\n\n36. valid sudokuclass Solution:    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:        rows = [[0] * 9 for _ in range(9)]        columns = [[0] * 9 for _ in range(9)]        subboxes = [[[0] * 9 for _ in range(3)] for _ in range(3)]        for i in range(0, 9):            for j in range(0, 9):                c = board[i][j]                if c != &#x27;.&#x27;:                    num = int(c) - 1                    rows[i][num] += 1                    columns[j][num] += 1                    subboxes[int(i/3)][int(j/3)][num] += 1                    if rows[i][num] &gt; 1 or columns[j][num] &gt; 1 or subboxes[int(i/3)][int(j/3)][num] &gt; 1:                        return False                return True\n\n38. count and sayclass Solution:    def countAndSay(self, n: int) -&gt; str:        if n == 1:            return &quot;1&quot;        if n == 2:            return &quot;11&quot;        old = self.countAndSay(n - 1)        size = len(old)        current_time = 1        ans = &quot;&quot;        for i in range(size - 1):            if old[i] == old[i + 1]:                current_time += 1            else:                ans += str(current_time) + old[i]                current_time = 1        ans += str(current_time) + old[-1]                return ans        # if n == 1:        #     return &quot;1&quot;        # # res = [&quot;1&quot;]        # ans = &quot;&quot;        # def traverse(base, time):        #     nonlocal ans        #     current_time = 0        #     number = base[0]        #     res = []        #     for i in range(0, len(base)):        #         if base[i] == number:        #             current_time += 1        #         else:        #             res.append(str(current_time))        #             res.append(number)        #             number = base[i]        #             current_time = 1        #     res.append(str(current_time))        #     res.append(number)        #     if time &lt; n:        #         traverse(res, time + 1)        #     else:        #         # return &quot;&quot;.join(res)        #         ans = &quot;&quot;.join(res)        # traverse([&quot;1&quot;], 2)        # return ans\n\n43. Multiply stringsclass Solution:    def multiply(self, num1: str, num2: str) -&gt; str:        if num1 == &quot;0&quot; or num2 ==&quot;0&quot;:            return &quot;0&quot;                if len(num1) &lt;= len(num2):            num_short = num1            num_long = num2        else:            num_short = num2            num_long = num1                num = 0        for i in range(len(num_short) - 1,  -1, -1):            current_num = 0            carry = 0            for j in range(len(num_long)-1, -1, -1):                multiple = int(num_short[i]) * int(num_long[j])                current_num += (carry + multiple % 10) * (10 ** (len(num_long) - 1 - j))                carry = multiple // 10                            if carry &gt; 0:                current_num += carry * (10 ** (len(num_long)))            num += current_num * (10 ** (len(num_short) - 1 - i))        return str(num)\n\n49. Group anagramsclass Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        from collections import defaultdict        mp = defaultdict(list)        for st in strs:             charCounts = [0] * 26            for c in st:                charCounts[ord(c) - ord(&#x27;a&#x27;)] += 1                        mp[tuple(charCounts)].append(st)                return list(mp.values())\n/** * @param &#123;string[]&#125; strs * @return &#123;string[][]&#125; */var groupAnagrams = function(strs) &#123;    mp = new Object();    for (const st of strs)&#123;        charCounts = new Array(26).fill(0);        for (const c of st)&#123;            charCounts[c.charCodeAt() - &#x27;a&#x27;.charCodeAt()] ++;        &#125;        mp[charCounts] ? mp[charCounts].push(st) : mp[charCounts] = [st]     &#125;    return Object.values(mp)&#125;;\n\n53. maximum subarrayclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        # Greedy        # maxSum = float(&quot;-inf&quot;)        # count = 0        # for i in range(len(nums)):        #     count += nums[i]        #     maxSum = max(maxSum, count)        #     if count &lt; 0:        #         count = 0        # return maxSum        # DP        dp = [0] * len(nums)        dp[0] = nums[0]        maxSum = dp[0]        for i in range(1, len(nums)):            dp[i] = max(dp[i-1]+nums[i], nums[i])            maxSum = max(maxSum, dp[i])                return maxSum\n/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxSubArray = function(nums) &#123;        // let maxSum = nums[0]    // let count = 0    // for(let i=0; i &lt; nums.length; i++)&#123;    //     count += nums[i];    //     maxSum = Math.max(count, maxSum);    //     if(count &lt; 0) count = 0;    // &#125;    // return maxSum    let dp = new Array(nums.length).fill(0)    dp[0] = nums[0]    let maxSum = nums[0]    for(let i = 1; i &lt; nums.length; i++)&#123;        dp[i] = Math.max(dp[i-1]+nums[i], nums[i])        maxSum = Math.max(maxSum, dp[i])    &#125;    return maxSum&#125;;\n54. spiral matrixclass Solution:    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:        if not matrix or not matrix[0]:            return []                res = []        rows, columns = len(matrix), len(matrix[0])        left, right, top, bottom = 0, columns - 1, 0, rows - 1        while left &lt;= right and top &lt;= bottom:            for column in range(left, right + 1):                res.append(matrix[top][column])            for row in range(top+1, bottom + 1):                res.append(matrix[row][right])                        if left &lt; right and top &lt; bottom:                for column in range(right - 1, left, -1):                    res.append(matrix[bottom][column])                for row in range(bottom, top, -1):                    res.append(matrix[row][left])                        left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1                return res\n\n59. Spiral matrix IIclass Solution:    def generateMatrix(self, n: int) -&gt; List[List[int]]:        res = [ [0] * n for i in range(n) ]        num = 1        left, right, top, down = 0, n - 1, 0, n - 1        while left &lt;= right or top &lt;= down:            for j in range(left, right + 1):                res[top][j] = num                num += 1            for i in range(top+ 1, down + 1):                res[i][right] = num                num += 1            for j in range(right - 1, left - 1, -1):                res[down][j] = num                num += 1            for i in range(down - 1, top, -1):                res[i][left] = num                num += 1            left += 1            right -= 1            top += 1            down -= 1                    return res        \n\n71. Simplify pathclass Solution:    def simplifyPath(self, path: str) -&gt; str:        from collections import deque        s = deque([])        names = path.split(&quot;/&quot;)        for name in names:            if name == &quot;..&quot;:                if s:                    s.pop()            elif name and name != &quot;.&quot;:                s.append(name)                return &quot;/&quot;+&quot;/&quot;.join(s)\n\n73. Set matrix zeroesclass Solution:    def setZeroes(self, matrix: List[List[int]]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify matrix in-place instead.        &quot;&quot;&quot;        m = len(matrix)        n = len(matrix[0])        row0Flag = False        col0Flag = False        for i in range(m):            if matrix[i][0] == 0:                col0Flag = True                break                for j in range(n):            if matrix[0][j] == 0:                row0Flag = True                break                for i in range(1, m):            for j in range(1, n):                if matrix[i][j] == 0:                    matrix[i][0] = matrix[0][j] = 0                for i in range(1, m):            for j in range(1, n):                if matrix[i][0] == 0 or matrix[0][j] == 0:                    matrix[i][j] = 0                if row0Flag:            for j in range(n):                matrix[0][j] = 0                if col0Flag:            for i in range(m):                matrix[i][0] = 0\n\n74. search a 2D matrix\n一次二分查找，把二分查找的中间值映射到matrix上class Solution:    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:        m = len(matrix)        n = len(matrix[0])        low, high = 0, m*n-1        while low &lt;= high:            mid = (low + high) // 2            num = matrix[mid // n][mid % n]            if target == num:                return True            elif target &lt; num:                high = mid - 1            else:                low = mid + 1                return False\n75. sort colors\n双指针 用于调换0和1，交换条件和指针移动条件略有不同class Solution:    def sortColors(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        n = len(nums)        p0 = p1 = 0        for i in range(n):            if nums[i] == 1:                nums[i], nums[p1] = nums[p1], nums[i]                p1 += 1            elif nums[i] == 0:                nums[i], nums[p0] = nums[p0], nums[i]                if p0 &lt; p1:                    nums[i], nums[p1] = nums[p1], nums[i]                p0 += 1                p1 += 1        \n\n80. remove duplicates from sorted array II\n此方法可同理把2换成任意的kclass Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        u = 0        for n in nums:            if u &lt; 2 or nums[u - 2] != n:                nums[u] = n                u += 1                return u\n# my solutionclass Solution:    def removeDuplicates(self, nums: List[int]) -&gt; int:        slow = 0        fast = 0        cur_num = nums[0]        times = 0        while fast &lt; len(nums):                        if nums[fast] == cur_num and slow == fast:                if times &lt; 2:                    slow +=1                    fast += 1                    times += 1                else:                    fast += 1            elif nums[fast] == cur_num and slow != fast:                if times &lt; 2:                    nums[fast], nums[slow] = nums[slow], nums[fast]                    times += 1                    slow += 1                    fast += 1                else:                    fast += 1            elif nums[fast] != cur_num and slow != fast:                nums[fast], nums[slow] = nums[slow], nums[fast]                cur_num = nums[slow]                times = 1                slow += 1                fast += 1            else:                cur_num = nums[fast]                times = 1                slow += 1                fast += 1        return slow\n\n33. search in rotated sorted arrayclass Solution:    def search(self, nums: List[int], target: int) -&gt; int:        if not nums:            return -1                n = len(nums)                l, r = 0, n-1        while l &lt;= r:            mid = (l+r)//2            if nums[mid] == target:                return mid            elif nums[0] &lt;= nums[mid]:                if nums[0] &lt;= target and target &lt;= nums[mid]:                    r -= 1                else:                    l += 1            else:                if nums[mid] &lt;= target and target &lt;= nums[n-1]:                    l += 1                else:                    r -= 1                return -1\n\n81. search in rotated sorted array IIclass Solution:    def search(self, nums: List[int], target: int) -&gt; bool:        if not nums:            return False                n = len(nums)        if n == 1:            return nums[0] == target                l, r = 0, n-1        while l &lt;= r:            mid = (l+r) // 2            if nums[mid] == target:                return True            elif nums[l] == nums[mid] and nums[mid] == nums[r]:                l += 1                r -= 1            elif nums[l] &lt;= nums[mid]:                if nums[l] &lt;= target and target &lt;= nums[mid]:                    r -= 1                else:                    l += 1            else:                if nums[mid] &lt;= target and target &lt;= nums[r]:                    l += 1                else:                    r -= 1        return False \n\n367.to be continued\n278.to be continued\n","categories":["刷题笔记"]},{"title":"贪心算法（greedy algorithm)","url":"/2021/12/21/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88greedy-algorithm/","content":"算法本质选择每一阶段的局部最优，从而达到全局最优化\n算法应用场景\n无固定套路，常识性推导\n想不到相应的反例，可以试试贪心\n贪心算法跑过测试用例即可，或自圆其说  \n\n贪心一般解题步骤\n将原本问题分解为若干子问题\n找出适合的贪心策略\n求出每个子问题最优解\n将局部最优解堆叠成全局最优解\n\nleetcode相关题目455.分发饼干(assign cookies)题目链接：\n\n数组-&gt;升序排列，遍历\n可用cookies的index来减少for循环层数\n两种思路\n时间复杂度 O(n)\n\nclass solution:    def find(self, g:List[int], s:List[int]) -&gt; int:        g.sort() # 先进行升序排列        s.sort()        index = 0 # 利用cookies下标代替两层for循环        for i in range(len(s)):            if index &lt; len(g) and s[i] &gt;= g[index]: # ！满足的标准和下标移动                index += 1        return index\n\n376.摆动序列（wiggle subsequence)题目链接：\n\n每个峰值的判断（判断单调区间）\n最右峰值的判断\n时间复杂度 O(n)\n\nclass solution:    def wiggleMaxLength(self, nums:List[int]) -&gt; int:        res = 1        cuffix = 0        prefix = 0        for i in range(len(nums)-1):            curfix = nums[i+1] - nums[i]            if curfix * prefix &lt;= 0 and curfix != 0:                res += 1                prefix = curfix        return res \n\n53.最大子序和（）题目链接：\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        if nums is None:            return nums        temp = 0        maxsum = nums[0]        for i in range(len(nums)):            temp += nums[i]            if temp &gt; maxsum:                maxsum = temp            if temp &lt; 0:                temp = 0        return maxsum\n\n122.买卖股票的最佳时机（best time to buy and sell stock2)题目链接：\n\n我的做法想的太过复杂，使用了判断单调上升区间卖出计算\n时间复杂度 O(n)  \n\nclass Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        prefix, curfix, profit = 0, 0, 0        begin, end = -1, -1        for i in range(len(prices)-1):            curfix = prices[i+1] - prices[i]            if prefix * curfix &lt;= 0 and curfix &gt; 0: #上升区间起点                begin = prices[i]            if prefix * curfix &lt;= 0 and curfix &lt;= 0 and prefix &gt; 0: #上升区间终点                end = prices[i]            if i+1 == len(prices)-1 and prices[-1] - prices[-2] &gt; 0: #判断list末尾是否为上升区间终点                end = prices[i+1]            if begin != -1 and end != -1: #只有同时找到起点和终点时才能组成一个单调区间                profit += (end - begin)                end, begin = -1, -1            prefix = curfix        return profit\n\n题解版本：\n\n实际上只关注正利润，由于题目中股票持有和卖出的特性\n只要利润为正，就记入总利润中，此特性也可以在画的图中展现出来class Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        result = 0        for i in range(1, len(prices)):            result += max(prices[i] - prices[i - 1], 0)        return result\n\n55.跳跃游戏（jump game）题目链接：https://leetcode-cn.com/problems/jump-game/\n\n局部最优解：可跳跃的最大覆盖范围 整体：能否覆盖到终点\nindex：棋子跳跃的下标 cover：棋子当下能够覆盖到的最远下标\n利用cover限制index，并作为while循环的中断条件class Solution:    def canJump(self, nums: List[int]) -&gt; bool:        if len(nums) == 1:            return True        cover = 0        index = 0        while index &lt;= cover:            cover = max(index+nums[index], cover)            if cover &gt;= len(nums) - 1:                return True            index += 1        return False\n\n45.跳跃游戏II题目链接：https://leetcode-cn.com/problems/jump-game-ii/submissions/本题与55相比，不同之处：45输出能否覆盖终点，本题输出覆盖终点的最小步数\n\n局部：可移动距离中尽可能多走，未到终点则步数加1；整体：一步尽可能多走，达到最小步数\ncurCover：当前可覆盖 nextCover：下一步可覆盖\n注意棋子跳跃的时候边界范围的设定class Solution:    def jump(self, nums: List[int]) -&gt; int:        if len(nums) == 1:            return 0        index, curCover, nextCover = 0, 0, 0        step = 0        while index &lt; len(nums) - 1:            nextCover = max(index+nums[index], nextCover)            if index == curCover:                curCover = nextCover                step += 1            index += 1        return step\n\n1005.k次取反后最大化的数组之和(maximize sum of array after k negations)题目链接：https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/\n\n数组按绝对值由大到小排序\n遍历数组，遇到负数则进行取反，k-=1；k=0时跳出循环\n若遍历完全还有剩余k，则取数组最后一个数（最小的数值）反复取反\nO(n)class Solution:    def largestSumAfterKNegations(self, nums: List[int], k: int) -&gt; int:        nums = sorted(nums, key=abs,reverse=True)        for i in range(len(nums)):            if k &gt; 0:                if nums[i] &lt; 0:                    nums[i] = -nums[i]                    k -= 1                else:                    continue            else:                break        if k &gt; 0:            if k % 2 == 1:                nums[-1] = -nums[-1]        return sum(nums)\n\n134.加油站（gas station）题目链接：https://leetcode-cn.com/problems/gas-station/该题和某公司oa中的魔毯问题一样\n\n如果sum(gas) &lt; sum(cost),那么汽车不可能走完一圈\nres[i] = gas[i] - cost[i]class Solution:    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int:        start, cursum, totalsum =0, 0, 0        for i in range(len(gas)):            cursum += gas[i] - cost[i]            totalsum += gas[i] - cost[i]            if cursum &lt; 0:                start = i + 1                cursum = 0        if totalsum &lt; 0:            return -1        return start\n\n135.分发糖果（candy）题目链接：https://leetcode-cn.com/problems/candy/\n\n关键是思考时不能顾此失彼，从左到右和从右到左遍历一遍\n注意第二次遍历时要考虑到取max\npython的后序遍历range（start,stop,step)class Solution:    def candy(self, ratings: List[int]) -&gt; int:        candyvec = [1] * len(ratings)        for i in range(1, len(ratings)):            if ratings[i] &gt; ratings[i-1]:                candyvec[i] = candyvec[i-1] + 1        for j in range(len(ratings)-2, -1, -1):            if ratings[j] &gt; ratings[j+1]:                candyvec[j] = max(candyvec[j], candyvec[j+1]+1)        return sum(candyvec)\n\n860.柠檬水找零（lemonade change）题目链接：https://leetcode-cn.com/problems/lemonade-change/\n\n常识做题\n后续可优化存储和判断，有部分冗余判断\n没有记录20元的张数，因为找零用不了20元class Solution:    def lemonadeChange(self, bills: List[int]) -&gt; bool:        if bills[0] != 5:            return False        change = [0] * 2        for i in range(len(bills)):            if bills[i] == 5: # 情况1 遇到5直接收下                change[0] += 1            elif bills[i] == 10: # 情况2 遇到10则检查有无5                if change[0] &lt; 1:                    return False                else:                    change[0] -= 1                    change[1] += 1            else: # 情况3 遇到20 先用10元找零，不够再用3张5元                if change[0]*5+change[1]*10&lt;15:                    return False                else:                    if change[0] &lt; 1:                        return False                    else:                        if change[1] &gt;= 1:                            change[1] -= 1                            change[0] -= 1                        else:                            if change[0] &lt; 3:                                return False                            else:                                change[0] -= 3        return True\n\n406.根据身高重建队列（queue restruction by height）题目链接：\n\n本题与分发糖果类似，确定一个维度排序，再根据另外一个维度插入\n先按身高维度 从大到小进行排序：确保前面的节点都比自身高\n后面queue的insert 根据另一个维度进行插入，结合list.insert(index, element)，直接根据第二个维度确定插入的下标class Solution:    def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]:        people = sorted(people, key=lambda x: (-x[0], x[1]))        queue = []        for p in people:            queue.insert(p[1], p)        # print(people)        # print(queue)        return queue\n\n452.用最少数量的箭引爆气球（minimum number of arrows to burst ballons)题目链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/\n\n对区间重叠的问题，有意识从维度排序先入手（本题以任一维度排序都行）\n后序思考太复杂，判断重叠只需要上一区间上边界与下一区间的下边界\n完成判断后要更新边界，以便后续判断class Solution:    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:        points = sorted(points, key= lambda x: (x[0], x[1]))        res = 1        for i in range(1,len(points)):            if points[i][0] &gt; points[i-1][1]:                res += 1            else:                points[i][1] = min(points[i-1][1], points[i][1])        return res\n\n435.无重叠区间(non-overlapping intervals)题目链接：https://leetcode-cn.com/problems/non-overlapping-intervals/\n\n解题思路和452类似\n我的ac和题解版本不太一样\n题解思路：最小移除区间数量 = 总区间数量 - 最大非交叉区间数量题解版本：class Solution:    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        intervals = sorted(intervals, key= lambda x:(x[1])) # 按照右边界排序        count  = 1        end = intervals[0][1]        for i in range(1, len(intervals)):            if intervals[i][0] &gt;= end:                count += 1                end = intervals[i][1]        return len(intervals) - count\n\n我的版本：\nclass Solution:    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        intervals = sorted(intervals, key= lambda x:(x[0])) # 按照左边界排序        res = 0        for i in range(1, len(intervals)):            if intervals[i][0] &lt; intervals[i-1][1]:                res += 1                intervals[i][1] = min(intervals[i-1][1], intervals[i][1])        return res\n\n763.划分字母区间（partition labels）题目链接：https://leetcode-cn.com/problems/partition-labels/\n\n第一次遍历list记录该字母出现的最远下标\n巧妙思路： 第二次遍历字符串时，若index==字母的最远index，则说明此处是分割点（无需记录字母的起始位置）\n别忘更新下一个分割区间起始点的位置：上一个分割index+1class Solution:    def partitionLabels(self, s: str) -&gt; List[int]:        character = [0] * 26 # 记录字符出现的最远位置的下标        for i in range(len(s)):            character[ord(s[i])-ord(&#x27;a&#x27;)] = i        start, end = 0, 0        res = []        for j in range(len(s)):            end = max(end, character[ord(s[j])-ord(&#x27;a&#x27;)])            if end == j:                res.append(end - start + 1)                start = j + 1        return res\n\n56.合并区间（merge intervals）题目链接：https://leetcode-cn.com/problems/merge-intervals/\n\n同样地，先对数组进行按第一维度排序\n通过和res中上一个数组的第二维度进行比较，如果重叠则直接更新第二维度，不重叠则append新的数组class Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x:x[0])        res = []        res.append([intervals[0][0], intervals[0][1]])        for i in range(1, len(intervals)):            if intervals[i][0] &lt;= res[-1][1]:                res[-1][1] = max(res[-1][1], intervals[i][1])            else:                res.append([intervals[i][0],intervals[i][1]])        return res\n\n738.单调递增的数字（monotone increasing digits)题目链接：https://leetcode-cn.com/problems/monotone-increasing-digits/submissions/\n\n首先要观察到判断规律\n从后向前遍历更能利用到数字条件，不用分类讨论下一个数字是大于等于的不同情况\n注意列表/字符串/字符等相互转化的方法 以及填满列表的方法class Solution:    def monotoneIncreasingDigits(self, n: int) -&gt; int:        if n &lt;= 9: return n        if n == 10: return 9        num = list(str(n))        for i in range(len(num)-1,0,-1):            if num[i] &lt; num[i-1]:                num[i-1] = str(int(num[i-1])-1)                num[i:] = &quot;9&quot; * (len(num) - i)        return int(&quot;&quot;.join(num))\n\n45. jump game2class Solution:    def jump(self, nums: List[int]) -&gt; int:        if len(nums) == 1:            return 0        # greedy algo        # keep changing the outermost boundary        currentDistance, nextDistance = 0, 0        steps = 0        for i in range(len(nums)-1):            nextDistance = max(nextDistance, i + nums[i])            if currentDistance == i:                steps += 1                currentDistance = nextDistance        return steps\n\n55. jump gameclass Solution:    def canJump(self, nums: List[int]) -&gt; bool:        n, rightmost_index = len(nums), 0        # if n == 1:        #     return True        for i in range(n):            if i &lt;= rightmost_index:                rightmost_index = max(rightmost_index, i+nums[i])                if rightmost_index &gt;= n - 1:                    return True            else:                return False        return False\n\n","categories":["刷题笔记"]},{"title":"链表linked_list","url":"/2022/01/12/%E9%93%BE%E8%A1%A8linked-list/","content":"关于链表作为曾经只用c写链表的人，只能说对链表厌恶至极。确实换了python刷题之后，链表操作更加简单了，但那种内心深处指针移来移去的恐惧还没有消失哈哈哈。不过，越是害怕的东西越要战胜，由于学期任务紧，关于链表的一些技巧后面再补充，这里先post一些挤出时间刷的题吧！\n2. Add two numbers/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123;    let carry = 0;    let dummyHead = null, cur = null;     while(l1 !== null || l2 !== null)&#123;        //  calculate         const num1 = l1 ? l1.val : 0;         const num2 = l2 ? l2.val : 0;         const num = carry + num1 + num2;         let newNum = num % 10;         carry = Math.floor(num / 10);         if(dummyHead === null)&#123;             dummyHead = cur = new ListNode(newNum);         &#125;else&#123;             cur.next = new ListNode(newNum);             cur = cur.next         &#125;                 //  move the pointer        if(l1 !== null)&#123;            l1 = l1.next;        &#125;        if(l2 !== null)&#123;            l2 = l2.next;        &#125;     &#125;     if(carry !== 0)&#123;         cur.next = new ListNode(carry);     &#125;     return dummyHead;&#125;;\n\n24.两两交换链表中的节点 swap nodes in pair题目链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n本题需要三个指针，一个指向pair的前一个节点，剩下两个分别指向pair里的两个nodes\n是否需要继续交换则通过判断pre是否同时存在next和next.next\npre初始可定位在虚拟头节点，若上述判断成立，则使cur和post指向pair（若不成立则代表无需继续交换）# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:\n\n707. design linked listhttps://leetcode.cn/problems/design-linked-list/\nclass LinkNode &#123;    constructor(val, next) &#123;        this.val = val;        this.next = next;    &#125;&#125;var MyLinkedList = function() &#123;    this._size = 0;    this._head = null;    this._tail = null;&#125;;/**  * @param &#123;number&#125; index * @return &#123;number&#125; */MyLinkedList.prototype.get = function(index) &#123;    if(index &lt; 0 || index &gt;= this._size) return -1;    let cur = new LinkNode(0, this._head);    while (index-- &gt;= 0)&#123;        cur = cur.next;    &#125;    return cur.val;&#125;;/**  * @param &#123;number&#125; val * @return &#123;void&#125; */MyLinkedList.prototype.addAtHead = function(val) &#123;    const node = new LinkNode(val, this._head);    this._head = node;    this._size ++;    if(!this._tail)&#123;        this._tail = node;    &#125;&#125;;/**  * @param &#123;number&#125; val * @return &#123;void&#125; */MyLinkedList.prototype.addAtTail = function(val) &#123;    const node = new LinkNode(val, null);    this._size ++;    if(this._tail)&#123;        this._tail.next = node;        this._tail = node;        return;    &#125;    this._tail = node;    this._head = node;&#125;;/**  * @param &#123;number&#125; index  * @param &#123;number&#125; val * @return &#123;void&#125; */MyLinkedList.prototype.addAtIndex = function(index, val) &#123;    if(index &gt; this._size) return;    if(index === this._size)&#123;        this.addAtTail(val);        return;    &#125;    if(index &lt;= 0)&#123;        this.addAtHead(val);        return;    &#125;    let cur = new LinkNode(0, this._head);    let x = index;    while(x-- &gt;= 1)&#123;        cur = cur.next;    &#125;    const node = new LinkNode(val, cur.next);    cur.next = node;    this._size ++;&#125;;/**  * @param &#123;number&#125; index * @return &#123;void&#125; */MyLinkedList.prototype.deleteAtIndex = function(index) &#123;    if(index &lt;0 || index &gt;= this._size) return;    if(index === 0)&#123;        this._head = this._head.next;        if(index === this._size - 1)&#123;            this._tail = this._head;        &#125;        this._size --;        return;    &#125;    let cur = new LinkNode(0, this._head);    let x = index;    while(x-- &gt;= 1)&#123;        cur = cur.next;    &#125;    cur.next = cur.next.next;    if(index === this._size - 1)&#123;        this._tail = cur;    &#125;    this._size -- ;&#125;;MyLinkedList.prototype.printNodes = function()&#123;    let cur = new LinkNode(0, this._head);    let res = [];    for(let i = 0; i &lt;= this._size; i++)&#123;        res.push(cur.val);        cur = cur.next;    &#125;    console.log(res);&#125;/** * Your MyLinkedList object will be instantiated and called as such: * var obj = new MyLinkedList() * var param_1 = obj.get(index) * obj.addAtHead(val) * obj.addAtTail(val) * obj.addAtIndex(index,val) * obj.deleteAtIndex(index) */\n\n206. reverse linked listPython:\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        pre = None        cur = head        while(cur != None):            temp = cur.next            cur.next = pre            pre = cur            cur = temp        return pre\nJavascript:\n/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123;    let pre = null;    let cur = head;    while(cur)&#123;        let temp = cur.next;        cur.next = pre;        pre = cur;        cur = temp;    &#125;    return pre;&#125;;\n\n203. remove linked list elementsJavascript:\n/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; val * @return &#123;ListNode&#125; */var removeElements = function(head, val) &#123;    const dummy_head = new ListNode(0, head);    let cur = dummy_head;    while(cur.next)&#123;        if(cur.next.val === val)&#123;            cur.next = cur.next.next;            continue;        &#125;        cur = cur.next;    &#125;    return dummy_head.next;&#125;;\n\nPython:\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:        fake_head = ListNode()        fake_head.next = head        cur = fake_head        while(cur.next != None):            if(cur.next.val == val):                cur.next = cur.next.next            else:                cur = cur.next        return fake_head.next\n\n24. swap nodes in pairsPython:\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        res = ListNode(0, head)        cur = res        while(cur.next and cur.next.next):            front = cur.next            back = cur.next.next            front.next = back.next            back.next = front            cur.next = back            cur = cur.next.next                return res.next\n\nJavascript:\n/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var swapPairs = function(head) &#123;    let res = new ListNode(0, head);    let cur = res;    while(cur.next &amp;&amp; cur.next.next)&#123;        let front = cur.next;        let back = cur.next.next;        front.next = back.next;        back.next = front;        cur.next = back;        cur = cur.next.next;    &#125;    return res.next;&#125;;\n\n19.删除链表倒数第n个节点remove nth node from end of list题目链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\n\n使用双指针，只需遍历一遍\nslow让fast先走n+1步，n+1是因为单向链表删除操作需要定位在前一个节点\n\nPython:\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:        res = ListNode(0, head)        slow = res        fast = res        while(fast != None and n!= 0):            fast = fast.next            n -= 1                while(fast.next != None):            fast = fast.next            slow = slow.next        slow.next = slow.next.next        return res.next\n\n/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; n * @return &#123;ListNode&#125; */var removeNthFromEnd = function(head, n) &#123;    let res = new ListNode(0, head);    let slow = res;    let fast = res;    while(n &gt; 0)&#123;        fast = fast.next;        n --;    &#125;    while(fast.next !== null)&#123;        fast = fast.next;        slow = slow.next;    &#125;    slow.next = slow.next.next;    return res.next;&#125;;\n\n61. Rotate list# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:        if k == 0 or not head or not head.next:            return head        node = 1        cur = head        while cur.next:            node += 1            cur = cur.next                move = node - k % node        if move == node:            return head                cur.next = head        while move:            cur = cur.next            move -= 1                dummy = cur.next        cur.next = None        return dummy\n\n82. remove duplicates from sorted list II# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def deleteDuplicates(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if not head:            return None        dummy_head = ListNode(-101)        anchor_num = head.val        p = dummy_head        anchor = head        cur = head        while cur:            if anchor_num != cur.val:                if anchor.next == cur:                    p.next = anchor                    p = p.next                    p.next = None                anchor = cur                anchor_num = cur.val            cur = cur.next        if anchor.next == cur:            p.next = anchor        return dummy_head.next\n\n83. remove duplicates from sorted list# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def deleteDuplicates(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        if not head:            return None        cur = head        p = head        while cur:            if cur.val != p.val:                p.next = cur                p = cur            cur = cur.next        p.next = None        return head\n\n86. partition list# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def partition(self, head: Optional[ListNode], x: int) -&gt; Optional[ListNode]:        if not head:            return None        dummy = ListNode(-101)        dummy.next = head        p1 = p2 = dummy        p3 = head        while p3:            if p3.val &lt; x and p2.val &gt;= x:                # swap the node                p2.next = p3.next                p3.next = p1.next                p1.next = p3                p1 = p1.next                p3 = p2.next            else:                if p3.val &gt;= x and p2.val &lt; x:                    p1 = p2                p3 = p3.next                p2 = p2.next            # print(dummy.next.val, p1.val)                return dummy.next","categories":["刷题笔记"]},{"title":"巴斯克芝士蛋糕","url":"/2021/12/27/%E5%B7%B4%E6%96%AF%E5%85%8B%E8%8A%9D%E5%A3%AB%E8%9B%8B%E7%B3%95/","content":"材料（此配方可制作6寸巴斯克芝士，8寸则所有用量乘以2）\n奶油奶酪 cream cheese: 350g\n细砂糖 sugar: 75g\n蛋黄 egg yolk: 3个\n全蛋 egg（大): 2个\n淡奶油 heavy whipping cream: 150g\n牛奶 whole milk: 50g\n玉米淀粉/低筋面粉 corn starch/cake flour: 12g\n\n简易做法版本（无电动打蛋器/无料理棒/无筛）\n奶油奶酪加入细砂糖，隔水加热，搅拌至顺滑（不能过火，有可能导致水油分离）\n\n\n\n分次加入3个蛋黄，2个全蛋，搅拌至吸收再加入下一个（鸡蛋可提前从冰箱取出放至室温，减少水油分离可能性）\n\n \n\n加入牛奶，搅拌均匀（有抹茶粉/可可粉则在牛奶后加入）\n\n加入淡奶油，搅拌均匀\n\n加入玉米淀粉，搅拌均匀\n\n烤箱预热，模具铺入烘焙纸（烘焙纸打湿/弄皱后更容易贴合模具）\n\n烤箱中层，220度22-23mins，提前查看表皮上色，上色不够深则移入烤箱上层烘烤2-3mins（我的公寓烤箱拧至一半多些，烘烤20mins后移入烤箱上层，3-4mins）\n\n出炉冷却后保鲜膜包裹起来，无需脱模，冷藏一夜\n\n \n\n可把部分剩余淡奶油打发至六分，结合水果进行装饰\n\n  \n\n\n \n\n\n","categories":["食谱"]},{"title":"面试准备","url":"/2022/01/24/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/","content":"更新一下时间线： \n1.19 收到亚麻oa 1.24做完1.29 收到亚麻vo（实际上还差点因为没有check邮箱而错过）2.9 亚麻vo一道technical 两道bqtechnical考了LRUCachebq1: tell me about the mistakes that you’ve madebq2: tell me about a situation you were going to miss the deadline(非常尴尬的是 我的bq只准备了一个万能模板，差点gg 第二个问题开始现场胡诌，毕竟我也快要到miss ddl的阶段了，明天某课中期pre 现在啥都没开始做)\n2.15元宵节收到亚麻offer等了很久 没想到是因为Google邮箱给我分类到promotion那类了 根本没提示收到之后疯狂房间暴走好几圈哈\nleetcode原题For frontend interviewtopological sorting269 Alien Dictionary/** * @param &#123;string[]&#125; words * @return &#123;string&#125; */var alienOrder = function(words) &#123;    const q = []    const graph = new Map()    const inDegrees = new Map()        // initialize graph and inDegrees    for(let word of words)&#123;        for(let char of word)&#123;            if(!graph.has(char))&#123;                graph.set(char, [])            &#125;            if(!inDegrees.has(char))&#123;                inDegrees.set(char, 0)            &#125;        &#125;    &#125;    for(let i = 1; i &lt; words.length; i++)&#123;        let word1 = words[i-1]        let word2 = words[i]        let len = Math.min(word1.length, word2.length)        if(word2.length &lt; word1.length &amp;&amp; word1.startsWith(word2))&#123;            return &#x27;&#x27;        &#125;        // Extracing dependency rule from the word        // word1[j] must before word2[j]: word1[j] -&gt; word2[j]        // Add the relation in graph and increase the inDegree for word2        for(let j = 0; j &lt; len; j++)&#123;            if(word1[j] !== word2[j])&#123;                graph.get(word1[j]).push(word2[j])                inDegrees.set(word2[j], inDegrees.get(word2[j])+1)                break;            &#125;        &#125;    &#125;    // Find all the inDegree as 0    for (let c of inDegrees)&#123;        if(c[1] === 0)&#123;            q.push(c[0])        &#125;    &#125;    const res = []    // BFS    while(q.length)&#123;        const node = q.shift()        res.push(node)        for(let c of graph.get(node))&#123;            const edges = inDegrees.get(c) - 1            inDegrees.set(c, edges)            if(edges === 0) q.push(c)        &#125;    &#125;    // Compare the char number and inDegrees size    return res.length === inDegrees.size ? res.join(&quot;&quot;) : &quot;&quot;&#125;;\n\nCourse Schedule II\nO(V+E) v=nodes number e=edge number\nvar findOrder = function(numCourses, prerequisites) &#123;    const inDegrees = new Array(numCourses).fill(0);    // Calculate in degrees for every node    for(const [v, _] of prerequisites)&#123;        inDegrees[v]++;    &#125;    const q = [];    const res = [];    // pick the node that has zero in degree    for(let i = 0; i &lt; inDegrees.length; i++)&#123;        const degree = inDegrees[i];        if(degree === 0) q.push(i)    &#125;    // Do dfs to search for the q which has nodes as indegree as 0    while(q.length)&#123;        const u0 = q.shift();        numCourses--;        res.push(u0);        for(const [v, u] of prerequisites)&#123;            if(u === u0)&#123;                inDegrees[v]--                if(inDegrees[v] === 0) q.push(v)            &#125;        &#125;    &#125;    return numCourses === 0 ? res : []&#125;;\n\nCourse Schedulevar canFinish = function(numCourses, prerequisites) &#123;    const inDegree = new Array(numCourses).fill(0)    for(const [v,_] of prerequisites)&#123;        inDegree[v]++    &#125;    const q = [];    for(let i = 0; i &lt; inDegree.length; i++)&#123;        const degree = inDegree[i]        if(degree === 0) q.push(i)    &#125;    while(q.length)&#123;        const node = q.shift()        numCourses --        for(const [a, b] of prerequisites)&#123;            if(b === node)&#123;                inDegree[a] --                if(inDegree[a] === 0) q.push(a)            &#125;        &#125;    &#125;    return numCourses === 0&#125;;\n\nParallel Coursevar minimumSemesters = function(n, relations) &#123;    const que = []    const inDegrees = new Array(n+1).fill(0)    const map = new Map()    for(let [a, v] of relations)&#123;        inDegrees[v] ++        if(!map.has(a)) map.set(a, [])        map.get(a).push(v)    &#125;    for(let i=1; i &lt; n+1; i++)&#123;        if(inDegrees[i] === 0)&#123;            que.push(i)        &#125;    &#125;    const list = []    let semester = 0    while(que.length)&#123;        const levelSize = que.length        for(let i = 0; i &lt; levelSize; i++)&#123;            const node = que.shift()            list.push(node)            for(let [a, b] of relations)&#123;                if(a === node)&#123;                    inDegrees[b] --                    if(inDegrees[b] === 0) que.push(b)                &#125;            &#125;        &#125;        semester++            &#125;    return list.length === n ? semester : -1&#125;;\n\nDiameter of N-Ary Treevar diameter = function(root) &#123;    let max = 0;    const dfs = (node) =&gt; &#123;        if(!node) return 0;        let first= 0, second = 0;        for(let child of node.children)&#123;            let pathLen = 1 + dfs(child)            if(pathLen &gt;= first)&#123;                second = first                first = pathLen            &#125;else if(pathLen &gt;= second)&#123;                second = pathLen            &#125;        &#125;        max = Math.max(max, first+second)        return first    &#125;    dfs(root)    return max&#125;;\n\n\nCourse Schedule IVvar checkIfPrerequisite = function(numCourses, prerequisites, queries) &#123;    const adjList = Array.from(&#123;length: numCourses&#125;, () =&gt; [])    const inDegrees = Array(numCourses).fill(0)    const allPre = Array.from(&#123;length: numCourses&#125;, () =&gt; new Set());    let q = []    for(let [pre, course] of prerequisites)&#123;        adjList[pre].push(course)        inDegrees[course] ++    &#125;    for(let i = 0; i &lt; numCourses; i++)&#123;        if(inDegrees[i] === 0) q.push(i)    &#125;    // BFS    while(q.length)&#123;        const len = q.length        for(let i = 0; i &lt; len; i++)&#123;            const parent = q.shift()            for(let child of adjList[parent])&#123;                inDegrees[child]--                if(inDegrees[child] === 0) q.push(child)                allPre[child] = new Set([...allPre[child], ...allPre[parent], parent])            &#125;        &#125;    &#125;        return queries.map(([pre, course]) =&gt; allPre[course].has(pre))&#125;;\n\nStack operationBasic calculator IIvar calculate = function(s) &#123;    let stack = [];    let preOperator = &#x27;+&#x27;;    let num = &#x27;&#x27;;    // make sure that&#x27;s the condition equal to length to make sure all number/op in the stack    for(let i = 0; i &lt;= s.length; i++)&#123;        const cur = s[i]        if(cur === &#x27; &#x27;) continue        // is a number        if(!isNaN(cur)) num += cur        if(isNaN(cur))&#123;            num = Number(num)            if(preOperator === &#x27;+&#x27;)&#123;                stack.push(num)            &#125;else if(preOperator === &#x27;-&#x27;)&#123;                stack.push(-num)            &#125;else if(preOperator === &#x27;*&#x27;)&#123;                stack.push(stack.pop() * num)            &#125;else&#123;                stack.push(Math.trunc(stack.pop() / num))            &#125;            // reset the state            num = &#x27;&#x27;;            preOperator = cur        &#125;    &#125;    return stack.reduce((acc, curr) =&gt; acc+curr, 0)&#125;;\n\nBasic calculatorvar calculate = function(s) &#123;    let res = 0, sum = 0, sign = 1;    let myStack = [];    // save as first sign    myStack.push(1)    for(let ch of s)&#123;        if(ch === &#x27; &#x27;) continue        if(!isNaN(ch)) &#123;            sum = sum * 10 + Number(ch)&#125;        else&#123;            // always multiple with previous sign and clear sum            res += sum * sign * myStack[myStack.length - 1];            sum = 0;            if(ch === &#x27;-&#x27;) sign = -1            else if(ch === &#x27;+&#x27;) sign = 1            else if(ch === &#x27;(&#x27;) &#123;                myStack.push(myStack[myStack.length - 1] * sign)                sign = 1            &#125;else if(ch === &#x27;)&#x27;) myStack.pop()        &#125;            &#125;    // add up the last num    return res += (sign * sum)&#125;;\n\nDecode string    /*        we have 4 possibilities        1) opening braces -&gt; new sequence starts, so         add curr string and curr number to the stack, reassign both        to initial values        2) closing braces -&gt; the sequence is over, it is time to create a substring        by getting prev string and prev number from the stack, add prev string(repeated prev num times)        to curr string        3) if it is number add to curr num        4) if it is char add to curr string    */var decodeString = function(s) &#123;    let stack = []    let currStr = &#x27;&#x27;    let currNum = 0    for (let i = 0; i &lt; s.length; i++)&#123;        if(s[i] === &#x27;[&#x27;)&#123;            stack.push(currStr)            stack.push(currNum)            currStr = &#x27;&#x27;            currNum = 0        &#125;else if(s[i] === &#x27;]&#x27;)&#123;            let prevNum = stack.pop()            let prevStr = stack.pop()            currStr = prevStr + currStr.repeat(prevNum)        &#125;else if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;)&#123;            currNum = currNum * 10 + Number(s[i])        &#125;else&#123;            currStr += s[i]        &#125;    &#125;    return currStr&#125;;\n\nLowest Common Ancestor of a Binary Tree IIIvar lowestCommonAncestor = function(p, q) &#123;    let depthFirst = getDepth(p)    let depthSecond = getDepth(q)    while(depthFirst !== depthSecond)&#123;        if(depthFirst &gt; depthSecond)&#123;            p = p.parent            depthFirst --        &#125;else&#123;            q = q.parent            depthSecond --        &#125;    &#125;    while(q != p)&#123;        p = p.parent        q = q.parent    &#125;    return p&#125;;function getDepth(node)&#123;    let depth = 0;    while(node)&#123;        node = node.parent        depth++    &#125;    return depth&#125;\n\nInterval ProblemMerge Intervalsvar merge = function(intervals) &#123;    intervals.sort((a, b) =&gt; a[0] - b[0])    let res = []    let curInterval = intervals[0]    for(let i = 1; i &lt; intervals.length; i++)&#123;        if(intervals[i][0] &lt;= curInterval[1])&#123;            curInterval[1] = Math.max(intervals[i][1], curInterval[1])        &#125;else&#123;            res.push(curInterval)            curInterval = intervals[i]        &#125;    &#125;    res.push(curInterval)    return res&#125;;\n\nEmployee free time/* Approach:            -- Merge all intervals and sort on start time            -- Keep track of two pointers - start and end            -- Start with first time and mark it prev            -- If there&#x27;s an overlap,               start = Math.min(start, current.start)               end = Math.max(end, current.end)            -- If there&#x27;s no overlap, free interval is [prev.end, current.start]    */var employeeFreeTime = function(schedule) &#123;    if(!schedule || schedule.length === 0) return []    const merged = schedule.flat()    merged.sort((a, b) =&gt; a.start - b.start)    const freeTime = [];    let prev = merged[0], start = prev.start, end = prev.end    for(let i = 1; i &lt; merged.length; i++)&#123;        let current = merged[i]        if(end &gt;= current.start)&#123;            start = Math.min(start, current.start)            end = Math.max(end, current.end)        &#125;else&#123;            freeTime.push(new Interval(end, current.start))            start = current.start            end = current.end        &#125;    &#125;    return freeTime&#125;;\n\nMeeting Rooms II\nO(nlogn)var minMeetingRooms = function(intervals) &#123;    const all = []    for(let interval of intervals)&#123;        all.push([interval[0], 0]) // start - 0        all.push([interval[1], 1]) // end - 1    &#125;    all.sort((a,b) =&gt; &#123;        return a[0] - b[0] || b[1] - a[1]    &#125;)    let result = 0;    let tempRoomNum = 0;    for(let [_, meetingState] of all)&#123;        if(meetingState === 1)&#123;            tempRoomNum --;        &#125;else&#123;            tempRoomNum++;        &#125;        result = Math.max(tempRoomNum, result)    &#125;    return result&#125;;\n\nMeeting Rooms\nO(nlogn)var canAttendMeetings = function(intervals) &#123;    intervals.sort((a, b) =&gt; a[0] - b[0] || a[1] - b[1])    for(let i = 0 ; i &lt; intervals.length -1 ; i++)&#123;        let e1 = intervals[i][1];        let e2 = intervals[i+1][0];        if(e1 &gt; e2) return false    &#125;    return true&#125;;\n\nDFS / BFSshortest distance from all buildingsconst directions = [[0, 1], [0, -1], [-1, 0], [1, 0]]var shortestDistance = function(grid) &#123;    const m = grid.length, n = grid[0].length    const tmp = Array.from(Array(m), () =&gt; Array(n).fill(0))    let emptyLandValue = 0    const isValid = (x, y) =&gt; &#123;        return x &lt; m &amp;&amp; x &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; grid[x][y] === emptyLandValue    &#125;    let minDistance = Infinity    for(let i =0; i &lt; m; i++)&#123;        for(let j = 0; j &lt; n; j++)&#123;            if(grid[i][j] === 1)&#123;                minDistance = Infinity                let queue = []                queue.push([i, j, 0])                while(queue.length)&#123;                    const len = queue.length                    const nextQ = []                    for(let k = 0; k &lt; len; k++)&#123;                        let[x, y, distance] = queue[k]                        distance++                        for(const [dx, dy] of directions)&#123;                            const nx = x + dx                            const ny = y + dy                            if(isValid(nx, ny))&#123;                                grid[nx][ny] --                                tmp[nx][ny] += distance                                minDistance = Math.min(minDistance, tmp[nx][ny])                                nextQ.push([nx, ny, distance])                            &#125;                        &#125;                    &#125;                    queue = nextQ                &#125;                emptyLandValue --            &#125;        &#125;    &#125;    return minDistance === Infinity ? -1 : minDistance&#125;;\n\nNumber of Islands\nO(m*n)// DFSvar numIslands = function(grid) &#123;    let island = 0;    const m = grid.length, n = grid[0].length;    const dfs = (i, j) =&gt; &#123;        if(i &gt;= m || j &gt;= n || i &lt; 0 || j &lt; 0 || grid[i][j] !== &#x27;1&#x27;) return;        grid[i][j] = &#x27;0&#x27;        dfs(i, j+1)        dfs(i, j-1)        dfs(i-1, j)        dfs(i+1, j)    &#125;    for(let i = 0; i &lt; m; i++)&#123;        for(let j = 0; j &lt; n; j++)&#123;            if(grid[i][j] === &#x27;1&#x27;)&#123;                island++;                dfs(i, j)            &#125;        &#125;    &#125;    return island&#125;;//BFSconst DIRECTION = [[0, 1], [0, -1], [1, 0], [-1, 0]]var numIslands = function(grid) &#123;    const m = grid.length, n = grid[0].length    let island = 0    const bfs = (i, j) =&gt; &#123;        let q = []        grid[i][j] = &#x27;0&#x27;        q.push([i,j])        while(q.length)&#123;            const [x, y] = q.shift()            for(let [a, b] of DIRECTION)&#123;                if(x + a &lt; 0 || x + a &gt;= m || y + b &lt; 0 || y + b &gt;= n || grid[x+a][y+b] === &#x27;0&#x27;) continue                grid[x+a][y+b] = &quot;0&quot;                q.push([x+a, y+b])            &#125;        &#125;    &#125;    for(let i = 0; i &lt; m; i++)&#123;        for(let j = 0; j &lt; n; j++)&#123;            if(grid[i][j] === &#x27;1&#x27;)&#123;                island ++                bfs(i, j)            &#125;        &#125;    &#125;    return island&#125;;\n\nMax Area of Island\nO(m*n)var maxAreaOfIsland = function(grid) &#123;    let res = 0, m = grid.length, n = grid[0].length    function dfs(i, j)&#123;        if(i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n || grid[i][j] === 0) return 0        grid[i][j] = 0        return 1 + dfs(i+1, j) + dfs(i-1, j) + dfs(i, j+1) + dfs(i, j-1)    &#125;    for(let i = 0; i &lt; m ; i++)&#123;        for(let j = 0; j &lt; n; j++)&#123;            if(grid[i][j]) res = Math.max(res, dfs(i, j))        &#125;    &#125;    return res&#125;;\n\nArrayvar maxDistToClosest = function(seats) &#123;    let maximum = 0;    let left = 0, right = 0;    seats.forEach((seat, i) =&gt; &#123;        right = i        const distance = right - left        if(seat)&#123;            if(!seats[left])&#123;                maximum = Math.max(distance, maximum)            &#125;else&#123;                maximum = Math.max(maximum, Math.floor(distance / 2))            &#125;            left = i        &#125;else if(right === seats.length - 1)&#123;            maximum = Math.max(maximum, distance)        &#125;    &#125;)    return maximum&#125;;\n\nsearch suggested systemsvar suggestedProducts = function(products, searchWord) &#123;    products.sort()    let ans = [], right = products.length - 1, left = 0    for(let i = 0; i &lt; searchWord.length; i++)&#123;        let c = searchWord.charAt(i), res=[]        while(products[left]?.charAt(i) &lt; c) left++        while(products[right]?.charAt(i) &gt; c) right--        for(let j = 0; j &lt; 3 &amp;&amp; left + j &lt;= right; j++) res.push(products[left+j])        ans.push(res)    &#125;    return ans&#125;;\nPower of twovar isPowerOfTwo = function(n) &#123;    return n &gt; 0 &amp;&amp; (n &amp; (n-1)) === 0&#125;;\n\nLRU Cache/** * @param &#123;number&#125; capacity */var LRUCache = function(capacity) &#123;    this.cache = new Map()    this.capacity = capacity&#125;;/**  * @param &#123;number&#125; key * @return &#123;number&#125; */LRUCache.prototype.get = function(key) &#123;    if(!this.cache.has(key)) return -1    const v = this.cache.get(key)    this.cache.delete(key);    this.cache.set(key, v)    return this.cache.get(key)&#125;;/**  * @param &#123;number&#125; key  * @param &#123;number&#125; value * @return &#123;void&#125; */LRUCache.prototype.put = function(key, value) &#123;    if(this.cache.has(key))&#123;        this.cache.delete(key)    &#125;    this.cache.set(key, value)    if(this.cache.size &gt; this.capacity)&#123;        this.cache.delete(this.cache.keys().next().value)    &#125;&#125;;\n\nsnap first roundconst input = [  &#123; id: 8, managerId: 8, name: &quot;Alice&quot; &#125;,  &#123; id: 2, managerId: 8, name: &quot;Bob&quot; &#125;,  &#123; id: 3, managerId: 2, name: &quot;Emp3&quot; &#125;,  &#123; id: 4, managerId: 3, name: &quot;Emp4&quot; &#125;,  &#123; id: 5, managerId: 4, name: &quot;Emp5&quot; &#125;,  &#123; id: 6, managerId: 3, name: &quot;Emp6&quot; &#125;,  &#123; id: 7, managerId: 8, name: &quot;Emp7&quot; &#125;];/* Output:Alice  Bob    Emp3      Emp4        Emp5      Emp6  Emp7 */function main() &#123;let relationMap = new Map()let root = -1;let managerName = &quot;&quot;;const indent = &#x27;\\t&#x27;function findRelations(input)&#123;    input.forEach((&#123;id, managerId, name&#125;) =&gt; &#123;        if(!relationMap.has(managerId)) relationMap.set(managerId, [])        if(id === managerId) &#123;            root = id;            managerName = name;        &#125;else&#123;            relationMap.get(managerId).push(&#123;id, name&#125;)        &#125;    &#125;)&#125;    function dfs(id, name, depth)&#123;    // end condition, no more reporters    if(!relationMap.has(id) || !relationMap.get(id)) return [`$&#123;indent.repeat(depth)&#125;$&#123;name&#125;`]        const reporters = relationMap.get(id);        return [`$&#123;indent.repeat(depth)&#125;$&#123;name&#125;`,...reporters.map((&#123;id, name&#125;) =&gt; &#123;        return dfs(id, name, depth+1)    &#125;)].join(&#x27;\\n&#x27;)&#125;findRelations(input)const res = dfs(root, managerName, 0)console.log(res)&#125;main()\n\nOthersScore of Parentheses\nO(n)var scoreOfParentheses = function(s) &#123;    // &quot;((()()))&quot;    let cur = 0;    let stack = [];    for(let q of s)&#123;        if(q === &#x27;(&#x27;)&#123;            stack.push(cur);            cur = 0;        &#125;else&#123;            const previousValue = stack.pop();            // Math.max(1, cur * 2) handles the two cases:            // If cur is 0 (which happens if the current pair is just (), an atomic pair), then Math.max(1, cur * 2) results in 1.            // If cur is non-zero (which means we have a nested structure like (A), then cur * 2 accounts for the score doubling rule.            cur = previousValue + Math.max(1, cur*2)        &#125;    &#125;      return cur  &#125;;\n\nJump Game III\nBFS | DFS we can discard the visited set by using -1\nO(n)var canReach = function(arr, start) &#123;    const visited = new Set();    const queue = [start];    const length = arr.length;    for(let i = 0; i &lt; queue.length; i++)&#123;        const currentIndex = queue[i];        if(visited.has(currentIndex)) continue;        if(arr[currentIndex] === 0) return true;        visited.add(currentIndex);        currentIndex + arr[currentIndex] &lt; length &amp;&amp; queue.push(currentIndex+arr[currentIndex]);        currentIndex - arr[currentIndex] &gt;= 0 &amp;&amp; queue.push(currentIndex-arr[currentIndex]);    &#125;    return false&#125;;const canReach = (arr, start) =&gt; &#123;  const val = arr[start];  if (val === 0) return true;  if (val === -1) return false;  arr[start] = -1;  return (start - val &gt;= 0 &amp;&amp; canReach(arr, start - val)) || (start + val &lt; arr.length &amp;&amp; canReach(arr, start + val));&#125;;\n\nFlip String to Monotone Increasing\nO(n)var minFlipsMonoIncr = function(s) &#123;    let numOfFlips = 0;    let numOfOne = 0;    for(let c of s)&#123;        if(c === &quot;1&quot;)&#123;            numOfOne ++;        &#125;else&#123;            if(numOfOne &gt; 0)&#123;                numOfOne --;                numOfFlips ++;            &#125;        &#125;    &#125;    return numOfFlips&#125;;var minFlipsMonoIncr = function(s) &#123;    let ans = 0, one = 0, zero = 0, j = 0;    let dp = [];     while (j &lt; s.length) &#123;        if (s[j] == &#x27;1&#x27;) break;        else dp[j] = 0;         j++;    &#125;    for (let i = j; i &lt; s.length; i++) &#123;        if (s[i] == &#x27;1&#x27;) &#123;dp[i] = !dp[i - 1] ? 0 : dp[i - 1];one++&#125;         else &#123;            zero++;             let a = Math.min(one, zero);            dp[i] = Math.min(1 + dp[i - 1], a);          &#125;    &#125;    // console.log(dp)    return dp[s.length - 1];&#125;;\n\nShortest Bridge\nO(n*n)\nDFS to find island -&gt; BFS to build bridgeconst DIRECT = [[0,1],[0,-1],[1,0],[-1,0]]var shortestBridge = function(grid) &#123;    let m = grid.length, n = grid[0].length;    let q = [];    for(let i = 0; i &lt; m; i++)&#123;        for(let j = 0; j &lt; n; j++)&#123;            if(findIslandDfs(i,j))&#123;                return buildBridgeBfs()            &#125;        &#125;    &#125;;    function findIslandDfs(i,j) &#123;        if(i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || grid[i][j] !== 1) return false;        grid[i][j] = 2;        q.push([i, j]);        findIslandDfs(i+1, j)        findIslandDfs(i-1, j)        findIslandDfs(i, j-1)        findIslandDfs(i, j+1)        return true    &#125;    function buildBridgeBfs () &#123;        let distance = -1;        let currentQueue = [];        while(q.length &gt; 0)&#123;            currentQueue = q;            q = [];            for(let [r, c] of currentQueue)&#123;                for(let[dx, dy] of DIRECT)&#123;                    const nextRow = r + dx;                    const nextCol = c + dy;                                   if(nextRow &gt;= 0 &amp;&amp; nextRow &lt; m &amp;&amp; nextCol &gt;= 0 &amp;&amp; nextRow &lt; n &amp;&amp; grid[nextRow][nextCol] !== 2)&#123;                        if(grid[nextRow][nextCol] === 1)&#123;                            return distance + 1;                        &#125;                        grid[nextRow][nextCol] = 2;                        q.push([nextRow, nextCol])                    &#125;                &#125;            &#125;            distance++;        &#125;        return -1;    &#125;    return -1;&#125;;\n\nExclusive time of functions\nO(n)var exclusiveTime = function(n, logs) &#123;    const sums = new Array(n).fill(0)    const stack = [];    let prevTime;    logs.forEach((log) =&gt; &#123;        const details = log.split(&#x27;:&#x27;)        const funcId = parseInt(details[0])        const state = details[1]        const time = parseInt(details[2]);        if(state === &#x27;start&#x27;)&#123;            if(stack.length &gt; 0)&#123;                let prevFunc = stack[stack.length - 1];                sums[prevFunc] += (time - prevTime)            &#125;            stack.push(funcId)            prevTime = time;        &#125;else&#123;            const lastFunc = stack.pop();            sums[lastFunc] += (time - prevTime + 1);            prevTime = time + 1        &#125;    &#125;)    return sums&#125;;\n\nWord searchvar exist = function(board, word) &#123;    const m = board.length, n = board[0].length;    for(let i = 0; i &lt; m; i++)&#123;        for(let j = 0; j &lt; n; j++)&#123;            if(backtracking(i, j, 0)) return true        &#125;    &#125;    function backtracking(i, j, k)&#123;        if(k === word.length) return true                if(i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || word.charAt(k) !== board[i][j]) return false        const temp = board[i][j]        board[i][j] = &#x27;/n&#x27;        const result = backtracking(i+1, j, k+1) || backtracking(i-1, j, k+1) || backtracking(i, j+1, k+1) || backtracking(i, j-1, k+1)        board[i][j] = temp        return result    &#125;    return false&#125;;\n\nPower of Two\nloop\nand operatorvar isPowerOfTwo = function(n) &#123;    if(n === 0) return false    while(n &gt; 0)&#123;        if(n === 1) return true        if(n % 2 !== 0) break        n = n /2    &#125;    return false&#125;;var isPowerOfTwo = function(n) &#123;    return n &gt; 0 &amp;&amp; (n &amp; (n-1)) === 0&#125;;\n\nMerge Two Sorted Lists/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; list1 * @param &#123;ListNode&#125; list2 * @return &#123;ListNode&#125; */var mergeTwoLists = function(list1, list2) &#123;    let dummy = new ListNode();    let cur = dummy;    while(list1 &amp;&amp; list2)&#123;        if(list1.val &gt; list2.val)&#123;            cur.next = list2;            list2 = list2.next        &#125;else&#123;            cur.next = list1;            list1 = list1.next        &#125;        cur = cur.next    &#125;    cur.next = list1 || list2    return dummy.next&#125;;\n\nInsert Delete GetRandom O(1)var RandomizedSet = function() &#123;    this.list = []    this.map = new Map()&#125;;/**  * @param &#123;number&#125; val * @return &#123;boolean&#125; */RandomizedSet.prototype.insert = function(val) &#123;    if(this.map.has(val)) return false    this.list.push(val)    this.map.set(val, this.list.length - 1)    return true&#125;;/**  * @param &#123;number&#125; val * @return &#123;boolean&#125; */RandomizedSet.prototype.remove = function(val) &#123;    if(!this.map.has(val)) return false    const index = this.map.get(val)    this.list[index] = this.list[this.list.length-1]    this.map.set(this.list[index], index)    this.list.pop()    this.map.delete(val)    return true&#125;;/** * @return &#123;number&#125; */RandomizedSet.prototype.getRandom = function() &#123;    const randomIndex = Math.floor(Math.random() * this.list.length)    return this.list[randomIndex]&#125;;/**  * Your RandomizedSet object will be instantiated and called as such: * var obj = new RandomizedSet() * var param_1 = obj.insert(val) * var param_2 = obj.remove(val) * var param_3 = obj.getRandom() */\n\nMax Consecutive Ones IIIvar longestOnes = function(nums, k) &#123;    let left = 0, right = 0;    while(right &lt; nums.length)&#123;        if(nums[right] === 0) k--        if(k &lt; 0)&#123;            k = nums[left] === 0 ? k+1 : k            left ++        &#125;        right ++    &#125;    return right - left&#125;;\nTop K Frequent Elements\nO(nlogn)var topKFrequent = function(nums, k) &#123;    let counter = new Map();    nums.forEach((num) =&gt; &#123;        counter.set(num, (counter.get(num)|| 0) + 1)    &#125;)    let sortedArray = Array.from(counter.entries()).sort((a, b) =&gt; b[1] - a[1])    return sortedArray.slice(0, k).map(num =&gt; num[0])&#125;;\n\nFind Peak Elementvar findPeakElement = function(nums) &#123;    let l = 0, r = nums.length - 1    while(l &lt;= r)&#123;        const mid = Math.floor(l + (r - l) / 2)        const prev = nums[mid - 1] || -Infinity        const next = nums[mid + 1] || -Infinity        if(prev &lt; nums[mid] &amp;&amp; nums[mid] &gt; next)&#123;             return mid        &#125;else if(next &gt;= nums[mid])&#123;            l = mid + 1        &#125;else&#123;            r = mid - 1        &#125;    &#125;&#125;;\n\nNested List Weight Sumvar depthSum = function(nestedList) &#123;    function dfs(array, depth)&#123;        let sum = 0;        for(let i = 0; i &lt; array.length; i++)&#123;            if(!array[i].isInteger())&#123;                sum = sum + dfs(array[i].getList(), depth + 1)            &#125;else&#123;                sum = sum + array[i].getInteger() * depth            &#125;        &#125;        return sum    &#125;    return dfs(nestedList, 1)&#125;;\n\nMaking a large island\nO(mn)const DIRECTION = [[-1, 0], [1, 0], [0, -1], [0, 1]]var largestIsland = function(grid) &#123;    let m = grid.length, n = grid[0].length    let numId = 2    let islandMap = new Map()    let maxAreaIsland = 0;        // pain the island by id and return the area    function paintIsland(id, i, j)&#123;        if(i &lt; 0 || j &lt; 0 || j &gt;= n || i &gt;= m || grid[i][j] !== 1) return 0                grid[i][j] = id        return 1 + paintIsland(id, i+1, j) + paintIsland(id, i-1, j) + paintIsland(id, i, j+1) + paintIsland(id, i, j-1)    &#125;    // Paint all the island and calculate the area    for(let i = 0; i &lt; m; i++)&#123;        for(let j = 0; j &lt; n; j++)&#123;            if(grid[i][j] === 1)&#123;                const islandArea = paintIsland(numId, i, j)                maxAreaIsland = Math.max(islandArea, maxAreaIsland)                islandMap.set(numId, islandArea)                numId += 1            &#125;        &#125;    &#125;    islandMap.set(0, 0)    let res = Math.max(0, maxAreaIsland)    let islands = []    //iterate through the water and calculate the 4 direction island area    for(let i = 0; i &lt; m; i++)&#123;        for(let j = 0; j &lt; n; j++)&#123;            if(grid[i][j] === 0)&#123;                // since fliping the water to island, initialize as 1                let sum = 1                // memorize which neighbor island is visited                let visited = new Set()                for(const dir of DIRECTION)&#123;                    let x = i + dir[0], y = j + dir[1]                    if(x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || visited.has(grid[x][y])) continue                    sum += islandMap.get(grid[x][y])                    visited.add(grid[x][y])                &#125;                res = Math.max(sum, res)            &#125;        &#125;    &#125;    return res&#125;;\n\nDiameter of Binary Tree\nO(n)var diameterOfBinaryTree = function(root) &#123;        let res = 0    function dfs(node)&#123;        if(!node) return 0        const left = dfs(node.left)        const right = dfs(node.right)        res = Math.max(res, left + right)        return Math.max(left, right) + 1    &#125;    dfs(root)    return res&#125;;\n\nBinary Tree Vertical Order Traversalvar verticalOrder = function(root) &#123;    if(!root) return []    const q = [[root, 0]]    const map = new Map()    while(q.length)&#123;        const [node, col] = q.shift()        if(!map.has(col)) map.set(col, [])                map.get(col).push(node.val)        if(node.left) q.push([node.left, col - 1])        if(node.right) q.push([node.right, col + 1])    &#125;    return Array.from(map.entries()).sort((a,b) =&gt; a[0] - b[0]).map((c) =&gt; c[1])&#125;;\n\nNested List Weight Sum IIvar depthSumInverse = function(nestedList) &#123;        const map = new Map()    let maxDepth = 1;    function dfs(nestedList, depth)&#123;        maxDepth = nestedList.length ? Math.max(maxDepth, depth) : maxDepth        for(let i = 0; i &lt; nestedList.length; i++)&#123;            if(nestedList[i].isInteger())&#123;                if(!map.has(depth)) map.set(depth, 0)                let val = map.get(depth)                val += nestedList[i].getInteger()                map.set(depth, val)            &#125;else&#123;                dfs(nestedList[i].getList(), depth + 1)            &#125;        &#125;    &#125;    dfs(nestedList, 1)    return Array.from(map.entries()).reduce((acc, cur) =&gt; &#123;        const [dep, sum] = cur        return acc + sum * (maxDepth - dep + 1)    &#125;, 0)&#125;;\n\nAccounts Merge\nO(E+V)var accountsMerge = function(accounts) &#123;    let adjList = new Map()    let res = [];    let visited = new Set()    // build graph    for(let i = 0; i &lt; accounts.length; i++)&#123;        for(let j = 2; j &lt; accounts[i].length; j++)&#123;            const arr1 = adjList.get(accounts[i][1]) || []            arr1.push(accounts[i][j])            adjList.set(accounts[i][1], arr1)            const arr2 = adjList.get(accounts[i][j]) || []            arr2.push(accounts[i][1])            adjList.set(accounts[i][j], arr2)        &#125;    &#125;    // check all the connected edge, add visited and push the result    function dfs(account, res)&#123;        visited.add(account)        res.push(account)        const neighbours = adjList.get(account) || []        for(neigh of neighbours)&#123;            if(!visited.has(neigh))&#123;                dfs(neigh, res)            &#125;        &#125;        return res    &#125;    // only to traverse the first account in list since the it&#x27;s been added to all the connected graph    for(let i = 0; i &lt; accounts.length; i ++)&#123;        if(!visited.has(accounts[i][1]))&#123;            const arr = dfs(accounts[i][1], [])            arr.sort()            res.push([accounts[i][0], ...arr])        &#125;    &#125;    return res&#125;;\n\nJSON.stringifyexport default function jsonStringify(value) &#123;  if(Array.isArray(value))&#123;    const arrayValue = value.map((item) =&gt; jsonStringify(item))    return `[$&#123;arrayValue.join(&#x27;,&#x27;)&#125;]`  &#125;  if(typeof value === &#x27;object&#x27; &amp;&amp; value !== null)&#123;    const objectEntries = Object.entries(value).map(([key, value]) =&gt; `&quot;$&#123;key&#125;&quot;:$&#123;jsonStringify(value)&#125;`)    return `&#123;$&#123;objectEntries.join(&#x27;,&#x27;)&#125;&#125;`  &#125;  if (typeof value === &#x27;string&#x27;)&#123;    return `&quot;$&#123;value&#125;&quot;`  &#125;  return String(value)&#125;\n\nHTML Serializerexport default function serializeHTML(element) &#123;  const indent = &#x27;\\t&#x27;  function dfs(ele, depth)&#123;    if(typeof ele === &#x27;string&#x27;)&#123;      return `$&#123;`\\t`.repeat(depth)&#125;$&#123;ele&#125;`    &#125;    return [`$&#123;indent.repeat(depth)&#125;&lt;$&#123;ele.tag.toLowerCase()&#125;&gt;`,    ...ele.children.flatMap((item) =&gt; dfs(item, depth + 1)),    `$&#123;indent.repeat(depth)&#125;&lt;/$&#123;ele.tag.toLowerCase()&#125;&gt;`,    ].join(&#x27;\\n&#x27;)  &#125;  console.log(dfs(element, 0))  return dfs(element, 0)&#125;\n\nText Searchexport default function textSearch(text, query) &#123;  if(text.trim() === &#x27;&#x27; || query.trim() === &#x27;&#x27;) return text  const boldChars =  new Array(text.length).fill(0)  for(let i = 0; i &lt; text.length; )&#123;    const substr = text.slice(i, i + query.length);    if(substr.toLowerCase() === query.toLowerCase())&#123;      boldChars.fill(1, i, i + query.length)      i = i + query.length    &#125;else&#123;      i ++    &#125;  &#125;  let hightLightedString = &#x27;&#x27;  for(let i = 0; i &lt; text.length; i++)&#123;    const shouldAddOpeningTag = boldChars[i] === 1 &amp;&amp; boldChars[i-1] !== 1;    const shouldAddClosingTag = boldChars[i] === 1 &amp;&amp; boldChars[i+1] !== 1;    let char = text[i]    if(shouldAddOpeningTag)&#123;      char = &#x27;&lt;b&gt;&#x27; + char    &#125;    if(shouldAddClosingTag)&#123;      char += &#x27;&lt;/b&gt;&#x27;    &#125;    hightLightedString += char  &#125;  return hightLightedString&#125;\n\nText Search IIexport default function textSearch(text, queries) &#123;  if(text.trim() === &#x27;&#x27; || queries.length === 0) return text  const boldChars = new Array(text.length).fill(0)  for(const query of queries)&#123;    if(query.trim() === &#x27;&#x27;) continue    for(let i = 0; i &lt; text.length; )&#123;      const subStr = text.slice(i, i + query.length)      if(subStr.toLowerCase() === query.toLowerCase())&#123;        boldChars.fill(1, i, i+query.length)        i += query.length      &#125;else&#123;        i++      &#125;    &#125;  &#125;  let res = &#x27;&#x27;  for(let i = 0; i &lt; text.length; i++)&#123;    const shouldAddOpeningTag = boldChars[i] === 1 &amp;&amp; boldChars[i-1] !== 1;    const shouldAddClosingTag = boldChars[i] === 1 &amp;&amp; boldChars[i+1] !== 1;    let char = text[i]    if(shouldAddOpeningTag) char = &#x27;&lt;b&gt;&#x27; + char    if(shouldAddClosingTag) char += &#x27;&lt;/b&gt;&#x27;    res += char  &#125;  return res&#125;\n\nEvent Emitterexport default class EventEmitter &#123;  constructor() &#123;    this.events = new Map()  &#125;  /**   * @param &#123;string&#125; eventName   * @param &#123;Function&#125; listener   * @returns &#123;EventEmitter&#125;   */  on(eventName, listener) &#123;    if(!this.events.has(eventName))&#123;      this.events.set(eventName, [])    &#125;    this.events.get(eventName).push(listener)    return this  &#125;  /**   * @param &#123;string&#125; eventName   * @param &#123;Function&#125; listener   * @returns &#123;EventEmitter&#125;   */  off(eventName, listener) &#123;    if(!this.events.has(eventName)) return this    const listeners = this.events.get(eventName)    const index = listeners.findIndex((listenerItem) =&gt; listenerItem === listener)    if(index &lt; 0) return this    listeners.splice(index, 1)    return this  &#125;  /**   * @param &#123;string&#125; eventName   * @param  &#123;...any&#125; args   * @returns &#123;boolean&#125;   */  emit(eventName, ...args) &#123;    if(!this.events.has(eventName) || this.events.get(eventName).length === 0) return false    const listeners = this.events.get(eventName).slice()    listeners.forEach((listener) =&gt; &#123;      listener.apply(null, args)    &#125;)    return true  &#125;&#125;\n\nEvent Emitterexport default class EventEmitter &#123;  constructor() &#123;    this.events = Object.create(null)    this.key = 0  &#125;  /**   * @param &#123;string&#125; eventName   * @param &#123;Function&#125; listener   * @returns &#123;&#123;off: Function&#125;&#125;   */  on(eventName, listener) &#123;    if(!Object.hasOwn(this.events, eventName)) this.events[eventName] = &#123;&#125;    const listenerId = this.key    this.events[eventName][listenerId] = listener;    this.key ++    return &#123;      off: () =&gt; &#123;        delete this.events[eventName][listenerId]      &#125;    &#125;  &#125;  /**   * @param &#123;string&#125; eventName   * @param &#123;...any&#125; args   * @returns boolean   */  emit(eventName, ...args) &#123;    if(!Object.hasOwn(this.events, eventName)|| Object.keys(this.events[eventName]).length === 0) return false    const listeners = &#123;...this.events[eventName]&#125;    Object.values(listeners).forEach((listener) =&gt; &#123;      listener.apply(null, args)    &#125;)    return true  &#125;&#125;\n\nDeep Cloneexport default function deepClone(value) &#123;  if(typeof value !== &#x27;object&#x27; || value === null)&#123;    return value  &#125;  if(Array.isArray(value))&#123;    return value.map((item) =&gt; deepClone(item))  &#125;  return Object.fromEntries(    Object.entries(value).map(([key, value]) =&gt; [key, deepClone(value)])  )&#125;\n\nSquash Objectexport default function squashObject(obj) &#123;  function squash(obj_, path, result)&#123;    for(const [key, value] of Object.entries(obj_))&#123;      if(typeof value !== &#x27;object&#x27; || value === null)&#123;        // Only reach the finally level to add the whole path and value to res        result[path.concat(key).filter(Boolean).join(&#x27;.&#x27;)] = value      &#125;else&#123;        // Otherwise keep tracking the path and pass down the result        squash(value, path.concat(key), result)      &#125;    &#125;  &#125;  const res = &#123;&#125;  squash(obj, [], res)  return res&#125;\n\n\nDebounceexport default function debounce(func, wait) &#123;  let timerID = null;  return function(...args) &#123;    const context = this;    clearTimeout(timerID);    timerID = setTimeout(function()&#123;      timerID = null;      func.apply(context, args);    &#125;, wait);  &#125;&#125;\n\nThrottleexport default function throttle(func, wait) &#123;  let shouldThrottle = false;  return function (...args)&#123;    if(shouldThrottle)&#123;      return    &#125;    shouldThrottle = true    setTimeout(function()&#123;      shouldThrottle = false;    &#125;, wait);    func.apply(this, args)  &#125;&#125;\n\nCheapest flight with K stops\nInitialize an array dp of size n to store the minimum cost to reach each city.\nSet the cost to reach the source city as 0 and all other cities’ costs as Integer.MAX_VALUE.\nIterate through each possible number of stops from 0 to k:\nCreate a copy of the dp array for each iteration.\nUpdate the minimum cost for each destination city based on the current flight.\n\n\nFinally, return the minimum cost to reach the destination city (dp[dst]).\n\nvar findCheapestPrice = function(n, flights, src, dst, k) &#123;    let dp = new Array(n).fill(Number.MAX_VALUE);    dp[src] = 0;    for (let i = 0; i &lt;= k; i++) &#123;        let temp = [...dp];        for (let flight of flights) &#123;            if (dp[flight[0]] !== Number.MAX_VALUE) &#123;                temp[flight[1]] = Math.min(temp[flight[1]], dp[flight[0]] + flight[2]);            &#125;        &#125;        dp = temp;    &#125;        return dp[dst] === Number.MAX_VALUE ? -1 : dp[dst];&#125;;\n\nFlatten Nested List Iteratorvar NestedIterator = function(nestedList) &#123;    this.stack = [];    this.beepboop(nestedList);&#125;;NestedIterator.prototype.beepboop = function(nestedList) &#123;    let n;    while (n = nestedList.pop()) &#123;        if (n.isInteger()) this.stack.push(n.getInteger());        else this.beepboop(n.getList());    &#125;&#125;;NestedIterator.prototype.hasNext = function() &#123;    return !!this.stack.length;&#125;;NestedIterator.prototype.next = function() &#123;\treturn this.stack.pop();&#125;;\n\nEvaluate Divisionvar calcEquation = function(equations, values, queries) &#123;    const adjList = new Map();        // Initialize the graph    for (let i = 0; i &lt; equations.length; i++) &#123;        adjList.set(equations[i][0], []);        adjList.set(equations[i][1], []);    &#125;    // Build the graph    for (let i = 0; i &lt; equations.length; i++) &#123;        const u = equations[i][0];        const v = equations[i][1];        const weight = values[i];                // u to v        adjList.get(u).push([v,weight]);                // v to u        adjList.get(v).push([u, 1/weight]);    &#125;        // Initialize results array    const res = [];        for (let i = 0; i &lt; queries.length; i++) &#123;        // divisor        const src = queries[i][0];                // dividend        const dest = queries[i][1];        const seen = new Set();        const val = dfs(adjList, src, src, dest, 1, seen);                        if (val === false) &#123;            res.push(-1);        &#125; else &#123;            res.push(val);        &#125;    &#125;        return res;&#125;// In the case that there are other multiple valid paths from source to destination, ultimately, the quotient is the same// returning the first then works.var dfs = function(adjList, src, curr, dest, quotient, seen) &#123;    //destination or source is non existent    if (!adjList.has(dest) || !adjList.has(src)) &#123;        return -1;    &#125;        //source is same as destination i.e. self-loop.    if (src === dest) &#123;        return 1;    &#125;        // Reached destination    if (curr === dest) &#123;        return quotient;    &#125;        seen.add(curr);        const neighbors = adjList.get(curr);        for (let i = 0; i &lt; neighbors.length; i++) &#123;        if (seen.has(neighbors[i][0])) &#123;            continue;        &#125;        const val = dfs(adjList, src, neighbors[i][0], dest, quotient * neighbors[i][1], seen);        // if any value was found we return because        // the only other cases would be having a cycle, or reaching our destination or path.        if (val !== false) return val;    &#125;        // We only return false if we&#x27;ve searched all neighbors and there&#x27;s no path to destination    // however we know that src and dest are in adjList    // thus it may just be disconnected, but this may return from different levels of recursion.    return false;&#125;\n\nEdit Distancevar minDistance = function(word1, word2) &#123;    //  dp[i][j] := min # Of operations to convert word1[0..i) to word2[0..j)    let dp = Array(word1.length+1).fill(null).map(()=&gt;(Array(word2.length+1).fill(0)));    for (let i=0;i&lt;dp.length;i++) &#123;        dp[i][0] = i    &#125;    for (let i=0;i&lt;dp[0].length;i++) &#123;        dp[0][i] = i    &#125;    for (let i = 1;i&lt;dp.length;i++) &#123;        for (let j=1;j&lt;dp[0].length;j++) &#123;            if(word1[i-1] === word2[i-1])&#123;                dp[i][j] = dp[i-1][j-1]            &#125;else&#123;                dp[i][j] = Math.min(                            dp[i-1][j]+1, // left                            dp[i][j-1]+1, // right                            dp[i-1][j-1] + 1 // diagonal                        );            &#125;                    &#125;    &#125;    return dp[dp.length-1][dp[0].length-1];&#125;;\n\nSearch a 2D Matrix II\nCheck for empty matrix.\nInitialize pointers for rows and columns.\nStart from the top-right corner.\nIterate through the matrix:\nCheck if the current element equals the target.\n Move down or left based on the comparison result.\n\n\n Return false if the target is not found.\nvar searchMatrix = function(matrix, target) &#123;\t// Start from the top-right corner    let i = 0;    let j = matrix[0].length - 1;    while (j &gt;= 0 &amp;&amp; i &lt; matrix.length) &#123;        if (matrix[i][j] === target)            return true;        if (j - 1 &gt;= 0 &amp;&amp; matrix[i][j - 1] &lt; target) &#123;            i++;        &#125; else &#123;            if (j - 1 &lt; 0)                i++;            else                j--;        &#125;    &#125;    return false;&#125;;\nSearch in Rotated Sorted Arrayvar search = function(nums, target) &#123;    if(nums.length === 0) return -1    let l = 0, r = nums.length - 1;    while(l &lt;= r)&#123;        const mid = Math.floor((l + r) / 2)        if(nums[mid] === target)&#123;            return mid        &#125;        if(nums[0] &lt;= nums[mid])&#123;            if(nums[0] &lt;= target &amp;&amp; target &lt; nums[mid])&#123;                r = mid - 1            &#125;else&#123;                l = mid + 1            &#125;        &#125;else&#123;            if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[nums.length - 1])&#123;                l = mid + 1            &#125;else&#123;                r = mid - 1            &#125;        &#125;    &#125;    return -1&#125;;\n\n153. Find Minimum in Rotated Sorted Arrayvar findMin = function(nums) &#123;    let l = 0, r = nums.length - 1    while(l &lt; r)&#123;        const mid = Math.floor(l + (r - l)/ 2)        if(nums[mid] &lt; nums[r])&#123;            r = mid        &#125;else&#123;            l = mid + 1        &#125;    &#125;    return nums[l]&#125;;\n\n数组和字符串1.两数之和 Two Sumlink\n\nbrute force\n\nn = len(nums)for i in range(n):    for j in range(i+1, n):        if nums[i] + nums[j] == target:            return [i, j]return []\n\n哈希表解决target-x问题table = &#123;&#125;for idx, num in enumerate(nums):    if target-num in table:        return [table[target-num], idx]    else:        table[nums[idx]] = idxreturn []\n\n3.无重复子串的最长字符串 Longest substring without repeating characterslink：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n\n滑动窗口，哈希记录出现字符的下标\nO(n)class Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        k, res = -1, 0        table = &#123;&#125;        for ix, char in enumerate(s):            if char in table and table[char] &gt; k:                k = table[char] # 定位到重复字符的下标作为字符串起始idx                table[char] = ix # 更新字符下标            else:                table[char] = ix                res = max(res, ix-k)        return res\n\n4.寻找两个有序数组的中位数 median of two sorted arrayslink: https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\n\n说实话，还没看懂题解class Solution:    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        if len(nums1) &gt; len(nums2):            return self.findMedianSortedArrays(nums2, nums1)        infinty = 2**40        m, n = len(nums1), len(nums2)        left, right = 0, m        # median1：前一部分的最大值        # median2：后一部分的最小值        median1, median2 = 0, 0        while left &lt;= right:            # 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]            # // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]            i = (left + right) // 2            j = (m + n + 1) // 2 - i            # nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]            nums_im1 = (-infinty if i == 0 else nums1[i - 1])            nums_i = (infinty if i == m else nums1[i])            nums_jm1 = (-infinty if j == 0 else nums2[j - 1])            nums_j = (infinty if j == n else nums2[j])            if nums_im1 &lt;= nums_j:                median1, median2 = max(nums_im1, nums_jm1), min(nums_i, nums_j)                left = i + 1            else:                right = i - 1        return (median1 + median2) / 2 if (m + n) % 2 == 0 else median1\n\n11.盛最多水的容器 container with most waterlink: https://leetcode-cn.com/problems/container-with-most-water/\n\n经典面试题，双指针法 O(n)\n左右指针分别定位在数组头部和尾部，移动数值较小一端\n理解该方法的正确性class Solution:    def maxArea(self, height: List[int]) -&gt; int:        left, right = 0, len(height) - 1        res = 0        while left &lt; right:            area = (right - left) * min(height[left], height[right])            res = max(res, area)            if height[left] &lt;= height[right]:                left += 1            else:                right -= 1        return res\n\n13.罗马数字转整数\n考虑到罗马数字的特性，一开始使用了双指针（但其实没必要）O(n)\n用字典存储数值，每次比较，只需要对slow index的数值进行操作，return之前记得把最后一个数值加上\n纯粹自己的解法class Solution:    def romanToInt(self, s: str) -&gt; int:        roman = &#123;&quot;I&quot;:1,&quot;V&quot;:5, &quot;X&quot;: 10, &quot;L&quot;:50, &quot;C&quot;:100, &quot;D&quot;:500, &quot;M&quot;: 1000&#125;        s = list(s)        if len(s) == 1:            return roman[s[0]]        res = 0        for i in range(len(s)-1):            if roman[s[i+1]] &lt;= roman[s[i]]:                res += roman[s[i]]            else:                res -= roman[s[i]]        res += roman[s[-1]]        return res\n\n12.整数转罗马数字\n和罗马数字表达特性有关， 字典存储， 固定组合 O(n)\n尽可能选择最大的数值，字典存储数值与字符对， list append相应的字符class Solution:    def intToRoman(self, num: int) -&gt; str:        dic = [            (1000, &quot;M&quot;),(900, &quot;CM&quot;),(500, &quot;D&quot;), (400, &quot;CD&quot;),(100, &quot;C&quot;), (90, &quot;XC&quot;),(50, &quot;L&quot;), (40, &quot;XL&quot;),(10, &quot;X&quot;), (9, &quot;IX&quot;), (5, &quot;V&quot;), (4, &quot;IV&quot;), (1, &quot;I&quot;)        ]        roman = []        for value, symbol in dic:            while num &gt;= value:                num -= value                roman.append(symbol)            if num == 0:                break        return &quot;&quot;.join(roman)\n\n49.字母异位词分组\n实际上调用了python里的包 collections\ncollections.defaultdict(list) 返回一个空的dict，里面的value为空的list类型\n字母异位词包含的字符一样，所以sorted之后返回的list都是一样的\n以sorted之后的str‘为key，而str则append进相应的value‘\n注意返回的时候 list(mp.values())， values返回一个iterable类型class Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        mp = collections.defaultdict(list)        for st in strs:            key = &quot;&quot;.join(sorted(st))            mp[key].append(st)        return list(mp.values())\n\n48.旋转图像\n水平翻转 + 主对角线翻转 (注意坐标的改变规律以及两层循环的不同)\nO(n^2) class Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify matrix in-place instead.        &quot;&quot;&quot;        n = len(matrix[0])        # 水平翻转（限制 i 的遍历范围）        for i in range(n // 2):            for j in range(n):                matrix[i][j], matrix[n - i - 1][j]  = matrix[n - i - 1][j], matrix[i][j]        # 主对角线翻转（限制j的遍历范围）        for i in range(n):            for j in range(i):                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]        \n\n15.三数之和 3sum\n双指针 + 排序\n去重逻辑比较复杂 循环开始前需要去重，找到满足条件的一个三元组之后需要去重\n边界例子： 如果第一个指针指向的数已经大于0，直接返回res；去重结束之后同样需要收缩两个边界指针class Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        res = []        n = len(nums)        nums = sorted(nums)        for i in range(n):            left = i + 1            right = n - 1            # 边界条件，节省时间            if nums[i] &gt; 0:                return res            # 循环前去重            if i &gt; 0 and nums[i] == nums[i - 1]:                continue            while left &lt; right:                total = nums[i] + nums[left] + nums[right]                if total &gt; 0:                    right -= 1                elif total &lt; 0:                    left += 1                else:                    res.append([nums[i],nums[left],nums[right]])                    # 找到正确答案后去重                    while left &lt; right and nums[right-1] == nums[right]:                        right -= 1                    while left &lt; right and nums[left+1] == nums[left]:                        left += 1                    # 找到正确答案后边界条件同时收缩                    right -= 1                    left += 1        return res     \n\n16.最接近的三数之和 3sum closet\n大致思路和上题一样 排序+双指针\n细节：res先设置成最大值；循环前去重；找到答案后去重（顺序）\n\nclass Solution:    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:        res = 10**7        n = len(nums)        # 排序        nums = sorted(nums)        for i in range(n):            # 循环前去重            if i &gt; 0 and nums[i-1] == nums[i]:                continue            # 因为此处是寻找与目标值最接近的总和，这里就不能通过判断第一位大于target而中止循环            left = i + 1             right = n - 1            while left &lt; right:                total = nums[i] + nums[left] + nums[right]                if abs(total - target) &lt;= abs(res - target):                    res = total                # 注意更新结果后的去重的顺序，去重再收缩边界                if total &lt; target:                    while left &lt; right and nums[left + 1] == nums[left]:                        left += 1                    left += 1                elif total &gt; target:                    while left &lt; right and nums[right - 1] == nums[right]:                        right -= 1                    right -= 1                else:                    return target        return res\n\n28.实现strStr（kmp算法）\nkmp算法需要多复习，关键在于next数组的构建，文本串和字符串匹配的过程 O(n+m)class Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        # 如果模式串为空，则返回0（在面试中可以问这个问题）        if needle == &quot;&quot;:            return 0        # 构建空next数组        nex = [0] * len(needle)        def findnext(nex:List[int], s:str):            # 初始化j为前缀起始，            j = -1            nex[0] = j            # i为后缀起始，定位为1            for i in range(1, len(s)):                while j &gt;= 0 and s[i] != s[j+1]: # 前后缀不同                    # 找j+1前一个元素在next里的值，赋值给j                    j = nex[j]                if s[i] == s[j+1]: # 前后缀相同                    # 指针往后移动                    j += 1                # 赋值到相应的后缀next数值中                nex[i] = j            return nex        # 构建模式串的next数组        Next = findnext(nex, needle)        j = -1        # 此处的i定位在文本串起始处 为0        for i in range(len(haystack)):            while j &gt;= 0 and haystack[i] != needle[j+1]:                j = Next[j]            if haystack[i] == needle[j+1]:                j += 1            if j == len(needle) - 1:                return (i - len(needle) + 1)        return -1\n\n8.字符串转换整数\n不太知道为什么美区企业题库里有这道题，但还是得硬着头皮做\n题解是用有限状态机写的，不使用ifelse来判断\n实际上得考虑边界条件，就当是练习一下怎么用python写class了INT_MAX = 2**31 -1INT_MIN = -2**31class Dfa:    def __init__(self):        self.state = &#x27;start&#x27;        self.sign = 1        self.ans = 0        # 关键是这个状态转换表，把表画出来之后就很容易了        self.table = &#123;            &#x27;start&#x27;: [&#x27;start&#x27;, &#x27;signed&#x27;, &#x27;in_num&#x27;, &#x27;end&#x27;],            &#x27;signed&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_num&#x27;, &#x27;end&#x27;],            &#x27;in_num&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_num&#x27;, &#x27;end&#x27;],            &#x27;end&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;]        &#125;    # 根据输入的字符和当前状态寻找下一转换状态    def get_col(self,c):        if c.isspace():            return 0        if c == &#x27;+&#x27; or c == &#x27;-&#x27;:            return 1        if c.isdigit():            return 2        return 3    # 只有其中两个状态的时候才需要改变，判断边界条件    def get(self, c):        self.state = self.table[self.state][self.get_col(c)]        if self.state == &quot;in_num&quot;:            self.ans = self.ans * 10 + int(c)            if self.sign == 1:                self.ans = min(self.ans, INT_MAX)            else:                self.ans = min(self.ans, -INT_MIN)        elif self.state == &quot;signed&quot;:            if c == &quot;+&quot;:                self.sign = 1            else:                self.sign = -1class Solution:    def myAtoi(self, s: str) -&gt; int:        dfa = Dfa()        for c in s:            dfa.get(c)        return dfa.sign * dfa.ans\n\n937.重新排列日志\n简单来说 就是熟练运用内置方法的一道题\nsorted，再写一个函数返回排序的keyclass Solution:    def reorderLogFiles(self, logs: List[str]) -&gt; List[str]:        def get_key(log):            id_, rest = log.split(&quot; &quot;, maxsplit=1)            if rest[0].isalpha():                return (0, rest, id_)            else:                return(1, )        return sorted(logs, key=get_key)\n\n42.接雨水\n双指针 O(n) 定义left和right指针 进行判断\n每次使用leftmax和rightmax来更新两边的最大值\n若有height[left] &lt; height[right]，则会有leftmax &lt; rightmax,下标left处能接的雨水量=leftmax - height[left]（因为此时左边界为最低的盛水高度\n反之同理，可画图演示class Solution:    def trap(self, height: List[int]) -&gt; int:        res = 0        left, right = 0, len(height)-1        leftmax = rightmax = 0        while left &lt; right:            leftmax = max(leftmax, height[left])            rightmax = max(rightmax, height[right])            if height[left] &lt; height[right]:                res += leftmax - height[left]                left += 1                        else:                res += rightmax - height[right]                right -= 1        return res\n\n76.最小覆盖子串\n双指针滑动窗口，只要字符个数和总数还不符合要求，右指针则继续滑动，符合要求后，左指针收缩\n记得及时记录窗口的长度class Solution:    def minWindow(self, s: str, t: str) -&gt; str:        from collections import Counter        if not s or not t:            return &quot;&quot;        char_count = Counter(t) # each char needed        windows_count = &#123;&#125; # saved the char in the s string        ans = (float(&quot;INF&quot;), None, None) # save the length, left index and right        formed = 0 # if an char was satisfied, formed add 1        needed_form = len(char_count) # compare with form        l, r = 0, 0        while r &lt; len(s):            character = s[r]            windows_count[character] = windows_count.get(character, 0) + 1            if character in char_count and windows_count[character] == char_count[character]:                formed += 1                        while formed == needed_form and l &lt;= r:                character = s[l]                if r - l + 1 &lt; ans[0]:                    ans = (r - l + 1, l, r)                windows_count[character] -= 1                if character in char_count and windows_count[character] &lt; char_count[character]:                    formed -= 1                                l += 1                        r += 1                if ans[0] == float(&quot;INF&quot;):            return &quot;&quot;        else:            return s[ans[1]:ans[2]+1]\n\n165.比较版本号\n比较简单 O(m+n)class Solution:    def compareVersion(self, version1: str, version2: str) -&gt; int:        l_v1 = version1.split(&quot;.&quot;)        l_v2 = version2.split(&quot;.&quot;)                n_v1 = len(l_v1)        n_v2 = len(l_v2)        for i in range(n_v1):            l_v1[i] = int(l_v1[i])                for i in range(n_v2):            l_v2[i] = int(l_v2[i])        p = 0        while p &lt; n_v1 and p &lt; n_v2:            if l_v1[p] &gt; l_v2[p]:                return 1            elif l_v1[p] &lt; l_v2[p]:                return -1            p += 1        if n_v2 == n_v1:            return 0                while p &lt; n_v1: # len(v1) &gt; len(v2)            if l_v1[p] &gt;= 1:                return 1            p += 1        while p &lt; n_v2:            if l_v2[p] &gt;= 1:                return -1            p += 1        return 0\n\n238.除自身以外数组的乘积\n两个数组存每个数左边以及右边的乘积， 再遍历相乘对应的位置 O(n)class Solution:    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:        n = len(nums)        ans = [1] * n        left = [1] * n        right = [1] * n                for i in range(n-1):            right[i+1] = nums[i] * right[i]                    for i in range(n-1,0,-1):            left[i-1] = nums[i] * left[i]                    for i in range(n):            ans[i] = left[i] * right[i]        return ans\n\n268.丢失的数字\n数学解法，求和公式-sum（nums）差值就是缺少的那一个class Solution:    def missingNumber(self, nums: List[int]) -&gt; int:        n = len(nums)        total = n * (n + 1) // 2        arrsum = sum(nums)        return total - arrsum\n\n链表2. 两数相加*注意进位问题\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        node1, node2 = l1, l2        res = cur = ListNode()        carry = v = 0        while node1 or node2:            if node1 and node2:                v = node1.val + node2.val + carry                node1 = node1.next                node2 = node2.next            elif node1 == None:                v = node2.val + carry                node2 = node2.next            else: # node2 == None                v = node1.val + carry                node1 = node1.next                        carry, v = divmod(v, 10)            cur.next = ListNode(v)            cur = cur.next                if carry:            cur.next = ListNode(1)        return(res.next)\n\n138.复制带随机指针的链表\n方法很巧妙，第一次遍历时 复制每个节点，并插入到旧节点的后面\n第二次遍历的时候改变新节点的random指向，但这里很关键，指向不能为random，而为random.next，因为复制了新的节点\nO(n)&quot;&quot;&quot;# Definition for a Node.class Node:    def __init__(self, x: int, next: &#x27;Node&#x27; = None, random: &#x27;Node&#x27; = None):        self.val = int(x)        self.next = next        self.random = random&quot;&quot;&quot;class Solution:    def copyRandomList(self, head: &#x27;Optional[Node]&#x27;) -&gt; &#x27;Optional[Node]&#x27;:        if not head:            return head                # 对节点进行复制并插入到链表中        cur = head        while cur:            new_node = Node(cur.val, None, None)            new_node.next = cur.next            cur.next = new_node            cur = cur.next.next                # 改变新节点的random值        cur = head        while cur:            if cur.random: # 不存在则指向空                cur.next.random = cur.random.next # 这里很关键            else:                cur.next.random = None            cur = cur.next.next                # 新旧链表各一个指针，再加一个需要返回的新链表的头指针        old_list = head        new_list = head.next        new_head = head.next        while old_list:            old_list.next = old_list.next.next            if new_list.next: # 若新链表中还有next，表明下一个还非空（画图可知）                new_list.next = new_list.next.next            else:                new_list.next = None            old_list = old_list.next            new_list = new_list.next        return new_head\n\n21.合并两个有序链表\n基本思想和上题一样\n注意对链表空或非空的判断，注意移动cur指针# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        res = cur = ListNode()        node1, node2 = list1, list2        while node1 or node2:            if node1 and node2:                if node2.val &gt;= node1.val:                    cur.next = ListNode(node1.val)                    node1 = node1.next                else:                    cur.next = ListNode(node2.val)                    node2 = node2.next            elif node1 == None:                cur.next = node2                node2 = node2.next            else: # node2 == None                cur.next = node1                node1 = node1.next            cur = cur.next        return res.next\n\n206.反转链表\n三个指针，pre cur next 实现O(n)\n先定义pre为空，返回pre指针# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def reverseList(self, head: ListNode) -&gt; ListNode:        if not head or not head.next:            return head                    cur = head        pre = None        while cur:            next = cur.next            cur.next = pre            pre = cur            cur = next        return pre \n\n25.k个一组翻转链表\nO(n)# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    # 这个函数的操作是用来翻转k范围内的节点，操作和翻转节点很相似    def reverseNode(self, head:ListNode, tail:ListNode):        # pre定义在tail的next原因是子链表的头翻转后要指向它        pre = tail.next        cur = head        # 所以这里的判断条件是，pre指针没有到链表区间范围尾端的tail指针        while pre != tail:            next = cur.next            cur.next = pre            pre = cur            cur = next        # 原来的tail成为新的head        return tail, head    def reverseKGroup(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:        # 新建一个空的头指针        hair = ListNode(0)        # 指向原来的head        hair.next = head        # 定位pre指针        pre = hair        while head:            tail = pre            # tail用来计算是否有足够的翻转空间            for i in range(k):                tail = tail.next                if not tail: # 如果剩下的不够翻转，直接返回                    return hair.next            # 保存tail.next 用于连接翻转后的子链表            nex = tail.next            head, tail = self.reverseNode(head, tail)            pre.next = head            tail.next = nex            # 只需移动pre和head指针，tail和nex指针每次都根据head的位置移动            pre = tail            head = tail.next                return hair.next\n\n23.合并k个升序链表\n优先队列，其实相当于四个指针\nimport heapq， heapq需要用list来作为item的载体，同时压入排序的key，以及下一个检索的idx（heapq不能直接压入node，只能压入node在list中的idx，用于下次寻找）\ntime:O(nlogk) space: queue:O(k) linked_list:O(n)# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        import heapq        head = cur = ListNode(0)        q = []        for i in range(len(lists)):            if lists[i]: # 很重要，如果是空节点则不能放进队列里，有可能有空节点（k个节点）                heapq.heappush(q,(lists[i].val, i))                lists[i] = lists[i].next                while q:            val, idx = heapq.heappop(q)            cur.next = ListNode(val)            cur = cur.next            if lists[idx]: # 同样的判断是否下个节点需要放进队列中                heapq.heappush(q, (lists[idx].val, idx))                lists[idx] = lists[idx].next                return head.next\n\n二叉树和图200.岛屿数量\n记住成为岛屿的条件，利用深度搜索对方格周围的四个方格进行搜索 O(mn)\n各种小细节，进入dfs之前记得岛屿数量增加；进入dfs后，搜索要加上边界限定条件class Solution:    def dfs(self, grid, r, c):        # 搜索过的方格需要进行置0        grid[r][c] = &quot;0&quot;        nr = len(grid)        nc = len(grid[0])        # dfs内的dfs只需要搜索相应的四个方格        for x,y in [(r-1, c), (r + 1, c), (r, c-1), (r, c+1)]:            # 因为此处循环没有边界限定所以要加上判断条件，防止越界            if 0&lt;= x &lt; nr and 0 &lt;= y &lt; nc and grid[x][y] == &quot;1&quot;:                self.dfs(grid, x, y)    def numIslands(self, grid: List[List[str]]) -&gt; int:        nr = len(grid)        # 判断输入为空的情况        if nr == 0:            return 0        nc = len(grid[0])        res = 0        for x in range(nr):            for y in range(nc):                # 在这层循环中，只要为1则进行dfs                if grid[x][y] == &quot;1&quot;:                    res += 1                    self.dfs(grid, x, y)        return res\n\n98.验证二叉搜索树\n利用二叉搜索树的特性，中序搜索是升序\n因为input中有最小值，需要全局最小化一个max值\n递归判断节点的左右子树，只有同时为真才为真# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def isValidBST(self, root: TreeNode) -&gt; bool:        # 全局最小值        cur_max = -float(&quot;INF&quot;)        def _isvalidbst(root: TreeNode):            # 全局变量            nonlocal cur_max            # 此处处理空节点的情况            if not root:                return True                        # 中序遍历            is_left = _isvalidbst(root.left)            if cur_max &lt; root.val:                cur_max = root.val            else:                return False                        is_right = _isvalidbst(root.right)            # 同时为真才为真            return is_left and is_right        return _isvalidbst(root)\n\n101.对称二叉树\n实际上这里没有严格用到二叉树的几种遍历方式，因为对称需要对比的是外侧和里侧\n使用递归，比较外侧：传入左子树的左孩子，右子树的右孩子；比较里侧：传入左子树的右孩子，右子树的左孩子# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def isSymmetric(self, root: TreeNode) -&gt; bool:        # 考虑根节点为空的情况        if not root:            return True        return self.compare(root.left, root.right)        def compare(self, left, right):        # 节点为空的情况        if left == None and right != None:            return False        elif right == None and left != None:            return False        elif right == None and left == None:            return True        # 节点不空但是val不同        elif right.val != left.val:            return False        # 节点不空且val相同，才可以继续递归        outside = self.compare(left.left, right.right)        inside = self.compare(left.right, right.left)        #两边同时为真才能为真        same = outside and inside        return same\n\n102.二叉树的层序遍历\n使用先进先出队列，迭代法实现层序遍历\ncollections.deque# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        # 判断节点是否为空        if not root:            return []                # 队列需要用list来做容器，初始化一个存放了root的deque        results = []        q = collections.deque([root])        while q:            size = len(q)            result = []            for i in range(size):                node = q.popleft()                result.append(node.val)                if node.left:                    q.append(node.left)                if node.right:                    q.append(node.right)            results.append(result)        return results\n\n103.二叉树的锯齿形层序遍历\n我的做法 102的层序遍历+标记位反转 O(n)，每个节点仅被遍历一次\n可以使用双端队列 从左端取出的孩子节点从右端压入，从右端取出的孩子节点再从左端压入，且左孩子和右孩子的压入先后有细小差别# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root:            return []                q = collections.deque([root])        results = []        # 标记位        direc = 1 # pop from left, append to right        while q:            size = len(q)            result = []            for i in range(size):                # 从左边取出                if direc % 2 == 1:                    node = q.popleft()                    result.append(node.val)                    # 右边先压入左孩子                    if node.left:                        q.append(node.left)                    if node.right:                        q.append(node.right)                # 从右边取出                if direc % 2 != 1:                    node = q.pop()                    result.append(node.val)                    # 从左边心压入右孩子                    if node.right:                        q.appendleft(node.right)                    if node.left:                        q.appendleft(node.left)            results.append(result)            # 改变标志位            direc += 1        return results\n\n124.二叉树中的最大路径和\n有点像后序遍历，注意细节，O(n)# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def maxPathSum(self, root: Optional[TreeNode]) -&gt; int:        maxsum = -float(&quot;INF&quot;)        def maxgain(node):            nonlocal maxsum            # 注意对空节点（叶子节点）的处理            if not node:                return 0            # 只有大于0的路径才纳入考虑            leftgain = max(maxgain(node.left), 0)            rightgain = max(maxgain(node.right), 0)            new_path = node.val + leftgain + rightgain            # 每次更新路径最大值            maxsum = max(new_path, maxsum)            # 只返回最大的一边路径，因为每个节点在路径中出现一次            # 想象一下假如返回一个节点的右子树和右子树，相当于节点被访问了两次，不符合题目要求            return node.val + max(leftgain, rightgain)        maxgain(root)        return maxsum \n\n236.二叉树的最近公共祖先\n后序遍历（回溯），找到节点之后还是要遍历整棵树\n需要理解的地方比较多，题目说p和q一定会存在，不需要考虑找不到的情况，就算这里找不到，返回的也是null# Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        # 假设找到相等的节点则立即返回        if not root or p == root or q == root:            return root                left = self.lowestCommonAncestor(root.left, p, q)        right = self.lowestCommonAncestor(root.right, p, q)        # 如果left和right同时为真，则代表此节点为最近的公共祖先        if left and right:            return root        # 可能是left的这个节点是她们的祖先，也有可能还没找到另一个孩子节点        elif left:            return left        return right\n\n543.二叉树的直径\n实际上就是二叉树的最长路径，做法类似124最大路径和\n稍微改动数值则可以ac，# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:        longest_sum = -float(&quot;INf&quot;)        def findlong(node):            # 遍历到叶子节点则返回0            if not node:                return 0            nonlocal longest_sum            # 寻找左孩子的最长路径            left = findlong(node.left)            # 寻找右孩子的最长路径            right = findlong(node.right)            # 最长路径更新时需要考虑两个孩子的最长路径            longest_sum = max(left+right, longest_sum)            # 而递归函数返回的时其最大的孩子路径+1            return max(left, right)+1        findlong(root)        return longest_sum\n\n733.图像渲染\n图的dfs，和小岛的数量题目很像\n注意一点是若old color和new color一样，则不需要进行递归，不然会超时class Solution:    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -&gt; List[List[int]]:                        def changecolor(image, r, c, old_color, newcolor):            image[r][c] = newcolor            nr = len(image)            nc = len(image[0])            for x,y in [(r,c+1), (r, c-1), (r+1, c), (r-1, c)]:                if 0 &lt;= x &lt; nr and 0 &lt;= y &lt; nc and image[x][y] == old_color:                    changecolor(image, x, y, old_color, newcolor)                                old_color = image[sr][sc]        if old_color == newColor:            return image        changecolor(image, sr, sc, old_color, newColor)        return image\n\n动态规划5.最长回文子串\n动态规划 O(n^2)\n注意边界条件的处理：字符串长度为1时，字符串长度只有2时（两个字母不同，需要返回任何一个字符）\n枚举子串长度，枚举左边界从而计算右边界/两个情况s[i] != s[j]，当字符相同时要分为两种子情况讨论class Solution:    def longestPalindrome(self, s: str) -&gt; str:        n = len(s)        # 边界条件        if n &lt; 2:            return s        # 初始化dp以及base case        dp = [[False]*n for _ in range(n)]        for i in range(n):            dp[i][i] = True        # 若没找到最长的回文串，返回首字符（很重要！        max_length = 1        begin_index = 0                # 枚举字符串长度（上限的设定）        for L in range(2, n+1):            # 左边界            for i in range(n):                j = L + i - 1                # 右边界判断是否越界                if j &gt;= n:                    break                if s[i] != s[j]:                    dp[i][j] = False                else:                    if j - i &lt; 3: # 字符串长度小于4时                        dp[i][j] = True                    else:                        # 两边字符相同时，但查表找中心处是否为回文                        dp[i][j] = dp[i+1][j-1]                # 更新index和最大长度                if dp[i][j] and j - i + 1 &gt; max_length:                    begin_index = i                    max_length = j - i + 1                # 左闭右开        return s[begin_index:begin_index+max_length] \n\n排序和查找215.数组中的第k个最大元素\nheapq，只要压入的元素超过k个则pop出来 循环完成后的堆顶元素则是目标元素class Solution:    def findKthLargest(self, nums: List[int], k: int) -&gt; int:        import heapq        q  = []        len_q = 0        for i in range(len(nums)):            heapq.heappush(q, nums[i])            len_q += 1            while len_q &gt; k:                num = heapq.heappop(q)                len_q -= 1        return heapq.heappop(q)\n\n56.合并区间\n先对区间进行排序，对数组的start和end进行判断\n只要答案list为空或者两个区间不重叠，则进行append\n重叠的区间，end要进行max判断 e.g.[[1,4],[2,3]]class Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x: x[0])        res = []        for i in range(len(intervals)):            if not res or intervals[i][0] &gt; res[-1][1]:                res.append(intervals[i])            else:                res[-1][1] = max(intervals[i][1],res[-1][1])        return res\n\n347.前k个高频元素\n用字典， heapq进行排序 O(nlogk)class Solution:    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:        dict_n = &#123;&#125;        import heapq        q = []        len_q = 0        res = []        for i in range(len(nums)): # O(n)            dict_n[nums[i]] = dict_n.get(nums[i], 0) + 1        for key in dict_n:            if len_q == k:                v, num = heapq.heappop(q)                if v &lt; dict_n[key]:                    heapq.heappush(q,(dict_n[key],key))                else:                    heapq.heappush(q,(v,num))            elif len_q &lt; k:                heapq.heappush(q,(dict_n[key],key))                len_q += 1        for _ in range(len(q)):            v,num = heapq.heappop(q)            res.append(num)                return res\n\n973.k个最接近原点的点\n负数存储在heapq里，因为需要找到距离最小的点，而距离最小的点取负数之后会变大class Solution:    def kClosest(self, points: List[List[int]], k: int) -&gt; List[List[int]]:        import heapq        q= []        res = []        len_q = 0        for i in range(len(points)):            dis = -(points[i][0] ** 2 + points[i][1] ** 2)            if len_q &lt; k:                heapq.heappush(q,(dis, points[i]))                len_q += 1            elif len_q == k:                d, p = heapq.heappop(q)                if dis &gt; d:                    heapq.heappush(q, (dis, points[i]))                else:                    heapq.heappush(q, (d, p))        for _ in range(len_q):            d, p = heapq.heappop(q)            res.append(p)        return res\n\n253.会议室II\n按开始时间排序，最小堆存入前一个会议的结束时间，与下一个会议的开始时间比较\n如果不overlap，就pop出上一个会议（表示空出会议室让给下一个会议），压入下一个会议结束时间class Solution:    def minMeetingRooms(self, intervals: List[List[int]]) -&gt; int:        import heapq        if not intervals:            return 0                free_room = []        intervals.sort(key=lambda x: x[0]) # sort by the meeting start time        heapq.heappush(free_room, intervals[0][1])        for i in intervals[1:]:            if free_room[0] &lt;= i[0]: # 如果前一个会议的结束时间早于当下会议的开始时间，则把这间会议室安排给当下会议                heapq.heappop(free_room)                        heapq.heappush(free_room, i[1])        return len(free_room)\n\n33.Search in Rotated Sorted Array 搜索旋转排序数组\n二分查找，先判断哪个区间为有序区间，通过这个来判断target值是否在有序区间内，在则搜索这个区间，否则搜索另一个区间class Solution:    def search(self, nums: List[int], target: int) -&gt; int:        if not nums:            return -1                l, r = 0, len(nums) - 1        while l &lt;= r:            mid = (l + r) // 2            if nums[mid] == target:                return mid                        if nums[0] &lt;= nums[mid]: # 0-mid-1 为有序的                if nums[0] &lt;= target &lt; nums[mid]:                    r = mid - 1 # 因为mid指针已经比较过，所以不需要再比较，同上的区间比较也是                else:                    l = mid + 1                            else:                if nums[mid] &lt; target &lt;= nums[len(nums)-1]:                    l = mid + 1                else:                    r = mid - 1        return -1\n\nvar search = function(nums, target) &#123;    if(nums.length === 0) return -1    let l = 0, r = nums.length - 1;    while(l &lt;= r)&#123;        const mid = Math.floor((l + r) / 2)        if(nums[mid] === target)&#123;            return mid        &#125;        if(nums[0] &lt;= nums[mid])&#123;            if(nums[0] &lt;= target &amp;&amp; target &lt; nums[mid])&#123;                r = mid - 1            &#125;else&#123;                l = mid + 1            &#125;        &#125;else&#123;            if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[nums.length - 1])&#123;                l = mid + 1            &#125;else&#123;                r = mid - 1            &#125;        &#125;    &#125;    return -1&#125;;\n\n153. Find Minimum in Rotated Sorted Arrayvar findMin = function(nums) &#123;    let l = 0, r = nums.length - 1    while(l &lt; r)&#123;        const mid = Math.floor(l + (r - l)/ 2)        if(nums[mid] &lt; nums[r])&#123;            r = mid        &#125;else&#123;            l = mid + 1        &#125;    &#125;    return nums[l]&#125;;\n\n167.两数之和II\n哈希表法 时间O(n) 空间O(n)\n双指针法 O(n) 空间O(1) 利用了数组的有序性\n并且留意题目是1-indexed数组，最后返回都要按顺序返回index并且+1\n\n哈希表解法class Solution:    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:        dict_n = &#123;&#125;        if not numbers:            return []                for i in range(len(numbers)):            if target - numbers[i] not in dict_n:                dict_n[numbers[i]] = i            else:                if i + 1 &lt; dict_n[target - numbers[i]] + 1:                    return [i+1, dict_n[target - numbers[i]]+1]                else:                    return [dict_n[target - numbers[i]]+1, i+1]        return []\n\n双指针设计146.LRU缓存\n使用双向链表和哈希表进行实现\n对put和get都是O(1)class DoublelinkNode:    # 双向链表的结构，记得初始化key和value，否则建立虚拟节点的时候会报错    def __init__(self, key=0, val=0):        self.key = key        self.val = val        self.next = None        self.pre = Noneclass LRUCache:    def __init__(self, capacity: int):        # 整个lru的容量，实际使用量，以及字典        self.capacity = capacity        self.size = 0        self.cache = &#123;&#125;        # 初始化空的双向链表        self.head = DoublelinkNode()        self.tail = DoublelinkNode()        self.head.next = self.tail        self.tail.pre = self.head        def addNode(self, node): # 添加节点到head的后面，实际上第一次添加的节点都是最靠近head的        node.pre = self.head        node.next = self.head.next        self.head.next.pre = node        self.head.next = node    def removeNode(self, node): # 删除节点，为后续的操作写基础函数        node.pre.next = node.next        node.next.pre = node.pre    def movetoHead(self, node): # 把原有已存在的节点移动到head后，相当于执行了一次get        self.removeNode(node)        self.addNode(node)    def removeLast(self): # 当实际用量大于容量的时候，则要移除最靠近尾部节点的节点        node = self.tail.pre        self.removeNode(node)        return node # 返回操作是因为node的值去删除字典中的key    def get(self, key: int) -&gt; int:        if key not in self.cache: # 如果key不在缓存中            return -1        node = self.cache[key] # 如果在，返回相应的值，并且移动到头部（因为最新使用过）        self.movetoHead(node)        return node.val    def put(self, key: int, value: int) -&gt; None:        # 如果原本不存在，则加到链表以及字典中，并更新当前使用量        if key not in self.cache:            node = DoublelinkNode(key, value)            self.cache[key] = node            self.addNode(node)            self.size += 1            if self.size &gt; self.capacity:                # 如果容量超过，则需要移除尾部的节点                removed = self.removeLast()                self.cache.pop(removed.key)                self.size -= 1        # 若原本存在则更新值，并移动到头部        else:            node = self.cache[key]            node.val = value            self.movetoHead(node)# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value)\n\n155.最小栈\n两个stack，即两个list\n一个按顺序压入元素，另一个作为存储最小值的栈（每次比较最小栈末尾以及当前元素）\n时间O(1), 空间O(n)class MinStack:    def __init__(self):        self.stack = []        self.min_stack = [float(&quot;INF&quot;)] # 存储最大值进行比较    def push(self, val: int) -&gt; None: # 同步压入        self.stack.append(val)        self.min_stack.append(min(self.min_stack[-1], val))    def pop(self) -&gt; None: # 同步取出        self.stack.pop()        self.min_stack.pop()    def top(self) -&gt; int:        return self.stack[-1]    def getMin(self) -&gt; int:        return self.min_stack[-1]\n\n","categories":["刷题笔记"]}]