[{"title":"Hello World","url":"/2021/12/18/hello-world/","content":"Welcome to my blog! This is my very first post. Actually I’ve been setting up my blog for a long time(even though I often found excuses not to implement anything on the website)\n"},{"title":"动态规划","url":"/2022/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"算法本质动态规划（Dynamic Programming),简称dp问题，dp中的每一个状态由上一个状态推导出来\n构建步骤\n确定dp table及其下标的含义\n确定递推公式\ndp数组初始化\n确定遍历顺序\n举例推导dp数组\n\ndebug方法\n打印tb table\n模拟dp table中的状态转移\n\nleetcode相关题目509.斐波那契数题目链接：https://leetcode-cn.com/problems/fibonacci-number/\n\n本题主要用于熟悉dp\n然而我的做法不是基于dp思路推导，选择了今天算法课上老师说的速度较快，内存占用较小的方法（避免了递归，重复计算）class Solution:    def fib(self, n: int) -&gt; int:        num = []        num.append(0)        num.append(1)        for i in range(n):            temp = num[1]            num[1] = num[0] + num[1]            num[0] = temp        return num[0]\n\n70.爬楼梯（climbing stairs）题目链接：https://leetcode-cn.com/problems/climbing-stairs/\n\ndp[i]：爬到第i层楼的方法数\n由于本题中一次只能跨1或2个台阶，所以dp[i] = dp[i-1] + dp[i-2]\ndp[0]的初始化，本题其实无需讨论，但要做到心里有数\n延伸到一步跨不同台阶数到做法class Solution:    def climbStairs(self, n: int) -&gt; int:        dp = [0] * (n+1)        dp[0] = 1        for i in range(n+1):            for j in range(1,3):                if i &gt;= j:                    dp[i] += dp[i-j] # j的范围可改 适应不同的跨过台阶数        return dp[-1]\n\n746.使用最小花费爬楼梯（min cost climbing stairs)题目链接：\n\ndp[i]:爬到第i层的最小花费\ndp的递推公式其实有两种，每种都考虑到了，但对于不同的递推公式，有不同的初始化\ndp[i] = min(dp[i-1],dp[i-2]) + cost[i] 或 dp[i] = min(dp[i-1]+cost[i-i], dp[i-2]+cost[i-2])我的版本：class Solution:    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:        dp = [0] * (len(cost)+1)        if len(cost) == 2:            return min(cost)        for i in range(2, len(cost)+1):            dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])        return dp[-1]\n\n题解版本：\nclass Solution:    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:        dp = [0] * (len(cost))        dp[0] = cost[0]        dp[1] = cost[1]        for i in range(2, len(cost)):            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]        return min(dp[len(cost) - 1], dp[len(cost) - 2])\n\n62.不同路径（unique paths)题目链接：https://leetcode-cn.com/problems/unique-paths/\n\n题目结合高中数学的知识可推导出dp的递推公式\ndp[i][j] = dp[i-1][j] + dp[i][j-1] 因为只能向右走或者向下走\n所以就引出dp数组的初始化问题，我采用了遍历过程中初始化的方法，也可以直接全部初始化为1，修改遍历的起始点我的版本：class Solution:    def uniquePaths(self, m: int, n: int) -&gt; int:        dp = [[0] * n] * m        for i in range(0, m):            for j in range(0, n):                if i != 0 and j != 0:                    dp[i][j] = dp[i-1][j] + dp[i][j-1]                else:                    dp[i][j] = 1        return dp[-1][-1]\n\n63.不同路径II题目链接：https://leetcode-cn.com/problems/unique-paths-ii/submissions/\n\n在62的基础上，多增设了障碍\n思考过程其实与62相似，dp递推公式类似，而遇到障碍的时候，该维度的dp数组就置0，意味着没有别的通路能够通往此处/或者从此处走出\n判断条件要加上，第一格，第一行，第一列的区别我的版本：class Solution:    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:        m = len(obstacleGrid)        n = len(obstacleGrid[0])        dp = [[0]*n]*m # 构造dp table        for i in range(m):            for j in range(n):                if i != 0 and j != 0:                    if obstacleGrid[i][j] != 1:                        dp[i][j] = dp[i-1][j] + dp[i][j-1]                    else:                        dp[i][j] = 0                elif i == 0 and j != 0: # 第一行                    if obstacleGrid[i][j]!= 1:                        dp[i][j] = dp[i][j-1]                    else:                        dp[i][j] = 0                elif j == 0 and i != 0: # 第一列                    if obstacleGrid[i][j]!= 1:                        dp[i][j] = dp[i-1][j]                    else:                        dp[i][j] = 0                else: # 第一格的情况                    if obstacleGrid[i][j]!= 1:                        dp[i][j] = 1                    else:                        dp[i][j] = 0        return dp[-1][-1]\n\n343.整数拆分题目链接：https://leetcode-cn.com/problems/integer-break/submissions/\n\n本题关键在于如何确定递推公式，将数拆分的过程\n严格意义上dp[0]和dp[1]无需赋值\nO(n^2)class Solution:    def integerBreak(self, n: int) -&gt; int:        dp = [0] * (n+1)        dp[2] = 1        for i in range(3, n+1):            for j in range(1, i-1):                # 假设对正整数i拆分出的第一个数为j（此时遍历j）                # 若将i拆封成两部分：i与i-j的乘积，则此时拆分部分乘积为j*(i-j)                # 若继续将（i-j）进行拆分，则此时拆分部分乘积为j*dp[i-j]                dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j])) # 不断迭代最大值        return dp[n]\n\n96.不同的二叉搜索树(unique binary search trees)题目链接：https://leetcode-cn.com/problems/unique-binary-search-trees/submissions/\n\n本题堪称最近最有成就感的一题（大概因为想了很久吧）\n其实线索可以从leetcode上的图中观察得出，下图中已经用颜色分类，首先可以看出树的形状是对称的，接着观察以1为头节点的下半部分，实际上是当n=2时bst的形状\n最后结合二叉搜索树左右节点的特点，则可以知道dp的递推公式，由此也可以想到初始化dp[0]=1(理论上也符合)\n\n我的版本：\nclass Solution:    def numTrees(self, n: int) -&gt; int:        dp = [0] * (n+1)        dp[0] = 1        dp[1] = 1        if n == 1: return 1        for i in range(2, n+1):            for j in range(0, int(i/2)):                dp[i] += 2*dp[j]*dp[i-1-j] # 相对于题解版本，我稍微减小了内层循环的长度，实际上相差不多            if i % 2 != 0: # 加上奇偶判断                dp[i] += dp[int((i-1)/2)]*dp[int((i-1)/2)]        return dp[n]\n\n416.分割等和子集partition equal subset sum题目链接：https://leetcode-cn.com/problems/partition-equal-subset-sum/\n\n实际上这题没有理解得十分透彻\n使用了滚动数组，得注意dp的定义以及遍历顺序class Solution:    def canPartition(self, nums: List[int]) -&gt; bool:        target = sum(nums)        if target % 2 != 0:            return False        target //= 2        dp = [0] * 10001        for i in range(len(nums)):            for j in range(target, nums[i]-1, -1):                dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])        return dp[target] == target\n\ncs336 homeworkhw2.1 checker collectorConsider the following single-player game played on a game board with dimensions 4 × n.  Each square of the game board has a prize given by a positive real number.  You would like to collect prizes to maximize the sum of prizes; however, you have to satisfy the following no two adjacent prizes can be collected.  In other words, if you collect the prize at location (i,j), you cannot collect the prize at (i±1,j) or (i,j±1) (assuming those indices exist).   For example, if you checkered the game board, then one solution could be to take all the black squares, another solution could be to take all the white squares.  You could also take some white squares and some black squares as long as none of are next to each other\nInput：\n\nA 4 × n matrix Q, with prize values qijOutput: The subset S of the entries of qij such that:\nif (i,j) in S, then (i±1,j)∉ S and (i,j±1)∉S.\nΣ(i,j)∈S qij is maximized.\n\ndef print_dp(matrix):    n = len(matrix[0])    # base case? need minimum?    d = [[0 for i in range(8)] for j in range(n + 1)]  # d[][]    val = [[0 for i in range(8)] for j in range(n + 1)]  # val(j,c)    C = [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;, &#x27;0001&#x27;, &#x27;1010&#x27;, &#x27;0101&#x27;, &#x27;1001&#x27;]    idx_c = &#123;&#x27;0000&#x27;: 0, &#x27;1000&#x27;: 1, &#x27;0100&#x27;: 2, &#x27;0010&#x27;: 3, &#x27;0001&#x27;: 4, &#x27;1010&#x27;: 5, &#x27;0101&#x27;: 6, &#x27;1001&#x27;: 7&#125;    # compute all the possible solution/compatible    compatible = &#123;&#x27;0000&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;, &#x27;0001&#x27;, &#x27;1010&#x27;, &#x27;0101&#x27;, &#x27;1001&#x27;],                  &#x27;1000&#x27;: [&#x27;0000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;, &#x27;0001&#x27;, &#x27;0101&#x27;],                  &#x27;0100&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0010&#x27;, &#x27;0001&#x27;, &#x27;1010&#x27;, &#x27;1001&#x27;],                  &#x27;0010&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0100&#x27;, &#x27;0001&#x27;, &#x27;0101&#x27;, &#x27;1001&#x27;],                  &#x27;0001&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;, &#x27;1010&#x27;],                  &#x27;1010&#x27;: [&#x27;0000&#x27;, &#x27;0100&#x27;, &#x27;0001&#x27;, &#x27;0101&#x27;],                  &#x27;0101&#x27;: [&#x27;0000&#x27;, &#x27;1000&#x27;, &#x27;0010&#x27;, &#x27;1010&#x27;],                  &#x27;1001&#x27;: [&#x27;0000&#x27;, &#x27;0100&#x27;, &#x27;0010&#x27;]&#125;    # compute all the val(j,c)    for j in range(1, n+1):        for index, c in enumerate(C):            if c == &#x27;0000&#x27;:                val[j][index] = 0            if c == &#x27;1000&#x27;:                val[j][index] = matrix[0][j-1]            if c == &#x27;0100&#x27;:                val[j][index] = matrix[1][j-1]            if c == &#x27;0010&#x27;:                val[j][index] = matrix[2][j-1]            if c == &#x27;0001&#x27;:                val[j][index] = matrix[3][j-1]            if c == &#x27;1010&#x27;:                val[j][index] = matrix[0][j-1] + matrix[2][j-1]            if c == &#x27;0101&#x27;:                val[j][index] = matrix[1][j-1] + matrix[3][j-1]            if c == &#x27;1001&#x27;:                val[j][index] = matrix[0][j-1] + matrix[3][j-1]    # dp    for j in range(1, n+1):        for index, c in enumerate(C):            for id, m in enumerate(compatible[c]):                idx = idx_c[m]                d[j][index] = max(d[j][index], val[j][idx] + d[j-1][idx])    # debug    print(d)    # optimal prize    print(max(d[n][0:7]))# Press the green button in the gutter to run the script.if __name__ == &#x27;__main__&#x27;:    # design a 4*n matrix m, we use 4*5 as an example    M = [[1, 10, 1, 10, 1],         [10, 1, 10, 1, 10],         [2, 10, 2, 2, 1],         [3, 2, 10, 3, 2]]    C = [[0, 1, 2, 3, 9, 2, 12, 13, 14, 15],         [2, 5, 6, 1, 9, 2, 1, 3, 9, 12],         [2, 10, 6, 2, 5, 7, 2, 5, 6, 8],         [3, 2, 7, 8, 1, 4, 2, 6, 7, 8],         ]    N = [[1, 2, 3],         [5, 6, 1],         [10, 6, 2],         [20, 7, 8]]    print_dp(M)","categories":["刷题笔记"]},{"title":"关于在winter break摆烂的随笔小记1","url":"/2021/12/20/%E5%85%B3%E4%BA%8E%E5%9C%A8winter-break%E6%91%86%E7%83%82%E7%9A%84%E9%9A%8F%E7%AC%94%E5%B0%8F%E8%AE%B01/","content":"“突然想起了学生公寓门口的拌饺，吃完一顿要打满六个小时的韭菜味饱嗝。以前想不到吃什么的时候总会买一份拌饺加一份水果捞，拎着回宿舍和朋友一起看剧。让人怀念的还有那个摊位卖的福鼎肉片，大晚上偷偷溜出去踩水之后总会买一份的宵夜，想起来总是很快乐的日子。不想看的曾经，但又想分享的曾经。”  \n\n\n\n\n\n本来想在微博上碎碎念的文字，后来突然想起自己刚搭建的秘密基地，也成为了我码字第一个博客的契机。当然了，这种废话文学只能被归类到“随笔”中，那干脆也来写写我winter break中的摆烂一天，好歹也是记录我存在过的证据了。以后我的孙子孙女可以直接摸过来看我的日记咯，还挺有趣的。  \n今天早上是和阿叶约的“芝加哥圣诞集市之行”，一直想去感受一下这边的圣诞氛围，苦于没有车，我和阿叶总是得等到有intercampus的时候，才敢出趟“远门”。去之前倒是很期待在集市里买到可爱的纪念杯，听说上面会印有每年的年份，就蛮有意义。还打算买个我最爱的pretzel和芝士法棍三明治，捧着热红酒慢慢悠悠的逛一圈。  \n然而人们对圣诞的热情还是远超我的想象。有点像市中心“义乌小市场”的圣诞集市，就连进去也要排队，简直是梦回迪士尼四小时玩俩机动游戏的噩梦了。  \n","categories":["随笔"]},{"title":"巴斯克芝士蛋糕","url":"/2021/12/27/%E5%B7%B4%E6%96%AF%E5%85%8B%E8%8A%9D%E5%A3%AB%E8%9B%8B%E7%B3%95/","content":"材料（此配方可制作6寸巴斯克芝士，8寸则所有用量乘以2）\n奶油奶酪 cream cheese: 350g\n细砂糖 sugar: 75g\n蛋黄 egg yolk: 3个\n全蛋 egg（大): 2个\n淡奶油 heavy whipping cream: 150g\n牛奶 whole milk: 50g\n玉米淀粉/低筋面粉 corn starch/cake flour: 12g\n\n简易做法版本（无电动打蛋器/无料理棒/无筛）\n奶油奶酪加入细砂糖，隔水加热，搅拌至顺滑（不能过火，有可能导致水油分离）\n\n\n\n分次加入3个蛋黄，2个全蛋，搅拌至吸收再加入下一个（鸡蛋可提前从冰箱取出放至室温，减少水油分离可能性）\n\n \n\n加入牛奶，搅拌均匀（有抹茶粉/可可粉则在牛奶后加入）\n\n加入淡奶油，搅拌均匀\n\n加入玉米淀粉，搅拌均匀\n\n烤箱预热，模具铺入烘焙纸（烘焙纸打湿/弄皱后更容易贴合模具）\n\n烤箱中层，220度22-23mins，提前查看表皮上色，上色不够深则移入烤箱上层烘烤2-3mins（我的公寓烤箱拧至一半多些，烘烤20mins后移入烤箱上层，3-4mins）\n\n出炉冷却后保鲜膜包裹起来，无需脱模，冷藏一夜\n\n \n\n可把部分剩余淡奶油打发至六分，结合水果进行装饰\n\n  \n\n\n \n\n\n","categories":["食谱"]},{"title":"贪心算法（greedy algorithm)","url":"/2021/12/21/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88greedy-algorithm/","content":"算法本质选择每一阶段的局部最优，从而达到全局最优化\n算法应用场景\n无固定套路，常识性推导\n想不到相应的反例，可以试试贪心\n贪心算法跑过测试用例即可，或自圆其说  \n\n贪心一般解题步骤\n将原本问题分解为若干子问题\n找出适合的贪心策略\n求出每个子问题最优解\n将局部最优解堆叠成全局最优解\n\nleetcode相关题目455.分发饼干(assign cookies)题目链接：\n\n数组-&gt;升序排列，遍历\n可用cookies的index来减少for循环层数\n两种思路\n时间复杂度 O(n)\n\nclass solution:    def find(self, g:List[int], s:List[int]) -&gt; int:        g.sort() # 先进行升序排列        s.sort()        index = 0 # 利用cookies下标代替两层for循环        for i in range(len(s)):            if index &lt; len(g) and s[i] &gt;= g[index]: # ！满足的标准和下标移动                index += 1        return index\n\n376.摆动序列（wiggle subsequence)题目链接：\n\n每个峰值的判断（判断单调区间）\n最右峰值的判断\n时间复杂度 O(n)\n\nclass solution:    def wiggleMaxLength(self, nums:List[int]) -&gt; int:        res = 1        cuffix = 0        prefix = 0        for i in range(len(nums)-1):            curfix = nums[i+1] - nums[i]            if curfix * prefix &lt;= 0 and curfix != 0:                res += 1                prefix = curfix        return res \n\n53.最大子序和（）题目链接：\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        if nums is None:            return nums        temp = 0        maxsum = nums[0]        for i in range(len(nums)):            temp += nums[i]            if temp &gt; maxsum:                maxsum = temp            if temp &lt; 0:                temp = 0        return maxsum\n\n122.买卖股票的最佳时机（best time to buy and sell stock2)题目链接：\n\n我的做法想的太过复杂，使用了判断单调上升区间卖出计算\n时间复杂度 O(n)  \n\nclass Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        prefix, curfix, profit = 0, 0, 0        begin, end = -1, -1        for i in range(len(prices)-1):            curfix = prices[i+1] - prices[i]            if prefix * curfix &lt;= 0 and curfix &gt; 0: #上升区间起点                begin = prices[i]            if prefix * curfix &lt;= 0 and curfix &lt;= 0 and prefix &gt; 0: #上升区间终点                end = prices[i]            if i+1 == len(prices)-1 and prices[-1] - prices[-2] &gt; 0: #判断list末尾是否为上升区间终点                end = prices[i+1]            if begin != -1 and end != -1: #只有同时找到起点和终点时才能组成一个单调区间                profit += (end - begin)                end, begin = -1, -1            prefix = curfix        return profit\n\n题解版本：\n\n实际上只关注正利润，由于题目中股票持有和卖出的特性\n只要利润为正，就记入总利润中，此特性也可以在画的图中展现出来class Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        result = 0        for i in range(1, len(prices)):            result += max(prices[i] - prices[i - 1], 0)        return result\n\n55.跳跃游戏（jump game）题目链接：https://leetcode-cn.com/problems/jump-game/\n\n局部最优解：可跳跃的最大覆盖范围 整体：能否覆盖到终点\nindex：棋子跳跃的下标 cover：棋子当下能够覆盖到的最远下标\n利用cover限制index，并作为while循环的中断条件class Solution:    def canJump(self, nums: List[int]) -&gt; bool:        if len(nums) == 1:            return True        cover = 0        index = 0        while index &lt;= cover:            cover = max(index+nums[index], cover)            if cover &gt;= len(nums) - 1:                return True            index += 1        return False\n\n45.跳跃游戏II题目链接：https://leetcode-cn.com/problems/jump-game-ii/submissions/本题与55相比，不同之处：45输出能否覆盖终点，本题输出覆盖终点的最小步数\n\n局部：可移动距离中尽可能多走，未到终点则步数加1；整体：一步尽可能多走，达到最小步数\ncurCover：当前可覆盖 nextCover：下一步可覆盖\n注意棋子跳跃的时候边界范围的设定class Solution:    def jump(self, nums: List[int]) -&gt; int:        if len(nums) == 1:            return 0        index, curCover, nextCover = 0, 0, 0        step = 0        while index &lt; len(nums) - 1:            nextCover = max(index+nums[index], nextCover)            if index == curCover:                curCover = nextCover                step += 1            index += 1        return step\n\n1005.k次取反后最大化的数组之和(maximize sum of array after k negations)题目链接：https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/\n\n数组按绝对值由大到小排序\n遍历数组，遇到负数则进行取反，k-=1；k=0时跳出循环\n若遍历完全还有剩余k，则取数组最后一个数（最小的数值）反复取反\nO(n)class Solution:    def largestSumAfterKNegations(self, nums: List[int], k: int) -&gt; int:        nums = sorted(nums, key=abs,reverse=True)        for i in range(len(nums)):            if k &gt; 0:                if nums[i] &lt; 0:                    nums[i] = -nums[i]                    k -= 1                else:                    continue            else:                break        if k &gt; 0:            if k % 2 == 1:                nums[-1] = -nums[-1]        return sum(nums)\n\n134.加油站（gas station）题目链接：https://leetcode-cn.com/problems/gas-station/该题和某公司oa中的魔毯问题一样\n\n如果sum(gas) &lt; sum(cost),那么汽车不可能走完一圈\nres[i] = gas[i] - cost[i]class Solution:    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int:        start, cursum, totalsum =0, 0, 0        for i in range(len(gas)):            cursum += gas[i] - cost[i]            totalsum += gas[i] - cost[i]            if cursum &lt; 0:                start = i + 1                cursum = 0        if totalsum &lt; 0:            return -1        return start\n\n135.分发糖果（candy）题目链接：https://leetcode-cn.com/problems/candy/\n\n关键是思考时不能顾此失彼，从左到右和从右到左遍历一遍\n注意第二次遍历时要考虑到取max\npython的后序遍历range（start,stop,step)class Solution:    def candy(self, ratings: List[int]) -&gt; int:        candyvec = [1] * len(ratings)        for i in range(1, len(ratings)):            if ratings[i] &gt; ratings[i-1]:                candyvec[i] = candyvec[i-1] + 1        for j in range(len(ratings)-2, -1, -1):            if ratings[j] &gt; ratings[j+1]:                candyvec[j] = max(candyvec[j], candyvec[j+1]+1)        return sum(candyvec)\n\n860.柠檬水找零（lemonade change）题目链接：https://leetcode-cn.com/problems/lemonade-change/\n\n常识做题\n后续可优化存储和判断，有部分冗余判断\n没有记录20元的张数，因为找零用不了20元class Solution:    def lemonadeChange(self, bills: List[int]) -&gt; bool:        if bills[0] != 5:            return False        change = [0] * 2        for i in range(len(bills)):            if bills[i] == 5: # 情况1 遇到5直接收下                change[0] += 1            elif bills[i] == 10: # 情况2 遇到10则检查有无5                if change[0] &lt; 1:                    return False                else:                    change[0] -= 1                    change[1] += 1            else: # 情况3 遇到20 先用10元找零，不够再用3张5元                if change[0]*5+change[1]*10&lt;15:                    return False                else:                    if change[0] &lt; 1:                        return False                    else:                        if change[1] &gt;= 1:                            change[1] -= 1                            change[0] -= 1                        else:                            if change[0] &lt; 3:                                return False                            else:                                change[0] -= 3        return True\n\n406.根据身高重建队列（queue restruction by height）题目链接：\n\n本题与分发糖果类似，确定一个维度排序，再根据另外一个维度插入\n先按身高维度 从大到小进行排序：确保前面的节点都比自身高\n后面queue的insert 根据另一个维度进行插入，结合list.insert(index, element)，直接根据第二个维度确定插入的下标class Solution:    def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]:        people = sorted(people, key=lambda x: (-x[0], x[1]))        queue = []        for p in people:            queue.insert(p[1], p)        # print(people)        # print(queue)        return queue\n\n452.用最少数量的箭引爆气球（minimum number of arrows to burst ballons)题目链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/\n\n对区间重叠的问题，有意识从维度排序先入手（本题以任一维度排序都行）\n后序思考太复杂，判断重叠只需要上一区间上边界与下一区间的下边界\n完成判断后要更新边界，以便后续判断class Solution:    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:        points = sorted(points, key= lambda x: (x[0], x[1]))        res = 1        for i in range(1,len(points)):            if points[i][0] &gt; points[i-1][1]:                res += 1            else:                points[i][1] = min(points[i-1][1], points[i][1])        return res\n\n435.无重叠区间(non-overlapping intervals)题目链接：https://leetcode-cn.com/problems/non-overlapping-intervals/\n\n解题思路和452类似\n我的ac和题解版本不太一样\n题解思路：最小移除区间数量 = 总区间数量 - 最大非交叉区间数量题解版本：class Solution:    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        intervals = sorted(intervals, key= lambda x:(x[1])) # 按照右边界排序        count  = 1        end = intervals[0][1]        for i in range(1, len(intervals)):            if intervals[i][0] &gt;= end:                count += 1                end = intervals[i][1]        return len(intervals) - count\n\n我的版本：\nclass Solution:    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        intervals = sorted(intervals, key= lambda x:(x[0])) # 按照左边界排序        res = 0        for i in range(1, len(intervals)):            if intervals[i][0] &lt; intervals[i-1][1]:                res += 1                intervals[i][1] = min(intervals[i-1][1], intervals[i][1])        return res\n\n763.划分字母区间（partition labels）题目链接：https://leetcode-cn.com/problems/partition-labels/\n\n第一次遍历list记录该字母出现的最远下标\n巧妙思路： 第二次遍历字符串时，若index==字母的最远index，则说明此处是分割点（无需记录字母的起始位置）\n别忘更新下一个分割区间起始点的位置：上一个分割index+1class Solution:    def partitionLabels(self, s: str) -&gt; List[int]:        character = [0] * 26 # 记录字符出现的最远位置的下标        for i in range(len(s)):            character[ord(s[i])-ord(&#x27;a&#x27;)] = i        start, end = 0, 0        res = []        for j in range(len(s)):            end = max(end, character[ord(s[j])-ord(&#x27;a&#x27;)])            if end == j:                res.append(end - start + 1)                start = j + 1        return res\n\n56.合并区间（merge intervals）题目链接：https://leetcode-cn.com/problems/merge-intervals/\n\n同样地，先对数组进行按第一维度排序\n通过和res中上一个数组的第二维度进行比较，如果重叠则直接更新第二维度，不重叠则append新的数组class Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x:x[0])        res = []        res.append([intervals[0][0], intervals[0][1]])        for i in range(1, len(intervals)):            if intervals[i][0] &lt;= res[-1][1]:                res[-1][1] = max(res[-1][1], intervals[i][1])            else:                res.append([intervals[i][0],intervals[i][1]])        return res\n\n738.单调递增的数字（monotone increasing digits)题目链接：https://leetcode-cn.com/problems/monotone-increasing-digits/submissions/\n\n首先要观察到判断规律\n从后向前遍历更能利用到数字条件，不用分类讨论下一个数字是大于等于的不同情况\n注意列表/字符串/字符等相互转化的方法 以及填满列表的方法class Solution:    def monotoneIncreasingDigits(self, n: int) -&gt; int:        if n &lt;= 9: return n        if n == 10: return 9        num = list(str(n))        for i in range(len(num)-1,0,-1):            if num[i] &lt; num[i-1]:                num[i-1] = str(int(num[i-1])-1)                num[i:] = &quot;9&quot; * (len(num) - i)        return int(&quot;&quot;.join(num))\n\n","categories":["刷题笔记"]},{"title":"链表linked_list","url":"/2022/01/12/%E9%93%BE%E8%A1%A8linked-list/","content":"关于链表作为曾经只用c写链表的人，只能说对链表厌恶至极。确实换了python刷题之后，链表操作更加简单了，但那种内心深处指针移来移去的恐惧还没有消失哈哈哈。不过，越是害怕的东西越要战胜，由于学期任务紧，关于链表的一些技巧后面再补充，这里先post一些挤出时间刷的题吧！\nleetcode相关题目24.两两交换链表中的节点 swap nodes in pair题目链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n本题需要三个指针，一个指向pair的前一个节点，剩下两个分别指向pair里的两个nodes\n是否需要继续交换则通过判断pre是否同时存在next和next.next\npre初始可定位在虚拟头节点，若上述判断成立，则使cur和post指向pair（若不成立则代表无需继续交换）# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:\n\n19.删除链表倒数第n个节点remove nth node from end of list题目链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\n\n使用双指针，只需遍历一遍\nslow让fast先走n+1步，n+1是因为单向链表删除操作需要定位在前一个节点# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:\n\n","categories":["刷题笔记"]},{"title":"面试准备","url":"/2022/01/24/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/","content":"leetcode原题数组和字符串1.两数之和link\n\nbrute force\n\nn = len(nums)for i in range(n):    for j in range(i+1, n):        if nums[i] + nums[j] == target:            return [i, j]return []\n\n哈希表解决target-x问题table = &#123;&#125;for idx, num in enumerate(nums):    if target-num in table:        return [table[target-num], idx]    else:        table[nums[idx]] = idxreturn []\n\n3.无重复子串的最长字符串link：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n\n滑动窗口，哈希记录出现字符的下标\nO(n)class Solution:    def lengthOfLongestSubstring(self, s: str) -&gt; int:        k, res = -1, 0        table = &#123;&#125;        for ix, char in enumerate(s):            if char in table and table[char] &gt; k:                k = table[char] # 定位到重复字符的下标作为字符串起始idx                table[char] = ix # 更新字符下标            else:                table[char] = ix                res = max(res, ix-k)        return res\n\n4.寻找两个有序数组的中位数link: https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\n\n说实话，还没看懂题解class Solution:    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:        if len(nums1) &gt; len(nums2):            return self.findMedianSortedArrays(nums2, nums1)        infinty = 2**40        m, n = len(nums1), len(nums2)        left, right = 0, m        # median1：前一部分的最大值        # median2：后一部分的最小值        median1, median2 = 0, 0        while left &lt;= right:            # 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]            # // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]            i = (left + right) // 2            j = (m + n + 1) // 2 - i            # nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]            nums_im1 = (-infinty if i == 0 else nums1[i - 1])            nums_i = (infinty if i == m else nums1[i])            nums_jm1 = (-infinty if j == 0 else nums2[j - 1])            nums_j = (infinty if j == n else nums2[j])            if nums_im1 &lt;= nums_j:                median1, median2 = max(nums_im1, nums_jm1), min(nums_i, nums_j)                left = i + 1            else:                right = i - 1        return (median1 + median2) / 2 if (m + n) % 2 == 0 else median1\n\n11.盛最多水的容器link: https://leetcode-cn.com/problems/container-with-most-water/\n\n经典面试题，双指针法 O(n)\n左右指针分别定位在数组头部和尾部，移动数值较小一端\n理解该方法的正确性class Solution:    def maxArea(self, height: List[int]) -&gt; int:        left, right = 0, len(height) - 1        res = 0        while left &lt; right:            area = (right - left) * min(height[left], height[right])            res = max(res, area)            if height[left] &lt;= height[right]:                left += 1            else:                right -= 1        return res\n\n13.罗马数字转整数\n考虑到罗马数字的特性，一开始使用了双指针（但其实没必要）O(n)\n用字典存储数值，每次比较，只需要对slow index的数值进行操作，return之前记得把最后一个数值加上\n纯粹自己的解法class Solution:    def romanToInt(self, s: str) -&gt; int:        roman = &#123;&quot;I&quot;:1,&quot;V&quot;:5, &quot;X&quot;: 10, &quot;L&quot;:50, &quot;C&quot;:100, &quot;D&quot;:500, &quot;M&quot;: 1000&#125;        s = list(s)        if len(s) == 1:            return roman[s[0]]        res = 0        for i in range(len(s)-1):            if roman[s[i+1]] &lt;= roman[s[i]]:                res += roman[s[i]]            else:                res -= roman[s[i]]        res += roman[s[-1]]        return res\n\n12.整数转罗马数字\n和罗马数字表达特性有关， 字典存储， 固定组合 O(n)\n尽可能选择最大的数值，字典存储数值与字符对， list append相应的字符class Solution:    def intToRoman(self, num: int) -&gt; str:        dic = [            (1000, &quot;M&quot;),(900, &quot;CM&quot;),(500, &quot;D&quot;), (400, &quot;CD&quot;),(100, &quot;C&quot;), (90, &quot;XC&quot;),(50, &quot;L&quot;), (40, &quot;XL&quot;),(10, &quot;X&quot;), (9, &quot;IX&quot;), (5, &quot;V&quot;), (4, &quot;IV&quot;), (1, &quot;I&quot;)        ]        roman = []        for value, symbol in dic:            while num &gt;= value:                num -= value                roman.append(symbol)            if num == 0:                break        return &quot;&quot;.join(roman)\n\n49.字母异位词分组\n实际上调用了python里的包 collections\ncollections.defaultdict(list) 返回一个空的dict，里面的value为空的list类型\n字母异位词包含的字符一样，所以sorted之后返回的list都是一样的\n以sorted之后的str‘为key，而str则append进相应的value‘\n注意返回的时候 list(mp.values())， values返回一个iterable类型class Solution:    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:        mp = collections.defaultdict(list)        for st in strs:            key = &quot;&quot;.join(sorted(st))            mp[key].append(st)        return list(mp.values())\n\n48.旋转图像\n水平翻转 + 主对角线翻转 (注意坐标的改变规律以及两层循环的不同)\nO(n^2) class Solution:    def rotate(self, matrix: List[List[int]]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify matrix in-place instead.        &quot;&quot;&quot;        n = len(matrix[0])        # 水平翻转（限制 i 的遍历范围）        for i in range(n // 2):            for j in range(n):                matrix[i][j], matrix[n - i - 1][j]  = matrix[n - i - 1][j], matrix[i][j]        # 主对角线翻转（限制j的遍历范围）        for i in range(n):            for j in range(i):                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]        \n\n15.三数之和\n双指针 + 排序\n去重逻辑比较复杂 循环开始前需要去重，找到满足条件的一个三元组之后需要去重\n边界例子： 如果第一个指针指向的数已经大于0，直接返回res；去重结束之后同样需要收缩两个边界指针class Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        res = []        n = len(nums)        nums = sorted(nums)        for i in range(n):            left = i + 1            right = n - 1            # 边界条件，节省时间            if nums[i] &gt; 0:                return res            # 循环前去重            if i &gt; 0 and nums[i] == nums[i - 1]:                continue            while left &lt; right:                total = nums[i] + nums[left] + nums[right]                if total &gt; 0:                    right -= 1                elif total &lt; 0:                    left += 1                else:                    res.append([nums[i],nums[left],nums[right]])                    # 找到正确答案后去重                    while left &lt; right and nums[right-1] == nums[right]:                        right -= 1                    while left &lt; right and nums[left+1] == nums[left]:                        left += 1                    # 找到正确答案后边界条件同时收缩                    right -= 1                    left += 1        return res     \n\n16.最接近的三数之和\n大致思路和上题一样 排序+双指针\n细节：res先设置成最大值；循环前去重；找到答案后去重（顺序）\n\nclass Solution:    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:        res = 10**7        n = len(nums)        # 排序        nums = sorted(nums)        for i in range(n):            # 循环前去重            if i &gt; 0 and nums[i-1] == nums[i]:                continue            # 因为此处是寻找与目标值最接近的总和，这里就不能通过判断第一位大于target而中止循环            left = i + 1             right = n - 1            while left &lt; right:                total = nums[i] + nums[left] + nums[right]                if abs(total - target) &lt;= abs(res - target):                    res = total                # 注意更新结果后的去重的顺序，去重再收缩边界                if total &lt; target:                    while left &lt; right and nums[left + 1] == nums[left]:                        left += 1                    left += 1                elif total &gt; target:                    while left &lt; right and nums[right - 1] == nums[right]:                        right -= 1                    right -= 1                else:                    return target        return res\n\n28.实现strStr（kmp算法）\nkmp算法需要多复习，关键在于next数组的构建，文本串和字符串匹配的过程 O(n+m)class Solution:    def strStr(self, haystack: str, needle: str) -&gt; int:        # 如果模式串为空，则返回0（在面试中可以问这个问题）        if needle == &quot;&quot;:            return 0        # 构建空next数组        nex = [0] * len(needle)        def findnext(nex:List[int], s:str):            # 初始化j为前缀起始，            j = -1            nex[0] = j            # i为后缀起始，定位为1            for i in range(1, len(s)):                while j &gt;= 0 and s[i] != s[j+1]: # 前后缀不同                    # 找j+1前一个元素在next里的值，赋值给j                    j = nex[j]                if s[i] == s[j+1]: # 前后缀相同                    # 指针往后移动                    j += 1                # 赋值到相应的后缀next数值中                nex[i] = j            return nex        # 构建模式串的next数组        Next = findnext(nex, needle)        j = -1        # 此处的i定位在文本串起始处 为0        for i in range(len(haystack)):            while j &gt;= 0 and haystack[i] != needle[j+1]:                j = Next[j]            if haystack[i] == needle[j+1]:                j += 1            if j == len(needle) - 1:                return (i - len(needle) + 1)        return -1\n\n8.字符串转换整数\n不太知道为什么美区企业题库里有这道题，但还是得硬着头皮做\n题解是用有限状态机写的，不使用ifelse来判断\n实际上得考虑边界条件，就当是练习一下怎么用python写class了INT_MAX = 2**31 -1INT_MIN = -2**31class Dfa:    def __init__(self):        self.state = &#x27;start&#x27;        self.sign = 1        self.ans = 0        # 关键是这个状态转换表，把表画出来之后就很容易了        self.table = &#123;            &#x27;start&#x27;: [&#x27;start&#x27;, &#x27;signed&#x27;, &#x27;in_num&#x27;, &#x27;end&#x27;],            &#x27;signed&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_num&#x27;, &#x27;end&#x27;],            &#x27;in_num&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;in_num&#x27;, &#x27;end&#x27;],            &#x27;end&#x27;: [&#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;, &#x27;end&#x27;]        &#125;    # 根据输入的字符和当前状态寻找下一转换状态    def get_col(self,c):        if c.isspace():            return 0        if c == &#x27;+&#x27; or c == &#x27;-&#x27;:            return 1        if c.isdigit():            return 2        return 3    # 只有其中两个状态的时候才需要改变，判断边界条件    def get(self, c):        self.state = self.table[self.state][self.get_col(c)]        if self.state == &quot;in_num&quot;:            self.ans = self.ans * 10 + int(c)            if self.sign == 1:                self.ans = min(self.ans, INT_MAX)            else:                self.ans = min(self.ans, -INT_MIN)        elif self.state == &quot;signed&quot;:            if c == &quot;+&quot;:                self.sign = 1            else:                self.sign = -1class Solution:    def myAtoi(self, s: str) -&gt; int:        dfa = Dfa()        for c in s:            dfa.get(c)        return dfa.sign * dfa.ans\n\n937.重新排列日志\n简单来说 就是熟练运用内置方法的一道题\nsorted，再写一个函数返回排序的keyclass Solution:    def reorderLogFiles(self, logs: List[str]) -&gt; List[str]:        def get_key(log):            id_, rest = log.split(&quot; &quot;, maxsplit=1)            if rest[0].isalpha():                return (0, rest, id_)            else:                return(1, )        return sorted(logs, key=get_key)\n\n42.接雨水\n双指针 O(n) 定义left和right指针 进行判断\n每次使用leftmax和rightmax来更新两边的最大值\n若有height[left] &lt; height[right]，则会有leftmax &lt; rightmax,下标left处能接的雨水量=leftmax - height[left]（因为此时左边界为最低的盛水高度\n反之同理，可画图演示class Solution:    def trap(self, height: List[int]) -&gt; int:        res = 0        left, right = 0, len(height)-1        leftmax = rightmax = 0        while left &lt; right:            leftmax = max(leftmax, height[left])            rightmax = max(rightmax, height[right])            if height[left] &lt; height[right]:                res += leftmax - height[left]                left += 1                        else:                res += rightmax - height[right]                right -= 1        return res\n\n链表2. 两数相加*注意进位问题\n# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        node1, node2 = l1, l2        res = cur = ListNode()        carry = v = 0        while node1 or node2:            if node1 and node2:                v = node1.val + node2.val + carry                node1 = node1.next                node2 = node2.next            elif node1 == None:                v = node2.val + carry                node2 = node2.next            else: # node2 == None                v = node1.val + carry                node1 = node1.next                        carry, v = divmod(v, 10)            cur.next = ListNode(v)            cur = cur.next                if carry:            cur.next = ListNode(1)        return(res.next)\n\n138.复制带随机指针的链表\n方法很巧妙，第一次遍历时 复制每个节点，并插入到旧节点的后面\n第二次遍历的时候改变新节点的random指向，但这里很关键，指向不能为random，而为random.next，因为复制了新的节点\nO(n)&quot;&quot;&quot;# Definition for a Node.class Node:    def __init__(self, x: int, next: &#x27;Node&#x27; = None, random: &#x27;Node&#x27; = None):        self.val = int(x)        self.next = next        self.random = random&quot;&quot;&quot;class Solution:    def copyRandomList(self, head: &#x27;Optional[Node]&#x27;) -&gt; &#x27;Optional[Node]&#x27;:        if not head:            return head                # 对节点进行复制并插入到链表中        cur = head        while cur:            new_node = Node(cur.val, None, None)            new_node.next = cur.next            cur.next = new_node            cur = cur.next.next                # 改变新节点的random值        cur = head        while cur:            if cur.random: # 不存在则指向空                cur.next.random = cur.random.next # 这里很关键            else:                cur.next.random = None            cur = cur.next.next                # 新旧链表各一个指针，再加一个需要返回的新链表的头指针        old_list = head        new_list = head.next        new_head = head.next        while old_list:            old_list.next = old_list.next.next            if new_list.next: # 若新链表中还有next，表明下一个还非空（画图可知）                new_list.next = new_list.next.next            else:                new_list.next = None            old_list = old_list.next            new_list = new_list.next        return new_head\n\n21.合并两个有序链表\n基本思想和上题一样\n注意对链表空或非空的判断，注意移动cur指针# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:        res = cur = ListNode()        node1, node2 = list1, list2        while node1 or node2:            if node1 and node2:                if node2.val &gt;= node1.val:                    cur.next = ListNode(node1.val)                    node1 = node1.next                else:                    cur.next = ListNode(node2.val)                    node2 = node2.next            elif node1 == None:                cur.next = node2                node2 = node2.next            else: # node2 == None                cur.next = node1                node1 = node1.next            cur = cur.next        return res.next\n\n206.反转链表\n三个指针，pre cur next 实现O(n)\n先定义pre为空，返回pre指针# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def reverseList(self, head: ListNode) -&gt; ListNode:        if not head or not head.next:            return head                    cur = head        pre = None        while cur:            next = cur.next            cur.next = pre            pre = cur            cur = next        return pre \n\n25.k个一组翻转链表\nO(n)# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    # 这个函数的操作是用来翻转k范围内的节点，操作和翻转节点很相似    def reverseNode(self, head:ListNode, tail:ListNode):        # pre定义在tail的next原因是子链表的头翻转后要指向它        pre = tail.next        cur = head        # 所以这里的判断条件是，pre指针没有到链表区间范围尾端的tail指针        while pre != tail:            next = cur.next            cur.next = pre            pre = cur            cur = next        # 原来的tail成为新的head        return tail, head    def reverseKGroup(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:        # 新建一个空的头指针        hair = ListNode(0)        # 指向原来的head        hair.next = head        # 定位pre指针        pre = hair        while head:            tail = pre            # tail用来计算是否有足够的翻转空间            for i in range(k):                tail = tail.next                if not tail: # 如果剩下的不够翻转，直接返回                    return hair.next            # 保存tail.next 用于连接翻转后的子链表            nex = tail.next            head, tail = self.reverseNode(head, tail)            pre.next = head            tail.next = nex            # 只需移动pre和head指针，tail和nex指针每次都根据head的位置移动            pre = tail            head = tail.next                return hair.next\n\n23.合并k个升序链表\n优先队列，其实相当于四个指针\nimport heapq， heapq需要用list来作为item的载体，同时压入排序的key，以及下一个检索的idx（heapq不能直接压入node，只能压入node在list中的idx，用于下次寻找）\ntime:O(nlogk) space: queue:O(k) linked_list:O(n)# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:        import heapq        head = cur = ListNode(0)        q = []        for i in range(len(lists)):            if lists[i]: # 很重要，如果是空节点则不能放进队列里，有可能有空节点（k个节点）                heapq.heappush(q,(lists[i].val, i))                lists[i] = lists[i].next                while q:            val, idx = heapq.heappop(q)            cur.next = ListNode(val)            cur = cur.next            if lists[idx]: # 同样的判断是否下个节点需要放进队列中                heapq.heappush(q, (lists[idx].val, idx))                lists[idx] = lists[idx].next                return head.next\n\n二叉树和图200.岛屿数量\n记住成为岛屿的条件，利用深度搜索对方格周围的四个方格进行搜索 O(mn)\n各种小细节，进入dfs之前记得岛屿数量增加；进入dfs后，搜索要加上边界限定条件class Solution:    def dfs(self, grid, r, c):        # 搜索过的方格需要进行置0        grid[r][c] = &quot;0&quot;        nr = len(grid)        nc = len(grid[0])        # dfs内的dfs只需要搜索相应的四个方格        for x,y in [(r-1, c), (r + 1, c), (r, c-1), (r, c+1)]:            # 因为此处循环没有边界限定所以要加上判断条件，防止越界            if 0&lt;= x &lt; nr and 0 &lt;= y &lt; nc and grid[x][y] == &quot;1&quot;:                self.dfs(grid, x, y)    def numIslands(self, grid: List[List[str]]) -&gt; int:        nr = len(grid)        # 判断输入为空的情况        if nr == 0:            return 0        nc = len(grid[0])        res = 0        for x in range(nr):            for y in range(nc):                # 在这层循环中，只要为1则进行dfs                if grid[x][y] == &quot;1&quot;:                    res += 1                    self.dfs(grid, x, y)        return res\n\n98.验证二叉搜索树\n利用二叉搜索树的特性，中序搜索是升序\n因为input中有最小值，需要全局最小化一个max值\n递归判断节点的左右子树，只有同时为真才为真# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def isValidBST(self, root: TreeNode) -&gt; bool:        # 全局最小值        cur_max = -float(&quot;INF&quot;)        def _isvalidbst(root: TreeNode):            # 全局变量            nonlocal cur_max            # 此处处理空节点的情况            if not root:                return True                        # 中序遍历            is_left = _isvalidbst(root.left)            if cur_max &lt; root.val:                cur_max = root.val            else:                return False                        is_right = _isvalidbst(root.right)            # 同时为真才为真            return is_left and is_right        return _isvalidbst(root)\n\n101.对称二叉树\n实际上这里没有严格用到二叉树的几种遍历方式，因为对称需要对比的是外侧和里侧\n使用递归，比较外侧：传入左子树的左孩子，右子树的右孩子；比较里侧：传入左子树的右孩子，右子树的左孩子# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def isSymmetric(self, root: TreeNode) -&gt; bool:        # 考虑根节点为空的情况        if not root:            return True        return self.compare(root.left, root.right)        def compare(self, left, right):        # 节点为空的情况        if left == None and right != None:            return False        elif right == None and left != None:            return False        elif right == None and left == None:            return True        # 节点不空但是val不同        elif right.val != left.val:            return False        # 节点不空且val相同，才可以继续递归        outside = self.compare(left.left, right.right)        inside = self.compare(left.right, right.left)        #两边同时为真才能为真        same = outside and inside        return same\n\n102.二叉树的层序遍历\n使用先进先出队列，迭代法实现层序遍历\ncollections.deque# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:        # 判断节点是否为空        if not root:            return []                # 队列需要用list来做容器，初始化一个存放了root的deque        results = []        q = collections.deque([root])        while q:            size = len(q)            result = []            for i in range(size):                node = q.popleft()                result.append(node.val)                if node.left:                    q.append(node.left)                if node.right:                    q.append(node.right)            results.append(result)        return results\n\n103.二叉树的锯齿形层序遍历\n我的做法 102的层序遍历+标记位反转 O(n)，每个节点仅被遍历一次\n可以使用双端队列 从左端取出的孩子节点从右端压入，从右端取出的孩子节点再从左端压入，且左孩子和右孩子的压入先后有细小差别# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]:        if not root:            return []                q = collections.deque([root])        results = []        # 标记位        direc = 1 # pop from left, append to right        while q:            size = len(q)            result = []            for i in range(size):                # 从左边取出                if direc % 2 == 1:                    node = q.popleft()                    result.append(node.val)                    # 右边先压入左孩子                    if node.left:                        q.append(node.left)                    if node.right:                        q.append(node.right)                # 从右边取出                if direc % 2 != 1:                    node = q.pop()                    result.append(node.val)                    # 从左边心压入右孩子                    if node.right:                        q.appendleft(node.right)                    if node.left:                        q.appendleft(node.left)            results.append(result)            # 改变标志位            direc += 1        return results\n\n124.二叉树中的最大路径和\n有点像后序遍历，注意细节，O(n)# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def maxPathSum(self, root: Optional[TreeNode]) -&gt; int:        maxsum = -float(&quot;INF&quot;)        def maxgain(node):            nonlocal maxsum            # 注意对空节点（叶子节点）的处理            if not node:                return 0            # 只有大于0的路径才纳入考虑            leftgain = max(maxgain(node.left), 0)            rightgain = max(maxgain(node.right), 0)            new_path = node.val + leftgain + rightgain            # 每次更新路径最大值            maxsum = max(new_path, maxsum)            # 只返回最大的一边路径，因为每个节点在路径中出现一次            # 想象一下假如返回一个节点的右子树和右子树，相当于节点被访问了两次，不符合题目要求            return node.val + max(leftgain, rightgain)        maxgain(root)        return maxsum \n\n236.二叉树的最近公共祖先\n后序遍历（回溯），找到节点之后还是要遍历整棵树\n需要理解的地方比较多，题目说p和q一定会存在，不需要考虑找不到的情况，就算这里找不到，返回的也是null# Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def lowestCommonAncestor(self, root: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;:        # 假设找到相等的节点则立即返回        if not root or p == root or q == root:            return root                left = self.lowestCommonAncestor(root.left, p, q)        right = self.lowestCommonAncestor(root.right, p, q)        # 如果left和right同时为真，则代表此节点为最近的公共祖先        if left and right:            return root        # 可能是left的这个节点是她们的祖先，也有可能还没找到另一个孩子节点        elif left:            return left        return right\n\n543.二叉树的直径\n实际上就是二叉树的最长路径，做法类似124最大路径和\n稍微改动数值则可以ac，# Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:        longest_sum = -float(&quot;INf&quot;)        def findlong(node):            # 遍历到叶子节点则返回0            if not node:                return 0            nonlocal longest_sum            # 寻找左孩子的最长路径            left = findlong(node.left)            # 寻找右孩子的最长路径            right = findlong(node.right)            # 最长路径更新时需要考虑两个孩子的最长路径            longest_sum = max(left+right, longest_sum)            # 而递归函数返回的时其最大的孩子路径+1            return max(left, right)+1        findlong(root)        return longest_sum\n\n设计146.LRU缓存\n使用双向链表和哈希表进行实现\n对put和get都是O(1)class DoublelinkNode:    # 双向链表的结构，记得初始化key和value，否则建立虚拟节点的时候会报错    def __init__(self, key=0, val=0):        self.key = key        self.val = val        self.next = None        self.pre = Noneclass LRUCache:    def __init__(self, capacity: int):        # 整个lru的容量，实际使用量，以及字典        self.capacity = capacity        self.size = 0        self.cache = &#123;&#125;        # 初始化空的双向链表        self.head = DoublelinkNode()        self.tail = DoublelinkNode()        self.head.next = self.tail        self.tail.pre = self.head        def addNode(self, node): # 添加节点到head的后面，实际上第一次添加的节点都是最靠近head的        node.pre = self.head        node.next = self.head.next        self.head.next.pre = node        self.head.next = node    def removeNode(self, node): # 删除节点，为后续的操作写基础函数        node.pre.next = node.next        node.next.pre = node.pre    def movetoHead(self, node): # 把原有已存在的节点移动到head后，相当于执行了一次get        self.removeNode(node)        self.addNode(node)    def removeLast(self): # 当实际用量大于容量的时候，则要移除最靠近尾部节点的节点        node = self.tail.pre        self.removeNode(node)        return node # 返回操作是因为node的值去删除字典中的key    def get(self, key: int) -&gt; int:        if key not in self.cache: # 如果key不在缓存中            return -1        node = self.cache[key] # 如果在，返回相应的值，并且移动到头部（因为最新使用过）        self.movetoHead(node)        return node.val    def put(self, key: int, value: int) -&gt; None:        # 如果原本不存在，则加到链表以及字典中，并更新当前使用量        if key not in self.cache:            node = DoublelinkNode(key, value)            self.cache[key] = node            self.addNode(node)            self.size += 1            if self.size &gt; self.capacity:                # 如果容量超过，则需要移除尾部的节点                removed = self.removeLast()                self.cache.pop(removed.key)                self.size -= 1        # 若原本存在则更新值，并移动到头部        else:            node = self.cache[key]            node.val = value            self.movetoHead(node)# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value)\n\n"}]