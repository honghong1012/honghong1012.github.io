[{"title":"Hello World","url":"/2021/12/18/hello-world/","content":"Welcome to my blog! This is my very first post. Actually I’ve been setting up my blog for a long time(even though I often found excuses not to implement anything on the website)\n"},{"title":"关于在winter break摆烂的随笔小记1","url":"/2021/12/20/%E5%85%B3%E4%BA%8E%E5%9C%A8winter-break%E6%91%86%E7%83%82%E7%9A%84%E9%9A%8F%E7%AC%94%E5%B0%8F%E8%AE%B01/","content":"“突然想起了学生公寓门口的拌饺，吃完一顿要打满六个小时的韭菜味饱嗝。以前想不到吃什么的时候总会买一份拌饺加一份水果捞，拎着回宿舍和朋友一起看剧。让人怀念的还有那个摊位卖的福鼎肉片，大晚上偷偷溜出去踩水之后总会买一份的宵夜，想起来总是很快乐的日子。不想看的曾经，但又想分享的曾经。”  \n\n\n\n\n\n本来想在微博上碎碎念的文字，后来突然想起自己刚搭建的秘密基地，也成为了我码字第一个博客的契机。当然了，这种废话文学只能被归类到“随笔”中，那干脆也来写写我winter break中的摆烂一天，好歹也是记录我存在过的证据了。以后我的孙子孙女可以直接摸过来看我的日记咯，还挺有趣的。  \n今天早上是和阿叶约的“芝加哥圣诞集市之行”，一直想去感受一下这边的圣诞氛围，苦于没有车，我和阿叶总是得等到有intercampus的时候，才敢出趟“远门”。去之前倒是很期待在集市里买到可爱的纪念杯，听说上面会印有每年的年份，就蛮有意义。还打算买个我最爱的pretzel和芝士法棍三明治，捧着热红酒慢慢悠悠的逛一圈。  \n然而人们对圣诞的热情还是远超我的想象。有点像市中心“义乌小市场”的圣诞集市，就连进去也要排队，简直是梦回迪士尼四小时玩俩机动游戏的噩梦了。  \n\n\n","categories":["随笔"]},{"title":"巴斯克芝士蛋糕","url":"/2021/12/27/%E5%B7%B4%E6%96%AF%E5%85%8B%E8%8A%9D%E5%A3%AB%E8%9B%8B%E7%B3%95/","content":"材料（此配方可制作6寸巴斯克芝士，8寸则所有用量乘以2）\n奶油奶酪 cream cheese: 350g\n细砂糖 sugar: 75g\n蛋黄 egg yolk: 3个\n全蛋 egg（大): 2个\n淡奶油 heavy whipping cream: 150g\n牛奶 whole milk: 50g\n玉米淀粉/低筋面粉 corn starch/cake flour: 12g\n\n简易做法版本（无电动打蛋器/无料理棒/无筛）\n奶油奶酪加入细砂糖，隔水加热，搅拌至顺滑（不能过火，有可能导致水油分离）\n\n\n\n分次加入3个蛋黄，2个全蛋，搅拌至吸收再加入下一个（鸡蛋可提前从冰箱取出放至室温，减少水油分离可能性）\n\n \n\n加入牛奶，搅拌均匀（有抹茶粉/可可粉则在牛奶后加入）\n\n加入淡奶油，搅拌均匀\n\n加入玉米淀粉，搅拌均匀\n\n烤箱预热，模具铺入烘焙纸（烘焙纸打湿/弄皱后更容易贴合模具）\n\n烤箱中层，220度22-23mins，提前查看表皮上色，上色不够深则移入烤箱上层烘烤2-3mins（我的公寓烤箱拧至一半多些，烘烤20mins后移入烤箱上层，3-4mins）\n\n出炉冷却后保鲜膜包裹起来，无需脱模，冷藏一夜\n\n \n\n可把部分剩余淡奶油打发至六分，结合水果进行装饰\n\n  \n\n\n \n\n\n","categories":["食谱"]},{"title":"动态规划","url":"/2022/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"算法本质动态规划（Dynamic Programming),简称dp问题，dp中的每一个状态由上一个状态推导出来\n构建步骤\n确定dp table及其下标的含义\n确定递推公式\ndp数组初始化\n确定遍历顺序\n举例推导dp数组\n\ndebug方法\n打印tb table\n模拟dp table中的状态转移\n\nleetcode相关题目509.斐波那契数题目链接：https://leetcode-cn.com/problems/fibonacci-number/\n\n本题主要用于熟悉dp\n然而我的做法不是基于dp思路推导，选择了今天算法课上老师说的速度较快，内存占用较小的方法（避免了递归，重复计算）class Solution:    def fib(self, n: int) -&gt; int:        num = []        num.append(0)        num.append(1)        for i in range(n):            temp = num[1]            num[1] = num[0] + num[1]            num[0] = temp        return num[0]\n\n70.爬楼梯（climbing stairs）题目链接：https://leetcode-cn.com/problems/climbing-stairs/\n\ndp[i]：爬到第i层楼的方法数\n由于本题中一次只能跨1或2个台阶，所以dp[i] = dp[i-1] + dp[i-2]\ndp[0]的初始化，本题其实无需讨论，但要做到心里有数\n延伸到一步跨不同台阶数到做法class Solution:    def climbStairs(self, n: int) -&gt; int:        dp = [0] * (n+1)        dp[0] = 1        for i in range(n+1):            for j in range(1,3):                if i &gt;= j:                    dp[i] += dp[i-j] # j的范围可改 适应不同的跨过台阶数        return dp[-1]\n\n746.使用最小花费爬楼梯（min cost climbing stairs)题目链接：\n\ndp[i]:爬到第i层的最小花费\ndp的递推公式其实有两种，每种都考虑到了，但对于不同的递推公式，有不同的初始化\ndp[i] = min(dp[i-1],dp[i-2]) + cost[i] 或 dp[i] = min(dp[i-1]+cost[i-i], dp[i-2]+cost[i-2])我的版本：class Solution:    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:        dp = [0] * (len(cost)+1)        if len(cost) == 2:            return min(cost)        for i in range(2, len(cost)+1):            dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])        return dp[-1]\n\n题解版本：\nclass Solution:    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:        dp = [0] * (len(cost))        dp[0] = cost[0]        dp[1] = cost[1]        for i in range(2, len(cost)):            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]        return min(dp[len(cost) - 1], dp[len(cost) - 2])\n\n62.不同路径（unique paths)题目链接：https://leetcode-cn.com/problems/unique-paths/\n\n题目结合高中数学的知识可推导出dp的递推公式\ndp[i][j] = dp[i-1][j] + dp[i][j-1] 因为只能向右走或者向下走\n所以就引出dp数组的初始化问题，我采用了遍历过程中初始化的方法，也可以直接全部初始化为1，修改遍历的起始点我的版本：class Solution:    def uniquePaths(self, m: int, n: int) -&gt; int:        dp = [[0] * n] * m        for i in range(0, m):            for j in range(0, n):                if i != 0 and j != 0:                    dp[i][j] = dp[i-1][j] + dp[i][j-1]                else:                    dp[i][j] = 1        return dp[-1][-1]\n\n63.不同路径II题目链接：https://leetcode-cn.com/problems/unique-paths-ii/submissions/\n\n在62的基础上，多增设了障碍\n思考过程其实与62相似，dp递推公式类似，而遇到障碍的时候，该维度的dp数组就置0，意味着没有别的通路能够通往此处/或者从此处走出\n判断条件要加上，第一格，第一行，第一列的区别我的版本：class Solution:    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:        m = len(obstacleGrid)        n = len(obstacleGrid[0])        dp = [[0]*n]*m # 构造dp table        for i in range(m):            for j in range(n):                if i != 0 and j != 0:                    if obstacleGrid[i][j] != 1:                        dp[i][j] = dp[i-1][j] + dp[i][j-1]                    else:                        dp[i][j] = 0                elif i == 0 and j != 0: # 第一行                    if obstacleGrid[i][j]!= 1:                        dp[i][j] = dp[i][j-1]                    else:                        dp[i][j] = 0                elif j == 0 and i != 0: # 第一列                    if obstacleGrid[i][j]!= 1:                        dp[i][j] = dp[i-1][j]                    else:                        dp[i][j] = 0                else: # 第一格的情况                    if obstacleGrid[i][j]!= 1:                        dp[i][j] = 1                    else:                        dp[i][j] = 0        return dp[-1][-1]\n\n343.整数拆分题目链接：https://leetcode-cn.com/problems/integer-break/submissions/\n\n本题关键在于如何确定递推公式，将数拆分的过程\n严格意义上dp[0]和dp[1]无需赋值\nO(n^2)class Solution:    def integerBreak(self, n: int) -&gt; int:        dp = [0] * (n+1)        dp[2] = 1        for i in range(3, n+1):            for j in range(1, i-1):                # 假设对正整数i拆分出的第一个数为j（此时遍历j）                # 若将i拆封成两部分：i与i-j的乘积，则此时拆分部分乘积为j*(i-j)                # 若继续将（i-j）进行拆分，则此时拆分部分乘积为j*dp[i-j]                dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j])) # 不断迭代最大值        return dp[n]\n\n","categories":["刷题笔记"]},{"title":"贪心算法（greedy algorithm)","url":"/2021/12/21/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88greedy-algorithm/","content":"算法本质选择每一阶段的局部最优，从而达到全局最优化\n算法应用场景\n无固定套路，常识性推导\n想不到相应的反例，可以试试贪心\n贪心算法跑过测试用例即可，或自圆其说  \n\n贪心一般解题步骤\n将原本问题分解为若干子问题\n找出适合的贪心策略\n求出每个子问题最优解\n将局部最优解堆叠成全局最优解\n\nleetcode相关题目455.分发饼干(assign cookies)题目链接：\n\n数组-&gt;升序排列，遍历\n可用cookies的index来减少for循环层数\n两种思路\n时间复杂度 O(n)\n\nclass solution:    def find(self, g:List[int], s:List[int]) -&gt; int:        g.sort() # 先进行升序排列        s.sort()        index = 0 # 利用cookies下标代替两层for循环        for i in range(len(s)):            if index &lt; len(g) and s[i] &gt;= g[index]: # ！满足的标准和下标移动                index += 1        return index\n\n376.摆动序列（wiggle subsequence)题目链接：\n\n每个峰值的判断（判断单调区间）\n最右峰值的判断\n时间复杂度 O(n)\n\nclass solution:    def wiggleMaxLength(self, nums:List[int]) -&gt; int:        res = 1        cuffix = 0        prefix = 0        for i in range(len(nums)-1):            curfix = nums[i+1] - nums[i]            if curfix * prefix &lt;= 0 and curfix != 0:                res += 1                prefix = curfix        return res \n\n53.最大子序和（）题目链接：\nclass Solution:    def maxSubArray(self, nums: List[int]) -&gt; int:        if nums is None:            return nums        temp = 0        maxsum = nums[0]        for i in range(len(nums)):            temp += nums[i]            if temp &gt; maxsum:                maxsum = temp            if temp &lt; 0:                temp = 0        return maxsum\n\n122.买卖股票的最佳时机（best time to buy and sell stock2)题目链接：\n\n我的做法想的太过复杂，使用了判断单调上升区间卖出计算\n时间复杂度 O(n)  \n\nclass Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        prefix, curfix, profit = 0, 0, 0        begin, end = -1, -1        for i in range(len(prices)-1):            curfix = prices[i+1] - prices[i]            if prefix * curfix &lt;= 0 and curfix &gt; 0: #上升区间起点                begin = prices[i]            if prefix * curfix &lt;= 0 and curfix &lt;= 0 and prefix &gt; 0: #上升区间终点                end = prices[i]            if i+1 == len(prices)-1 and prices[-1] - prices[-2] &gt; 0: #判断list末尾是否为上升区间终点                end = prices[i+1]            if begin != -1 and end != -1: #只有同时找到起点和终点时才能组成一个单调区间                profit += (end - begin)                end, begin = -1, -1            prefix = curfix        return profit\n\n题解版本：\n\n实际上只关注正利润，由于题目中股票持有和卖出的特性\n只要利润为正，就记入总利润中，此特性也可以在画的图中展现出来class Solution:    def maxProfit(self, prices: List[int]) -&gt; int:        result = 0        for i in range(1, len(prices)):            result += max(prices[i] - prices[i - 1], 0)        return result\n\n55.跳跃游戏（jump game）题目链接：https://leetcode-cn.com/problems/jump-game/\n\n局部最优解：可跳跃的最大覆盖范围 整体：能否覆盖到终点\nindex：棋子跳跃的下标 cover：棋子当下能够覆盖到的最远下标\n利用cover限制index，并作为while循环的中断条件class Solution:    def canJump(self, nums: List[int]) -&gt; bool:        if len(nums) == 1:            return True        cover = 0        index = 0        while index &lt;= cover:            cover = max(index+nums[index], cover)            if cover &gt;= len(nums) - 1:                return True            index += 1        return False\n\n45.跳跃游戏II题目链接：https://leetcode-cn.com/problems/jump-game-ii/submissions/本题与55相比，不同之处：45输出能否覆盖终点，本题输出覆盖终点的最小步数\n\n局部：可移动距离中尽可能多走，未到终点则步数加1；整体：一步尽可能多走，达到最小步数\ncurCover：当前可覆盖 nextCover：下一步可覆盖\n注意棋子跳跃的时候边界范围的设定class Solution:    def jump(self, nums: List[int]) -&gt; int:        if len(nums) == 1:            return 0        index, curCover, nextCover = 0, 0, 0        step = 0        while index &lt; len(nums) - 1:            nextCover = max(index+nums[index], nextCover)            if index == curCover:                curCover = nextCover                step += 1            index += 1        return step\n\n1005.k次取反后最大化的数组之和(maximize sum of array after k negations)题目链接：https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/\n\n数组按绝对值由大到小排序\n遍历数组，遇到负数则进行取反，k-=1；k=0时跳出循环\n若遍历完全还有剩余k，则取数组最后一个数（最小的数值）反复取反\nO(n)class Solution:    def largestSumAfterKNegations(self, nums: List[int], k: int) -&gt; int:        nums = sorted(nums, key=abs,reverse=True)        for i in range(len(nums)):            if k &gt; 0:                if nums[i] &lt; 0:                    nums[i] = -nums[i]                    k -= 1                else:                    continue            else:                break        if k &gt; 0:            if k % 2 == 1:                nums[-1] = -nums[-1]        return sum(nums)\n\n134.加油站（gas station）题目链接：https://leetcode-cn.com/problems/gas-station/该题和某公司oa中的魔毯问题一样\n\n如果sum(gas) &lt; sum(cost),那么汽车不可能走完一圈\nres[i] = gas[i] - cost[i]class Solution:    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int:        start, cursum, totalsum =0, 0, 0        for i in range(len(gas)):            cursum += gas[i] - cost[i]            totalsum += gas[i] - cost[i]            if cursum &lt; 0:                start = i + 1                cursum = 0        if totalsum &lt; 0:            return -1        return start\n\n135.分发糖果（candy）题目链接：https://leetcode-cn.com/problems/candy/\n\n关键是思考时不能顾此失彼，从左到右和从右到左遍历一遍\n注意第二次遍历时要考虑到取max\npython的后序遍历range（start,stop,step)class Solution:    def candy(self, ratings: List[int]) -&gt; int:        candyvec = [1] * len(ratings)        for i in range(1, len(ratings)):            if ratings[i] &gt; ratings[i-1]:                candyvec[i] = candyvec[i-1] + 1        for j in range(len(ratings)-2, -1, -1):            if ratings[j] &gt; ratings[j+1]:                candyvec[j] = max(candyvec[j], candyvec[j+1]+1)        return sum(candyvec)\n\n860.柠檬水找零（lemonade change）题目链接：https://leetcode-cn.com/problems/lemonade-change/\n\n常识做题\n后续可优化存储和判断，有部分冗余判断\n没有记录20元的张数，因为找零用不了20元class Solution:    def lemonadeChange(self, bills: List[int]) -&gt; bool:        if bills[0] != 5:            return False        change = [0] * 2        for i in range(len(bills)):            if bills[i] == 5: # 情况1 遇到5直接收下                change[0] += 1            elif bills[i] == 10: # 情况2 遇到10则检查有无5                if change[0] &lt; 1:                    return False                else:                    change[0] -= 1                    change[1] += 1            else: # 情况3 遇到20 先用10元找零，不够再用3张5元                if change[0]*5+change[1]*10&lt;15:                    return False                else:                    if change[0] &lt; 1:                        return False                    else:                        if change[1] &gt;= 1:                            change[1] -= 1                            change[0] -= 1                        else:                            if change[0] &lt; 3:                                return False                            else:                                change[0] -= 3        return True\n\n406.根据身高重建队列（queue restruction by height）题目链接：\n\n本题与分发糖果类似，确定一个维度排序，再根据另外一个维度插入\n先按身高维度 从大到小进行排序：确保前面的节点都比自身高\n后面queue的insert 根据另一个维度进行插入，结合list.insert(index, element)，直接根据第二个维度确定插入的下标class Solution:    def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]:        people = sorted(people, key=lambda x: (-x[0], x[1]))        queue = []        for p in people:            queue.insert(p[1], p)        # print(people)        # print(queue)        return queue\n\n452.用最少数量的箭引爆气球（minimum number of arrows to burst ballons)题目链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/\n\n对区间重叠的问题，有意识从维度排序先入手（本题以任一维度排序都行）\n后序思考太复杂，判断重叠只需要上一区间上边界与下一区间的下边界\n完成判断后要更新边界，以便后续判断class Solution:    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:        points = sorted(points, key= lambda x: (x[0], x[1]))        res = 1        for i in range(1,len(points)):            if points[i][0] &gt; points[i-1][1]:                res += 1            else:                points[i][1] = min(points[i-1][1], points[i][1])        return res\n\n435.无重叠区间(non-overlapping intervals)题目链接：https://leetcode-cn.com/problems/non-overlapping-intervals/\n\n解题思路和452类似\n我的ac和题解版本不太一样\n题解思路：最小移除区间数量 = 总区间数量 - 最大非交叉区间数量题解版本：class Solution:    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        intervals = sorted(intervals, key= lambda x:(x[1])) # 按照右边界排序        count  = 1        end = intervals[0][1]        for i in range(1, len(intervals)):            if intervals[i][0] &gt;= end:                count += 1                end = intervals[i][1]        return len(intervals) - count\n\n我的版本：\nclass Solution:    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        intervals = sorted(intervals, key= lambda x:(x[0])) # 按照左边界排序        res = 0        for i in range(1, len(intervals)):            if intervals[i][0] &lt; intervals[i-1][1]:                res += 1                intervals[i][1] = min(intervals[i-1][1], intervals[i][1])        return res\n\n763.划分字母区间（partition labels）题目链接：https://leetcode-cn.com/problems/partition-labels/\n\n第一次遍历list记录该字母出现的最远下标\n巧妙思路： 第二次遍历字符串时，若index==字母的最远index，则说明此处是分割点（无需记录字母的起始位置）\n别忘更新下一个分割区间起始点的位置：上一个分割index+1class Solution:    def partitionLabels(self, s: str) -&gt; List[int]:        character = [0] * 26 # 记录字符出现的最远位置的下标        for i in range(len(s)):            character[ord(s[i])-ord(&#x27;a&#x27;)] = i        start, end = 0, 0        res = []        for j in range(len(s)):            end = max(end, character[ord(s[j])-ord(&#x27;a&#x27;)])            if end == j:                res.append(end - start + 1)                start = j + 1        return res\n\n56.合并区间（merge intervals）题目链接：https://leetcode-cn.com/problems/merge-intervals/\n\n同样地，先对数组进行按第一维度排序\n通过和res中上一个数组的第二维度进行比较，如果重叠则直接更新第二维度，不重叠则append新的数组class Solution:    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:        intervals.sort(key=lambda x:x[0])        res = []        res.append([intervals[0][0], intervals[0][1]])        for i in range(1, len(intervals)):            if intervals[i][0] &lt;= res[-1][1]:                res[-1][1] = max(res[-1][1], intervals[i][1])            else:                res.append([intervals[i][0],intervals[i][1]])        return res\n\n738.单调递增的数字（monotone increasing digits)题目链接：https://leetcode-cn.com/problems/monotone-increasing-digits/submissions/\n\n首先要观察到判断规律\n从后向前遍历更能利用到数字条件，不用分类讨论下一个数字是大于等于的不同情况\n注意列表/字符串/字符等相互转化的方法 以及填满列表的方法class Solution:    def monotoneIncreasingDigits(self, n: int) -&gt; int:        if n &lt;= 9: return n        if n == 10: return 9        num = list(str(n))        for i in range(len(num)-1,0,-1):            if num[i] &lt; num[i-1]:                num[i-1] = str(int(num[i-1])-1)                num[i:] = &quot;9&quot; * (len(num) - i)        return int(&quot;&quot;.join(num))\n\n","categories":["刷题笔记"]}]